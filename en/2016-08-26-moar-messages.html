<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:400,700&subset=latin,latin-ext" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="../css/bootstrap.css">
    <link rel="alternate" type="application/rss+xml" href="../en/posts.atom">
    <link rel="icon" type="image/vnd.microsoft.icon" href="../favicon.ico">
    <title>Using fedmsg to send more fedmsg</title>
  </head>

  <body id="top">

    <div class="container">
      <h1>Using fedmsg to send more fedmsg</h1>

<div class="row metainfo">
    <div class="col-md-4">
        <a href="../">back to main page</a>
    </div>
    <div class="col-md-4">
        <strong>August 26, 2016</strong>
    </div>

    <div class="col-md-4">
        <span>Tagged as: <a href="../en/tags/fedora.html">Fedora</a>, <a href="../en/tags/fedmsg.html">fedmsg</a>, <a href="../en/tags/python.html">Python</a>.</span>
    </div>
</div>

<div class="post">
    <article>
        <p>Fedmsg is a perfect system for automating things. I mostly use it to integrate <a href="https://pagure.io/">Pagure</a> with <a href="http://jenkins.fedorainfracloud.org/">Jenkins</a>, which works rather well.</p>
<p>One hiccup is that when a pull request is updated (by pushing more commits to the branch or rebasing it), Pagure will not notice that until someone visits the pull request page. At that point a comment with the notice is generated and the message sent.</p>
<p>My first instinct to automate this was to use a git hook. It's easy to automate hitting each pull request page.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">curl</span> -s https://pagure.io/api/0/pungi/pull-requests <span class="kw">|</span> <span class="kw">\</span>
    <span class="kw">jq</span> <span class="st">'.requests[] | select(.user.name == &quot;lsedlar&quot;) | .id'</span> <span class="kw">|</span> <span class="kw">\</span>
    <span class="kw">while</span> <span class="kw">read</span> <span class="ot">PR_ID</span>; <span class="kw">do</span>
        <span class="kw">echo</span> <span class="st">&quot;https://pagure.io/pungi/pull-request/</span><span class="ot">$PR_ID</span><span class="st">&quot;</span>
        <span class="kw">curl</span> -s <span class="st">&quot;https://pagure.io/pungi/pull-request/</span><span class="ot">$PR_ID</span><span class="st">&quot;</span> <span class="kw">&gt;</span>/dev/null
    <span class="kw">done</span></code></pre></div>
<p>However, there <a href="http://stackoverflow.com/a/9038644/1576064">is no <code>post-push</code> hook</a>, so one would have to run the script manually. That's too much work.</p>
<h2 id="fedmsg-to-the-rescue">Fedmsg to the rescue</h2>
<p>How about getting notified about the push from the server? Pagure will send a message announcing a push immediately.</p>
<p>What we need is a very simple consumer that waits for pushes, finds where the pull requests would likely be going to, tries to find one from this branch and hits the web page.</p>
<p>If the push is to a fork, we can assume the pull request would be filed against the original repo. If it's not a fork, then the pull request would probably be against the same repo.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">BASE_URL <span class="op">=</span> <span class="st">'https://pagure.io'</span>


<span class="kw">class</span> Poker(fedmsg.consumers.FedmsgConsumer):
    topic <span class="op">=</span> [<span class="st">'io.pagure.prod.pagure.git.receive'</span>]
    config_key <span class="op">=</span> <span class="st">'poker.enabled'</span>

    <span class="kw">def</span> consume(<span class="va">self</span>, msg):
        msg <span class="op">=</span> msg[<span class="st">'body'</span>][<span class="st">'msg'</span>]
        branch <span class="op">=</span> msg[<span class="st">'branch'</span>].split(<span class="st">'/'</span>)[<span class="op">-</span><span class="dv">1</span>]
        repo <span class="op">=</span> msg[<span class="st">'repo'</span>][<span class="st">'name'</span>]
        <span class="cf">if</span> msg[<span class="st">'repo'</span>][<span class="st">'parent'</span>]:
            repo <span class="op">=</span> msg[<span class="st">'repo'</span>][<span class="st">'parent'</span>][<span class="st">'name'</span>]

        url <span class="op">=</span> <span class="st">'</span><span class="sc">%s</span><span class="st">/api/0/</span><span class="sc">%s</span><span class="st">/pull-requests'</span> <span class="op">%</span> (BASE_URL, repo)
        response <span class="op">=</span> requests.get(url)
        <span class="cf">if</span> response.status_code <span class="op">!=</span> <span class="dv">200</span>:
            <span class="va">self</span>.log.warning(<span class="st">'Failed to get </span><span class="sc">%s</span><span class="st"> ...'</span>, url)
            <span class="cf">return</span>

        <span class="cf">for</span> pr <span class="op">in</span> response.json()[<span class="st">'requests'</span>]:
            <span class="cf">if</span> pr[<span class="st">'repo_from'</span>][<span class="st">'id'</span>] <span class="op">!=</span> msg[<span class="st">'repo'</span>][<span class="st">'id'</span>]:
                <span class="cf">continue</span>
            <span class="cf">if</span> pr[<span class="st">'branch_from'</span>] <span class="op">!=</span> branch:
                <span class="cf">continue</span>
            url <span class="op">=</span> <span class="st">'</span><span class="sc">%s</span><span class="st">/</span><span class="sc">%s</span><span class="st">/pull-request/</span><span class="sc">%s</span><span class="st">'</span> <span class="op">%</span> (BASE_URL, repo, pr[<span class="st">'id'</span>])
            <span class="va">self</span>.log.info(<span class="st">'Poking </span><span class="sc">%s</span><span class="st">'</span>, url)
            requests.get(url)
            <span class="cf">return</span></code></pre></div>
<p>A file with this class should be installed with <code>setup.py</code> somewhere under <code>site-packages</code>. For <code>fedmgs-hub</code> to pick the consumer up, there must be a special section in the <code>setup()</code> function call:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">entry_points<span class="op">=</span><span class="st">&quot;&quot;&quot;</span>
<span class="st">[moksha.consumer]</span>
<span class="st">pokeapagure = poke_a_pagure:Poker</span>
<span class="st">&quot;&quot;&quot;</span></code></pre></div>
<p>The name on the left of the equals sign does not really matter. The string on the right should be a package name and a class name of the consumer. In this case the file will be <code>poke_a_pagure/__init__.py</code>.</p>
<h2 id="how-to-make-it-work">How to make it work</h2>
<p>This consumer will run as part of <code>fedmsg-hub</code> (provided in similarly named package). All that is needed to get it working is to install the hub and the python package with the class.</p>
<p>There also needs to be a config file in <code>/etc/fedmsg.d/poke_a_pagure.py</code>. The name is completely arbitrary, nothing depends on it.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">config <span class="op">=</span> {
    <span class="st">'poker.enabled'</span>: <span class="va">True</span>
}</code></pre></div>
<p>Note the matching config key with the consumer above. There can be more configuration, such as custom rules for logging.</p>
<p>Once that exists, just restart the hub and observe its logs. It will tell you which consumers were loaded.</p>
<p>It's this easy to write a consumer of messages. Now, would it be easier to fix Pagure to send the message immediately? Maybe. But is working with fedmsg fun? Definitely!</p>
    </article>

    <h2 class="comments-header">Comments</h2>

    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function () {
            this.page.url = "https://lubomir.github.io//en/2016-08-26-moar-messages.html";
            this.page.identifier = "/en/2016-08-26-moar-messages.html";
        };
        (function() {
            var d = document, s = d.createElement('script');
            s.src = '//indexoflsedlar.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>

    </div><!-- .container -->

    <footer class="container">
        <ul class="nav nav-pills">
          <li><a href="../">Home</a></li>
          <li><a href="#top">Back to top</a></li>
          <li><a href="mailto:lubomir.sedlar@gmail.com">Contact me</a></li>
          <li class="last"><a href="../cookies.html">Cookies</a></li>
          <li class="license"><a href="http://creativecommons.org/licenses/by/4.0/">
            <img src="../images/cc-by.png" alt="CC-BY" title="Licensed under Creative Commons Attribution"></a>
          </li>
        </ul>
    </footer><!-- .container -->

    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-40665960-1']);
        _gaq.push(['_trackPageview']);
        (function() {
         var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
         ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
         var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
         })();
        window.cookieconsent_options = {"message":"This website uses some cookies.","dismiss":"Got it!","learnMore":"More info","link":"/cookies.html","theme":"dark-floating"};
     </script>
     <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/1.0.9/cookieconsent.min.js"></script>
  </body>
</html>
