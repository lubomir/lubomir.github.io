<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>lsedlar</title>
    <link href="http://lubomir.github.io//en/posts.atom" rel="self" />
    <link href="http://lubomir.github.io/" />
    <id>http://lubomir.github.io//en/posts.atom</id>
    <author>
        <name>Lubomír Sedlář</name>
        <email>lubomir.sedlar@gmail.com</email>
    </author>
    <updated>2014-09-18T00:00:00Z</updated>
    <entry>
    <title>Exploring test case fixtures in Django</title>
    <link href="http://lubomir.github.io//en/2014-09-18-exploring-django-fixtures.html" />
    <id>http://lubomir.github.io//en/2014-09-18-exploring-django-fixtures.html</id>
    <published>2014-09-18T00:00:00Z</published>
    <updated>2014-09-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://www.djangoproject.com/">Django</a> has a nice feature for exploring the environment in which the tests run via the <code>testserver</code> command. You can give it paths to fixture files used in the test case you want and go crazy.</p>
<p>However, this use case becomes really unpleasant once you need to load bigger number of fixtures. It would be much more user friendly if you could instead tell it what test case you want to explore and the script automatically inferred what fixtures to load.</p>
<p>The <code>--help</code> output is silent on this, so let's roll our own solution to this. The script will have two mandatory arguments: module containing the tests and the actual test case name.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">run-test-server.py</span> myapp.tests MyComplicatedTestCase</code></pre></div>
<p>The first idea how to proceed is to simply import the module and look at <code>fixtures</code> attribute of the test case. Sadly, it is not that easy. Importing the module fails with <code>ImproperlyConfiguredException</code> because simply importing a module would be too much to ask for without loading all the <a href="https://www.djangoproject.com/">Django</a> settings. This could be a whole other rant.</p>
<p>Since <code>__import__</code> is slightly more complicated that necessary, let's offload the actual importing to <code>importlib.import_module</code> which works exactly as expected. However, it is only available since Python 2.7.</p>
<p>Once the module is imported, all that needs to be done is to retrieve the test case, its fixtures and fire out the <code>testserver</code> command with appropriate arguments.</p>
<p>The whole script looks as follows. The only unexplained part is the modification of path. This needs to be done so that the script can be located anywhere and still manage to import modules from current directory.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">#! /usr/bin/env python</span>

<span class="ch">import</span> argparse
<span class="ch">from</span> subprocess <span class="ch">import</span> call
<span class="ch">import</span> sys
<span class="ch">import</span> importlib

<span class="ch">from</span> django.conf <span class="ch">import</span> settings


<span class="kw">def</span> get_fixtures(module, case):
    settings.configure()
    parts = module.split(<span class="st">&#39;.&#39;</span>)

    app = importlib.import_module(module)
    <span class="kw">return</span> <span class="dt">getattr</span>(app, case).fixtures


<span class="kw">def</span> main():
    parser = argparse.ArgumentParser()
    parser.add_argument(<span class="st">&#39;MODULE&#39;</span>, <span class="dt">type</span>=<span class="dt">str</span>)
    parser.add_argument(<span class="st">&#39;TEST_CASE&#39;</span>, <span class="dt">type</span>=<span class="dt">str</span>)

    args = parser.parse_args()
    fixtures = get_fixtures(args.MODULE, args.TEST_CASE)

    call([<span class="st">&quot;python&quot;</span>, <span class="st">&quot;manage.py&quot;</span>, <span class="st">&quot;testserver&quot;</span>] + fixtures)


<span class="kw">if</span> <span class="ot">__name__</span> == <span class="st">&#39;__main__&#39;</span>:
    sys.path.append(<span class="st">&#39;.&#39;</span>)
    main()</code></pre></div>
<h2 id="further-improvements">Further improvements</h2>
<p>This script could obviously use a bit more polish:</p>
<ul>
<li>The help output could be more helpful.</li>
<li>If something breaks, the user is presented with a stack trace. Not nice.</li>
</ul>]]></summary>
</entry>
<entry>
    <title>Simulating an elevator</title>
    <link href="http://lubomir.github.io//en/2014-08-31-simulating-an-elevator.html" />
    <id>http://lubomir.github.io//en/2014-08-31-simulating-an-elevator.html</id>
    <published>2014-08-31T00:00:00Z</published>
    <updated>2014-08-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Recently I lived in a building with twelve floors and a very dumb elevator. Multiple times have I stood in front of an elevator and watched as it went by repeatedly refusing to stop and let me on.</p>
<p>There were two elevators, each equipped with a single button that should tell the elevator to come to your floor. However, if the elevator is currently going somewhere, it will ignore your request. You have to wait for it to stop and press the button again. Should someone press it faster, you are out of luck and have to wait for next try.</p>
<p>Obviously, the two elevators do not communicate in any way, so in fact you gamble with two elevators at the same time.</p>
<p>This system seemed very stupid to me, so I decided to create a simple model to verify how much better it would be if the elevator was somewhat smarter.</p>
<h2 id="the-model">The model</h2>
<p>So let's model a building with a single elevator. The simulation will run in turns. At the beginning of each turn, a person can appear at each floor with some probability. All people want to go to the lowest floor (think busy morning). Next, the elevator must decide whether to go up, down, load or unload people or wait.</p>
<p>We will test three different elevator logics. In the simulation, the elevator is represented by a <code>Haskell</code> function with type <code>Building -&gt; Decision</code>, where <code>Building</code> is a data type with information about waiting people and actual position of the elevator.</p>
<p>Note that even the simplest elevator in the simulation is still more elaborate than the one in my building. To simulate that, it would be necessary to choose floor to pick people up at random. This would require the elevator logic to retain some state between each call, which currently is not possible.</p>
<h2 id="the-elevators">The elevators</h2>
<p>The simplest elevator is called <code>dumbElevator</code>, but none-the-less it still is a bit smarter that the one in my former building. This elevator stores each request in a queue and works in a first-come-first-served fashion.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">dumbElevator b
  <span class="fu">|</span> hasPeople b <span class="fu">=</span> <span class="kw">if</span> inBasement b <span class="kw">then</span> <span class="dt">Unload</span> <span class="kw">else</span> <span class="dt">GoDown</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">case</span> (<span class="fu">==</span> b <span class="fu">^.</span> curPosition) <span class="ot">`fmap`</span> (b <span class="fu">^.</span> queue <span class="fu">^?</span> _head) <span class="kw">of</span>
        <span class="dt">Just</span> <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="dt">Load</span>
        <span class="dt">Just</span> <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">GoUp</span>
        <span class="dt">Nothing</span>    <span class="ot">-&gt;</span> <span class="dt">Wait</span></code></pre></div>
<p>If there are people on the elevator, it will take them to the basement and unload. Otherwise it will go to the next floor in the queue and load all the people there.</p>
<p>We will improve this elevator with slightly nicer behavior in <code>niceElevator</code>: when it goes down through a floor with people, it will stop and let on.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">niceElevator b
  <span class="fu">|</span> hasPeople b <span class="fu">=</span> <span class="kw">if</span> inBasement b
                    <span class="kw">then</span> <span class="dt">Unload</span>
                    <span class="kw">else</span> <span class="kw">if</span> peopleOnCurrentFloor b <span class="kw">then</span> <span class="dt">Load</span> <span class="kw">else</span> <span class="dt">GoDown</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> dumbElevator b</code></pre></div>
<p>The last modeled elevator behaves the same as <code>niceElevator</code> when going down. Where it differs is that when it decides where to start loading people, it ignores the order of requests and goes to the highest floor with waiting people.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">smartElevator b
  <span class="fu">|</span> hasPeople b <span class="fu">=</span> niceElevator b
  <span class="fu">|</span> any (<span class="fu">&gt;</span> b <span class="fu">^.</span> curPosition) (b <span class="fu">^.</span> queue) <span class="fu">=</span> <span class="dt">GoUp</span>
  <span class="fu">|</span> peopleOnCurrentFloor b <span class="fu">=</span> <span class="dt">Load</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Wait</span></code></pre></div>
<p>It does not preserve any state. In each turn, it will check if there is a floor above it with people. If so, it will go for them. If not and there are people on current floor, it lets them on, otherwise it will wait. Note that a situation when people are waiting below the elevator can never happen, as the elevator goes up only if it can pick someone up there.</p>
<h2 id="results">Results</h2>
<p>It should not be a surprise that the dumb elevator does not behave very well. The metric that I measured is the average waiting time. Every time a person got on the elevator, their waiting time (current time minus the appearance of this person) was recorded. This way we can determine how bad the elevator is. The number itself does not say much, but a comparison of different elevators does.</p>
<p>The first graph displays the average waiting time with regards to the probability of a person appearing.</p>
<figure>
<img src="/images/elevator/wait-vs-prob-5.png" alt="In a 5 floor building" /><figcaption>In a 5 floor building</figcaption>
</figure>
<p>If the building has more floors, the trend remains the same. The wait time for <em>dumb</em> elevator goes much higher than for the other two elevators. However, the additional cunning of <em>smart</em> elevator does not seem to bring much.</p>
<figure>
<img src="/images/elevator/wait-vs-prob-10.png" alt="In a 10 floor building" /><figcaption>In a 10 floor building</figcaption>
</figure>
<p>It seems from the graphs that at certain point the elevators can no longer deal with the amount of people appearing in the building. The simulation was run for 10000 turns and people who were never picked up do not have any effect on the average time, thus the upper bound on the wait time.</p>
<p>It might also be interesting to have a look at the relation between waiting time and number of floors.</p>
<figure>
<img src="/images/elevator/wait-vs-floors-5.png" alt="For probability 5 %" /><figcaption>For probability 5 %</figcaption>
</figure>
<p>Interestingly, the probability of people appearing has pretty much no influence on the results.</p>
<figure>
<img src="/images/elevator/wait-vs-floors-15.png" alt="For probability 15 %" /><figcaption>For probability 15 %</figcaption>
</figure>
<h2 id="conclusion">Conclusion</h2>
<p>There is one positive result: I don't have to live a with a dumb elevator anymore. The simulation confirmed that a slight improvement in the logic – letting people get on the elevator when it is going down – can have significant impact on average waiting time.</p>
<p>The code used for this is available at <a href="https://github.com/lubomir/elevator">GitHub</a>.</p>]]></summary>
</entry>

</feed>
