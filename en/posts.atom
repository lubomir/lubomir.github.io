<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>lsedlar</title>
    <link href="http://lubomir.github.io//en/posts.atom" rel="self" />
    <link href="http://lubomir.github.io/" />
    <id>http://lubomir.github.io//en/posts.atom</id>
    <author>
        <name>Lubomír Sedlář</name>
        <email>lubomir.sedlar@gmail.com</email>
    </author>
    <updated>2016-02-12T00:00:00Z</updated>
    <entry>
    <title>Today I Learned: Scrolling in screen</title>
    <link href="http://lubomir.github.io//en/2016-02-12-TIL-scrolling-in-screen.html" />
    <id>http://lubomir.github.io//en/2016-02-12-TIL-scrolling-in-screen.html</id>
    <published>2016-02-12T00:00:00Z</published>
    <updated>2016-02-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>By default, <code>screen</code> does not allow scrolling with regular <code>PgUp</code>/<code>PgDn</code> or arrow keys. However, there is a way to move around: the is a <em>copy mode</em>.</p>
<p>This mode can be entered by pressing the regular prefix combination (<code>^A</code>), and then hitting <code>Esc</code>. Moving around is possible with arrow keys. To get back to regular mode hit <code>Esc</code> twice.</p>
<p><a href="http://unix.stackexchange.com/questions/40242/scroll-inside-screen-or-pause-output">Source at Unix Stack Exchange</a>.</p>
<p>Even better option is to put following into <code>.screenrc</code>:</p>
<pre><code>termcapinfo xterm* ti@:te@</code></pre>
<p>This will enable regular scrolling with mouse wheel or terminal scrollbar.</p>
<p><a href="http://unix.stackexchange.com/questions/18006/can-mouse-wheel-scrolling-work-in-a-screen-session">Source at Unix Stack Exchange</a></p>]]></summary>
</entry>
<entry>
    <title>Watching process outputs with Haskell</title>
    <link href="http://lubomir.github.io//en/2016-01-24-watching-process-outputs.html" />
    <id>http://lubomir.github.io//en/2016-01-24-watching-process-outputs.html</id>
    <published>2016-01-24T00:00:00Z</published>
    <updated>2016-01-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>When using <em>docker-compose</em>, I really like how the output printed by the running containers gets interleaved in different colors. I wanted something like that, but for arbitrary commands.</p>
<p>A recent <a href="https://www.reddit.com/r/haskell/comments/41za4n/streaming_a_unix_tools_output_to_haskell/">post on Reddit</a> actually reminded me of that.</p>
<p>I will call the program <code>race</code>, although there are not going to be any winners.</p>
<p>The idea of the program is simple: it will run each process in a separate thread. This runner thread will read the output of the program (both <code>stdout</code> and <code>stderr</code>, I just don't care) and send this to the main thread. This way, there will always single thread writing the actual output.</p>
<p>The communication between threads will happen through <code>Control.Concurrent.Chan</code>, and we will be sending simple messages:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Msg</span> <span class="fu">=</span> <span class="dt">Quit</span>                 <span class="co">-- ^The process finished</span>
         <span class="fu">|</span> <span class="dt">Msg</span> <span class="dt">Int</span> <span class="dt">ByteString</span>   <span class="co">-- ^A single line of output</span></code></pre></div>
<p>The number in the message will indicate which child process is sending the line and will be used to pick a color.</p>
<p>The thread for consuming these messages and printing the data is not too complex. It's a loop that keeps track of the number of running processes. In each iteration, we read a single message from the channel and depending on what it is, we either decrement the process counter or print the message wrapped in ANSI color sequences.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">printer ::</span> <span class="dt">Chan</span> <span class="dt">Msg</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
printer _ <span class="dv">0</span> <span class="fu">=</span> return ()
printer chan num <span class="fu">=</span> <span class="kw">do</span>
    msg <span class="ot">&lt;-</span> readChan chan
    <span class="kw">case</span> msg <span class="kw">of</span>
        <span class="dt">Quit</span> <span class="ot">-&gt;</span> printer chan (num <span class="fu">-</span> <span class="dv">1</span>)
        <span class="dt">Msg</span> i d <span class="ot">-&gt;</span> <span class="kw">do</span>
            B.putStr <span class="fu">$</span> colored i d
            reader chan num

<span class="ot">colored ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span>
colored i d <span class="fu">=</span> <span class="kw">let</span> col <span class="fu">=</span> colors <span class="fu">!!</span> i
              <span class="kw">in</span> <span class="st">&quot;\ESC[&quot;</span> <span class="fu">&lt;&gt;</span> col <span class="fu">&lt;&gt;</span> <span class="st">&quot;;1m&quot;</span> <span class="fu">&lt;&gt;</span> d <span class="fu">&lt;&gt;</span> <span class="st">&quot;\ESC[0m\n&quot;</span>
  <span class="kw">where</span>
    colors <span class="fu">=</span> cycle [<span class="st">&quot;36&quot;</span>, <span class="st">&quot;35&quot;</span>, <span class="st">&quot;32&quot;</span>, <span class="st">&quot;33&quot;</span>, <span class="st">&quot;34&quot;</span>, <span class="st">&quot;31&quot;</span>]</code></pre></div>
<p>Reading the output of a random program is a bit more involved. As input, we will submit the channel, process number and a string with the command.</p>
<p>There is a very <a href="https://www.schoolofhaskell.com/user/snoyberg/library-documentation/data-conduit-process">helpful tutorial</a> for <code>Data.Conduit.Process</code> which contains an example. We can adapt this to our needs.</p>
<p>The biggest hurdle here is that <em>glibc</em> will by default line-buffer standard output if it goes to interactive terminal, but as soon as we redirect it to a pipe, it gets fully buffered in 4 KiB blocks.</p>
<p>This is definitely not what we want. There are a few ways to mitigate this: the easiest is to use <code>stdbuf</code> executable, which modifies the buffering mode. The problem with it is that it does not work for all cases, especially for commands involving piping data between multiple processes.</p>
<p>Another attempt that I made was to use a pseudoterminal. This approach is however quite complex, and I failed to get it running reliably.</p>
<p>In the end I settled for <code>script</code> command. By using the <code>-c</code> argument it can run a complex command and it handles buffering just the way I wanted.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runProcess ::</span> <span class="dt">Chan</span> <span class="dt">Msg</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
runProcess chan&#39; i cmd <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">let</span> cmd&#39; <span class="fu">=</span> <span class="st">&quot;script -qfc \&quot;&quot;</span> <span class="fu">&lt;&gt;</span> cmd <span class="fu">&lt;&gt;</span> <span class="st">&quot;\&quot; /dev/null&quot;</span>
    (<span class="dt">ClosedStream</span>, fromProcess, fromProcessErr, cph) <span class="ot">&lt;-</span>
        streamingProcess (shell cmd&#39;)

    <span class="kw">let</span> output h <span class="fu">=</span> CB.sourceHandle h <span class="fu">$$</span> CB.lines <span class="fu">=$</span> CL.mapM_
            (writeChan chan <span class="fu">.</span> <span class="dt">Msg</span> i)

    _ <span class="ot">&lt;-</span> runConcurrently <span class="fu">$</span>
        <span class="dt">Concurrently</span> (output fromProcess) <span class="fu">*&gt;</span>
        <span class="dt">Concurrently</span> (output fromProcessErr) <span class="fu">*&gt;</span>
        <span class="dt">Concurrently</span> (waitForStreamingProcess cph)

    writeChan chan <span class="dt">Quit</span></code></pre></div>
<p>All that is left to do is to tie it all together: get command line arguments, spawn a thread for each one and run the printer function in the main thread. We will create the channel with one duplicate: the copy will be shared by all worker threads.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    args <span class="ot">&lt;-</span> getArgs
    readEnd <span class="ot">&lt;-</span> newChan
    writeEnd <span class="ot">&lt;-</span> dupChan readEnd

    mapM_ (forkIO <span class="fu">.</span> uncurry (runProcess writeEnd)) (zip [<span class="dv">0</span><span class="fu">..</span>] args)

    reader readEnd (length args)</code></pre></div>
<p>The program can now be used like this:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">race</span> <span class="st">&quot;python -m SimpleHTTPServer&quot;</span> <span class="st">&quot;make rebuild-on-change&quot;</span></code></pre></div>
<p>Arguably, it is just a glorified wrapper for the <code>&amp;</code> Bash functionality and <code>wait</code> command. Nonetheless, I still consider it useful.</p>
<p>You can get <a href="https://github.com/lubomir/race">the whole project</a> including cabal file with list of dependencies on GitHub.</p>]]></summary>
</entry>
<entry>
    <title>Reviewing GitHub pull requests locally</title>
    <link href="http://lubomir.github.io//en/2015-08-01-reviewing-github-pull-request.html" />
    <id>http://lubomir.github.io//en/2015-08-01-reviewing-github-pull-request.html</id>
    <published>2015-08-01T00:00:00Z</published>
    <updated>2015-08-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>GitHub is a great place to collaborate on open-source code. One thing I have struggled with a bit is how to perform code review for pull requests.</p>
<p>If the contributor has access to the actual repository and requests a pull from a branch, it is really trivial. The real issue is with reviewing pull requests coming from forks.</p>
<p>By reviewing, I don't mean just looking over the code. That could be done through the web interface easy enough. Usually, I want to see the code in action, play around with it a test it.</p>
<p>The way GitHub recommends right next to the merge button is to add another remote and checkout a branch from it. This works, but it has the downside of cluttering your local repo with a bunch of not so useful remotes.</p>
<p>Ideally, what I would like is to somehow just create one local branch with the proposed changes.</p>
<p>Turns out GitHub allows just that. There is a ref pointing to the changes created by the pull request. It is easy enough to create a local branch by the following command:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">git</span> fetch origin pull/PULL_REQUEST_ID/head:LOCAL_BRANCH</code></pre></div>
<p>Obviously, the parts in all caps need to be changed to something more useful. After running the command, you can check out the local branch and do anything you want with it. When you are done, simply delete it and everything is the way it was before. It does not get much simpler than that.</p>]]></summary>
</entry>
<entry>
    <title>Exploring test case fixtures in Django</title>
    <link href="http://lubomir.github.io//en/2014-09-18-exploring-django-fixtures.html" />
    <id>http://lubomir.github.io//en/2014-09-18-exploring-django-fixtures.html</id>
    <published>2014-09-18T00:00:00Z</published>
    <updated>2014-09-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://www.djangoproject.com/">Django</a> has a nice feature for exploring the environment in which the tests run via the <code>testserver</code> command. You can give it paths to fixture files used in the test case you want and go crazy.</p>
<p>However, this use case becomes really unpleasant once you need to load bigger number of fixtures. It would be much more user friendly if you could instead tell it what test case you want to explore and the script automatically inferred what fixtures to load.</p>
<p>The <code>--help</code> output is silent on this, so let's roll our own solution to this. The script will have two mandatory arguments: module containing the tests and the actual test case name.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">run-test-server.py</span> myapp.tests MyComplicatedTestCase</code></pre></div>
<p>The first idea how to proceed is to simply import the module and look at <code>fixtures</code> attribute of the test case. Sadly, it is not that easy. Importing the module fails with <code>ImproperlyConfiguredException</code> because simply importing a module would be too much to ask for without loading all the <a href="https://www.djangoproject.com/">Django</a> settings. This could be a whole other rant.</p>
<p>Since <code>__import__</code> is slightly more complicated that necessary, let's offload the actual importing to <code>importlib.import_module</code> which works exactly as expected. However, it is only available since Python 2.7.</p>
<p>Once the module is imported, all that needs to be done is to retrieve the test case, its fixtures and fire out the <code>testserver</code> command with appropriate arguments.</p>
<p>The whole script looks as follows. The only unexplained part is the modification of path. This needs to be done so that the script can be located anywhere and still manage to import modules from current directory.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">#! /usr/bin/env python</span>

<span class="im">import</span> argparse
<span class="im">from</span> subprocess <span class="im">import</span> call
<span class="im">import</span> sys
<span class="im">import</span> importlib

<span class="im">from</span> django.conf <span class="im">import</span> settings


<span class="kw">def</span> get_fixtures(module, case):
    settings.configure()
    parts <span class="op">=</span> module.split(<span class="st">&#39;.&#39;</span>)

    app <span class="op">=</span> importlib.import_module(module)
    <span class="cf">return</span> <span class="bu">getattr</span>(app, case).fixtures


<span class="kw">def</span> main():
    parser <span class="op">=</span> argparse.ArgumentParser()
    parser.add_argument(<span class="st">&#39;MODULE&#39;</span>, <span class="bu">type</span><span class="op">=</span><span class="bu">str</span>)
    parser.add_argument(<span class="st">&#39;TEST_CASE&#39;</span>, <span class="bu">type</span><span class="op">=</span><span class="bu">str</span>)

    args <span class="op">=</span> parser.parse_args()
    fixtures <span class="op">=</span> get_fixtures(args.MODULE, args.TEST_CASE)

    call([<span class="st">&quot;python&quot;</span>, <span class="st">&quot;manage.py&quot;</span>, <span class="st">&quot;testserver&quot;</span>] <span class="op">+</span> fixtures)


<span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:
    sys.path.append(<span class="st">&#39;.&#39;</span>)
    main()</code></pre></div>
<h2 id="further-improvements">Further improvements</h2>
<p>This script could obviously use a bit more polish:</p>
<ul>
<li>The help output could be more helpful.</li>
<li>If something breaks, the user is presented with a stack trace. Not nice.</li>
</ul>]]></summary>
</entry>
<entry>
    <title>Simulating an elevator</title>
    <link href="http://lubomir.github.io//en/2014-08-31-simulating-an-elevator.html" />
    <id>http://lubomir.github.io//en/2014-08-31-simulating-an-elevator.html</id>
    <published>2014-08-31T00:00:00Z</published>
    <updated>2014-08-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Recently I lived in a building with twelve floors and a very dumb elevator. Multiple times have I stood in front of an elevator and watched as it went by repeatedly refusing to stop and let me on.</p>
<p>There were two elevators, each equipped with a single button that should tell the elevator to come to your floor. However, if the elevator is currently going somewhere, it will ignore your request. You have to wait for it to stop and press the button again. Should someone press it faster, you are out of luck and have to wait for next try.</p>
<p>Obviously, the two elevators do not communicate in any way, so in fact you gamble with two elevators at the same time.</p>
<p>This system seemed very stupid to me, so I decided to create a simple model to verify how much better it would be if the elevator was somewhat smarter.</p>
<h2 id="the-model">The model</h2>
<p>So let's model a building with a single elevator. The simulation will run in turns. At the beginning of each turn, a person can appear at each floor with some probability. All people want to go to the lowest floor (think busy morning). Next, the elevator must decide whether to go up, down, load or unload people or wait.</p>
<p>We will test three different elevator logics. In the simulation, the elevator is represented by a <code>Haskell</code> function with type <code>Building -&gt; Decision</code>, where <code>Building</code> is a data type with information about waiting people and actual position of the elevator.</p>
<p>Note that even the simplest elevator in the simulation is still more elaborate than the one in my building. To simulate that, it would be necessary to choose floor to pick people up at random. This would require the elevator logic to retain some state between each call, which currently is not possible.</p>
<h2 id="the-elevators">The elevators</h2>
<p>The simplest elevator is called <code>dumbElevator</code>, but none-the-less it still is a bit smarter that the one in my former building. This elevator stores each request in a queue and works in a first-come-first-served fashion.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">dumbElevator b
  <span class="fu">|</span> hasPeople b <span class="fu">=</span> <span class="kw">if</span> inBasement b <span class="kw">then</span> <span class="dt">Unload</span> <span class="kw">else</span> <span class="dt">GoDown</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">case</span> (<span class="fu">==</span> b <span class="fu">^.</span> curPosition) <span class="ot">`fmap`</span> (b <span class="fu">^.</span> queue <span class="fu">^?</span> _head) <span class="kw">of</span>
        <span class="dt">Just</span> <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="dt">Load</span>
        <span class="dt">Just</span> <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">GoUp</span>
        <span class="dt">Nothing</span>    <span class="ot">-&gt;</span> <span class="dt">Wait</span></code></pre></div>
<p>If there are people on the elevator, it will take them to the basement and unload. Otherwise it will go to the next floor in the queue and load all the people there.</p>
<p>We will improve this elevator with slightly nicer behavior in <code>niceElevator</code>: when it goes down through a floor with people, it will stop and let them on.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">niceElevator b
  <span class="fu">|</span> hasPeople b <span class="fu">=</span> <span class="kw">if</span> inBasement b
                    <span class="kw">then</span> <span class="dt">Unload</span>
                    <span class="kw">else</span> <span class="kw">if</span> peopleOnCurrentFloor b <span class="kw">then</span> <span class="dt">Load</span> <span class="kw">else</span> <span class="dt">GoDown</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> dumbElevator b</code></pre></div>
<p>The last modeled elevator behaves the same as <code>niceElevator</code> when going down. Where it differs is that when it decides where to start loading people, it ignores the order of requests and goes to the highest floor with waiting people.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">smartElevator b
  <span class="fu">|</span> hasPeople b <span class="fu">=</span> niceElevator b
  <span class="fu">|</span> any (<span class="fu">&gt;</span> b <span class="fu">^.</span> curPosition) (b <span class="fu">^.</span> queue) <span class="fu">=</span> <span class="dt">GoUp</span>
  <span class="fu">|</span> peopleOnCurrentFloor b <span class="fu">=</span> <span class="dt">Load</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Wait</span></code></pre></div>
<p>It does not preserve any state. In each turn, it will check if there is a floor above it with people. If so, it will go for them. If not and there are people on current floor, it lets them on, otherwise it will wait. Note that a situation when people are waiting below the elevator can never happen, as the elevator goes up only if it can pick someone up there.</p>
<h2 id="results">Results</h2>
<p>It should not be a surprise that the dumb elevator does not behave very well. The metric that I measured is the average waiting time. Every time a person got on the elevator, their waiting time (current time minus the appearance of this person) was recorded. This way we can determine how bad the elevator is. The number itself does not say much, but a comparison of different elevators does.</p>
<p>The first graph displays the average waiting time with regards to the probability of a person appearing.</p>
<figure>
<img src="/images/elevator/wait-vs-prob-5.png" alt="In a 5 floor building" /><figcaption>In a 5 floor building</figcaption>
</figure>
<p>If the building has more floors, the trend remains the same. The wait time for <em>dumb</em> elevator goes much higher than for the other two elevators. However, the additional cunning of <em>smart</em> elevator does not seem to bring much.</p>
<figure>
<img src="/images/elevator/wait-vs-prob-10.png" alt="In a 10 floor building" /><figcaption>In a 10 floor building</figcaption>
</figure>
<p>It seems from the graphs that at certain point the elevators can no longer deal with the amount of people appearing in the building. The simulation was run for 10000 turns and people who were never picked up do not have any effect on the average time, thus the upper bound on the wait time.</p>
<p>It might also be interesting to have a look at the relation between waiting time and number of floors.</p>
<figure>
<img src="/images/elevator/wait-vs-floors-5.png" alt="For probability 5 %" /><figcaption>For probability 5 %</figcaption>
</figure>
<p>Interestingly, the probability of people appearing has pretty much no influence on the results.</p>
<figure>
<img src="/images/elevator/wait-vs-floors-15.png" alt="For probability 15 %" /><figcaption>For probability 15 %</figcaption>
</figure>
<h2 id="conclusion">Conclusion</h2>
<p>There is one positive result: I don't have to live a with a dumb elevator anymore. The simulation confirmed that a slight improvement in the logic – letting people get on the elevator when it is going down – can have significant impact on average waiting time.</p>
<p>The code used for this is available at <a href="https://github.com/lubomir/elevator">GitHub</a>.</p>]]></summary>
</entry>

</feed>
