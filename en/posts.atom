<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>lsedlar</title>
    <link href="https://lubomir.github.io//en/posts.atom" rel="self" />
    <link href="https://lubomir.github.io/" />
    <id>https://lubomir.github.io//en/posts.atom</id>
    <author>
        <name>Lubomír Sedlář</name>
        <email>lubomir.sedlar@gmail.com</email>
    </author>
    <updated>2016-03-14T00:00:00Z</updated>
    <entry>
    <title>Today I Learned: Packaging bash-completion files</title>
    <link href="https://lubomir.github.io//en/2016-03-14-TIL-packaging-bash-completion.html" />
    <id>https://lubomir.github.io//en/2016-03-14-TIL-packaging-bash-completion.html</id>
    <published>2016-03-14T00:00:00Z</published>
    <updated>2016-03-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Today I ran into this kind of problem for the first time: a package I needed to build installed a bash completion file, and the destination for it was determined by <code>pkg-config</code>. Depending on the system, it would most likely end up in <code>/usr/share/bash-completion/completions/</code> or <code>/etc/bash_completion.d/</code>.</p>
<p>How to write the spec file to handle this dichotomy? Turns out it is not that complicated.</p>
<p>Drop this at the top of spec file and then use <code>%{compdir}</code> in the <code>%files</code> section. Solved.</p>
<pre><code>%define compdir %(pkg-config --variable=completionsdir bash-completion)
%if &quot;%{compdir}&quot; == &quot;&quot;
%define compdir &quot;/etc/bash_completion.d&quot;
%endif</code></pre>
<p>The real gotcha is that the <code>%files</code> section must install the parent of this directory, otherwise the builds will fail with error about two files on one line.</p>]]></summary>
</entry>
<entry>
    <title>Poor Man's CI</title>
    <link href="https://lubomir.github.io//en/2016-03-08-poor-man-ci.html" />
    <id>https://lubomir.github.io//en/2016-03-08-poor-man-ci.html</id>
    <published>2016-03-08T00:00:00Z</published>
    <updated>2016-03-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I have been using <a href="https://pagure.io/">Pagure</a> quite intensively recently and the one thing I miss the most compared to GitHub is some sort of continuous integration. I just want to see the green check appear on my pull requests.</p>
<p>There is a not-very-advertised <a href="https://fedoraproject.org/wiki/Jenkins@infra">Jenkins server</a> used for Fedora Infrastructure. The project I'm working on primarily, <a href="https://pagure.io/pungi">Pungi</a>, has a couple unit tests that are run there after every push to <code>master</code> or some other long-lived branch.</p>
<p>This is a nice start, but leads to problems when new contributors submit their pull requests. Unless someone runs the tests manually, we won't know if they break.</p>
<p>As it turns out, it is quite possible to roll your own service to integrate the two.</p>
<h2 id="apply-mutagen-to-jenkins">Apply mutagen to Jenkins</h2>
<p>Step one on my journey to having CI was to customize the Jenkins job definition to be able to merge pull requests from any repository.</p>
<p>To be able to do so, I added two parameters. One is for the URL to the remote repository, the other for the branch.</p>
<figure>
<img src="/images/poormanci/parameters.png" alt="Jenkins Parameters" /><figcaption>Jenkins Parameters</figcaption>
</figure>
<p>These parameters are available as environment variables in the script that runs the tests. This snippet will add the repo with changes to be tested as a remote and merge the proposed branch on top of master.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">if [</span> <span class="ot">-n</span> <span class="st">&quot;</span><span class="ot">$REPO</span><span class="st">&quot;</span> <span class="ot">-a</span> <span class="ot">-n</span> <span class="st">&quot;</span><span class="ot">$BRANCH</span><span class="st">&quot;</span><span class="kw"> ]</span>; <span class="kw">then</span>
    <span class="kw">git</span> remote rm proposed <span class="kw">||</span> <span class="kw">true</span>
    <span class="kw">git</span> remote add proposed <span class="st">&quot;</span><span class="ot">$REPO</span><span class="st">&quot;</span>
    <span class="kw">git</span> fetch proposed
    <span class="kw">git</span> checkout origin/master
    <span class="kw">git</span> merge --no-ff <span class="st">&quot;proposed/</span><span class="ot">$BRANCH</span><span class="st">&quot;</span> -m <span class="st">&quot;Merge PR&quot;</span>
<span class="kw">fi</span></code></pre></div>
<p>Last part of the Jenkins change is allowing remotely triggered builds. To do this, it is necessary to set up an authentication token. Triggering a build is then a simple HTTP <code>POST</code> request with a <code>?cause=203&amp;REPO=https://example.com/repo.git&amp;BRANCH=merge-this-plz&amp;token=BEEFCAFE</code>.</p>
<p>The <code>cause</code> part is used to keep track of the pull request in question. It will come in handy later.</p>
<p>Since we need to get information about the builds in some way, it is necessary to enable sending messages to Fedmsg as a post-build action.</p>
<h2 id="supercharge-pagure-configuration">Supercharge Pagure configuration</h2>
<p>The configuration on Pagure side is not that complicated. All that needs to be done is enable Fedmsg integration and set up an API key. This key needs to be able to post comments to pull requests.</p>
<h2 id="one-integration-point-to-bind-them-all">One integration point to bind them all</h2>
<p>The last part is to run a service that will listen to the messaging bus and trigger actions as needed. When it hears about new or changed pull request, it should trigger a build in Jenkins. When a build finishes (and is actually a build that verified a pull request), a comment with details should be posted to proper place.</p>
<p>I put the code to do exactly this into a <a href="https://pagure.io/poor-man-ci">poor-man-ci</a> repo on Pagure.</p>
<p>I have deployed this thing on my VPS and so far it seems to be working quite well. Open infrastructure for the win!</p>
<h2 id="implementation-details">Implementation details</h2>
<p>The service is based on the <a href="https://github.com/fedora-infra/pdc-updater">pdc-updater</a> model. There is a consumer running as part of <code>fedmsg-hub</code>. It subscribes to three topics: one from Jenkins, one for new pull requests on Pagure and one for comments on existing pull requests.</p>
<p>As far as I could tell, Pagure does not send a separate message when pull request is updated or rebased. It does however add a comment with this information.</p>
<p>When a message from Pagure is received, the contents must be examined to determine if a build should be triggered. For new pull requests this is completely straightforward. For the update part we need to check if the last comment is one of the known strings and if the pull request is still open.</p>
<p>Messages from Jenkins are a lot simpler. In fact they don't contain pretty much anything but the build number. This is where <a href="http://python-jenkins.readthedocs.org/en/latest/">python-jenkins</a> comes into play. It is a library on top of Jenkins API which makes it relatively easy to get more details about the build. The only part I was interested in was the result (this is actually in the message directly) and the note with pull request number.</p>
<p>Finally the last part is to post a comment to Pagure. This is really trivial, just submit an HTTP <code>POST</code> request.</p>
<h2 id="deploying">Deploying</h2>
<p>Implementation wise, the hardest part for me was to package the whole service and get it running. During most of the development I was using the <code>fedmsg.tail_messages()</code> function, which was probably not meant for this use case.</p>
<p>Ultimately, I just ripped of existing projects, mostly <a href="https://github.com/fedora-infra/pdc-updater">pdc-updater</a> and <a href="https://github.com/fedora-infra/the-new-hotness">the-new-hotness</a>. That helped some, but there are still a couple open questions. For example, I have no idea why the packages do not depend on <code>fedmsg-hub</code> when they clearly need it to run.</p>
<p>My take away points for developing with Fedmsg are these:</p>
<p><strong>Point 1</strong>: Your <code>setup.py</code> must specify an entrypoint for <em>moksha</em>.</p>
<div class="sourceCode"><pre class="sourceCode ini"><code class="sourceCode ini"><span class="kw">[moksha.consumer]</span>
<span class="dt">integrator </span><span class="ot">=</span><span class="st"> poormanci.consumer:Integrator</span></code></pre></div>
<p>This will get installed together with egg-info and the hub will somehow pick it up. The name of the key is not important. The value should point to a Python module containing a subclass of the <code>FedmsgConsumer</code>.</p>
<p><strong>Point 2</strong>: The consumer class should have <code>topic</code> attribute listing all the topics you are interested in, a <code>config_key</code> attribute with the name of the configuration key that controls whether this consumer is enabled and finally a <code>consume</code> method that will be called with the message received.</p>
<p><strong>Point 3</strong>: The configuration file needs to live in <code>/etc/fedmsg.d</code>. Its name is not important. It must be a Python module that defines a single value <code>config</code> as a dict. It should contain at least the configuration code mentioned above to enable the consumer, but can have arbitrary other stuff. I put the API keys there, for example.</p>
<p><strong>Point 4</strong>: The actual packaging (as in how to install the software) is not really important as long as the module with the consumer can be imported and the egg-info directory gets install into Python site lib.</p>
<p><strong>Point 5</strong>: I had to restart the hub to have it pick up updates. This is as easy as <code>systemctl restart fedmsg-hub.service</code>.</p>
<p><strong>Point 6</strong>: I found it helpful to tail the hub logs to see what is happening – <code>journalctl -f -u fedmsg-hub.service</code>. This log also contains traceback when the consumer crashes.</p>]]></summary>
</entry>
<entry>
    <title>Today I Learned: Customizing less</title>
    <link href="https://lubomir.github.io//en/2016-02-18-TIL-customizing-less.html" />
    <id>https://lubomir.github.io//en/2016-02-18-TIL-customizing-less.html</id>
    <published>2016-02-18T00:00:00Z</published>
    <updated>2016-02-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I have been using <code>less</code> wrong. For a long time I have had <code>LESS=-R</code> in my <code>.bashrc</code> to make <code>less</code> display colors.</p>
<p>Ever since I set this, I've had trouble with <code>git</code> paging its output even when it would fit on a single page. This has bothered me, but I did not connect it to the <code>LESS</code> setting.</p>
<p>It turns out that <code>git</code> is quite sophisticated. When its output is paged via <code>less</code>, it looks if <code>LESS</code> env var is set, and sets it to <code>-FRX</code> if it is not.</p>
<p>The <code>-F</code> part is the important one. If tells <code>less</code> to not do anything if the output fits on screen.</p>]]></summary>
</entry>
<entry>
    <title>Today I Learned: Validating XML</title>
    <link href="https://lubomir.github.io//en/2016-02-12-TIL-validating-xml.html" />
    <id>https://lubomir.github.io//en/2016-02-12-TIL-validating-xml.html</id>
    <published>2016-02-12T00:00:00Z</published>
    <updated>2016-02-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This is not rocket science nor brain surgery. I just never needed this and found it practical to note this for further reference.</p>
<p>Setup: I have an XML file and a doctype, each in some place on my hard drive. I want to check whether the document validates against the doctype.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">xmllint</span> --path ./path/to/dir/with/doctype path/to/my.xml --valid</code></pre></div>
<p>If I don't want the formatted output (which I usually don't), there is an option for that: <code>--noout</code> will suppress printing of the result tree.</p>]]></summary>
</entry>
<entry>
    <title>Today I Learned: Scrolling in screen</title>
    <link href="https://lubomir.github.io//en/2016-02-10-TIL-scrolling-in-screen.html" />
    <id>https://lubomir.github.io//en/2016-02-10-TIL-scrolling-in-screen.html</id>
    <published>2016-02-10T00:00:00Z</published>
    <updated>2016-02-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>By default, <code>screen</code> does not allow scrolling with regular <code>PgUp</code>/<code>PgDn</code> or arrow keys. However, there is a way to move around: the is a <em>copy mode</em>.</p>
<p>This mode can be entered by pressing the regular prefix combination (<code>^A</code>), and then hitting <code>Esc</code>. Moving around is possible with arrow keys. To get back to regular mode hit <code>Esc</code> twice.</p>
<p><a href="http://unix.stackexchange.com/questions/40242/scroll-inside-screen-or-pause-output">Source at Unix Stack Exchange</a>.</p>
<p>Even better option is to put following into <code>.screenrc</code>:</p>
<pre><code>termcapinfo xterm* ti@:te@</code></pre>
<p>This will enable regular scrolling with mouse wheel or terminal scrollbar.</p>
<p><a href="http://unix.stackexchange.com/questions/18006/can-mouse-wheel-scrolling-work-in-a-screen-session">Source at Unix Stack Exchange</a></p>]]></summary>
</entry>
<entry>
    <title>Watching process outputs with Haskell</title>
    <link href="https://lubomir.github.io//en/2016-01-24-watching-process-outputs.html" />
    <id>https://lubomir.github.io//en/2016-01-24-watching-process-outputs.html</id>
    <published>2016-01-24T00:00:00Z</published>
    <updated>2016-01-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>When using <em>docker-compose</em>, I really like how the output printed by the running containers gets interleaved in different colors. I wanted something like that, but for arbitrary commands.</p>
<p>A recent <a href="https://www.reddit.com/r/haskell/comments/41za4n/streaming_a_unix_tools_output_to_haskell/">post on Reddit</a> actually reminded me of that.</p>
<p>I will call the program <code>race</code>, although there are not going to be any winners.</p>
<p>The idea of the program is simple: it will run each process in a separate thread. This runner thread will read the output of the program (both <code>stdout</code> and <code>stderr</code>, I just don't care) and send this to the main thread. This way, there will always single thread writing the actual output.</p>
<p>The communication between threads will happen through <code>Control.Concurrent.Chan</code>, and we will be sending simple messages:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Msg</span> <span class="fu">=</span> <span class="dt">Quit</span>                 <span class="co">-- ^The process finished</span>
         <span class="fu">|</span> <span class="dt">Msg</span> <span class="dt">Int</span> <span class="dt">ByteString</span>   <span class="co">-- ^A single line of output</span></code></pre></div>
<p>The number in the message will indicate which child process is sending the line and will be used to pick a color.</p>
<p>The thread for consuming these messages and printing the data is not too complex. It's a loop that keeps track of the number of running processes. In each iteration, we read a single message from the channel and depending on what it is, we either decrement the process counter or print the message wrapped in ANSI color sequences.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">printer ::</span> <span class="dt">Chan</span> <span class="dt">Msg</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
printer _ <span class="dv">0</span> <span class="fu">=</span> return ()
printer chan num <span class="fu">=</span> <span class="kw">do</span>
    msg <span class="ot">&lt;-</span> readChan chan
    <span class="kw">case</span> msg <span class="kw">of</span>
        <span class="dt">Quit</span> <span class="ot">-&gt;</span> printer chan (num <span class="fu">-</span> <span class="dv">1</span>)
        <span class="dt">Msg</span> i d <span class="ot">-&gt;</span> <span class="kw">do</span>
            B.putStr <span class="fu">$</span> colored i d
            reader chan num

<span class="ot">colored ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span>
colored i d <span class="fu">=</span> <span class="kw">let</span> col <span class="fu">=</span> colors <span class="fu">!!</span> i
              <span class="kw">in</span> <span class="st">&quot;\ESC[&quot;</span> <span class="fu">&lt;&gt;</span> col <span class="fu">&lt;&gt;</span> <span class="st">&quot;;1m&quot;</span> <span class="fu">&lt;&gt;</span> d <span class="fu">&lt;&gt;</span> <span class="st">&quot;\ESC[0m\n&quot;</span>
  <span class="kw">where</span>
    colors <span class="fu">=</span> cycle [<span class="st">&quot;36&quot;</span>, <span class="st">&quot;35&quot;</span>, <span class="st">&quot;32&quot;</span>, <span class="st">&quot;33&quot;</span>, <span class="st">&quot;34&quot;</span>, <span class="st">&quot;31&quot;</span>]</code></pre></div>
<p>Reading the output of a random program is a bit more involved. As input, we will submit the channel, process number and a string with the command.</p>
<p>There is a very <a href="https://www.schoolofhaskell.com/user/snoyberg/library-documentation/data-conduit-process">helpful tutorial</a> for <code>Data.Conduit.Process</code> which contains an example. We can adapt this to our needs.</p>
<p>The biggest hurdle here is that <em>glibc</em> will by default line-buffer standard output if it goes to interactive terminal, but as soon as we redirect it to a pipe, it gets fully buffered in 4 KiB blocks.</p>
<p>This is definitely not what we want. There are a few ways to mitigate this: the easiest is to use <code>stdbuf</code> executable, which modifies the buffering mode. The problem with it is that it does not work for all cases, especially for commands involving piping data between multiple processes.</p>
<p>Another attempt that I made was to use a pseudoterminal. This approach is however quite complex, and I failed to get it running reliably.</p>
<p>In the end I settled for <code>script</code> command. By using the <code>-c</code> argument it can run a complex command and it handles buffering just the way I wanted.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runProcess ::</span> <span class="dt">Chan</span> <span class="dt">Msg</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
runProcess chan&#39; i cmd <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">let</span> cmd&#39; <span class="fu">=</span> <span class="st">&quot;script -qfc \&quot;&quot;</span> <span class="fu">&lt;&gt;</span> cmd <span class="fu">&lt;&gt;</span> <span class="st">&quot;\&quot; /dev/null&quot;</span>
    (<span class="dt">ClosedStream</span>, fromProcess, fromProcessErr, cph) <span class="ot">&lt;-</span>
        streamingProcess (shell cmd&#39;)

    <span class="kw">let</span> output h <span class="fu">=</span> CB.sourceHandle h <span class="fu">$$</span> CB.lines <span class="fu">=$</span> CL.mapM_
            (writeChan chan <span class="fu">.</span> <span class="dt">Msg</span> i)

    _ <span class="ot">&lt;-</span> runConcurrently <span class="fu">$</span>
        <span class="dt">Concurrently</span> (output fromProcess) <span class="fu">*&gt;</span>
        <span class="dt">Concurrently</span> (output fromProcessErr) <span class="fu">*&gt;</span>
        <span class="dt">Concurrently</span> (waitForStreamingProcess cph)

    writeChan chan <span class="dt">Quit</span></code></pre></div>
<p>All that is left to do is to tie it all together: get command line arguments, spawn a thread for each one and run the printer function in the main thread. We will create the channel with one duplicate: the copy will be shared by all worker threads.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    args <span class="ot">&lt;-</span> getArgs
    readEnd <span class="ot">&lt;-</span> newChan
    writeEnd <span class="ot">&lt;-</span> dupChan readEnd

    mapM_ (forkIO <span class="fu">.</span> uncurry (runProcess writeEnd)) (zip [<span class="dv">0</span><span class="fu">..</span>] args)

    reader readEnd (length args)</code></pre></div>
<p>The program can now be used like this:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">race</span> <span class="st">&quot;python -m SimpleHTTPServer&quot;</span> <span class="st">&quot;make rebuild-on-change&quot;</span></code></pre></div>
<p>Arguably, it is just a glorified wrapper for the <code>&amp;</code> Bash functionality and <code>wait</code> command. Nonetheless, I still consider it useful.</p>
<p>You can get <a href="https://github.com/lubomir/race">the whole project</a> including cabal file with list of dependencies on GitHub.</p>]]></summary>
</entry>
<entry>
    <title>Reviewing GitHub pull requests locally</title>
    <link href="https://lubomir.github.io//en/2015-08-01-reviewing-github-pull-request.html" />
    <id>https://lubomir.github.io//en/2015-08-01-reviewing-github-pull-request.html</id>
    <published>2015-08-01T00:00:00Z</published>
    <updated>2015-08-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>GitHub is a great place to collaborate on open-source code. One thing I have struggled with a bit is how to perform code review for pull requests.</p>
<p>If the contributor has access to the actual repository and requests a pull from a branch, it is really trivial. The real issue is with reviewing pull requests coming from forks.</p>
<p>By reviewing, I don't mean just looking over the code. That could be done through the web interface easy enough. Usually, I want to see the code in action, play around with it a test it.</p>
<p>The way GitHub recommends right next to the merge button is to add another remote and checkout a branch from it. This works, but it has the downside of cluttering your local repo with a bunch of not so useful remotes.</p>
<p>Ideally, what I would like is to somehow just create one local branch with the proposed changes.</p>
<p>Turns out GitHub allows just that. There is a ref pointing to the changes created by the pull request. It is easy enough to create a local branch by the following command:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">git</span> fetch origin pull/PULL_REQUEST_ID/head:LOCAL_BRANCH</code></pre></div>
<p>Obviously, the parts in all caps need to be changed to something more useful. After running the command, you can check out the local branch and do anything you want with it. When you are done, simply delete it and everything is the way it was before. It does not get much simpler than that.</p>]]></summary>
</entry>
<entry>
    <title>Exploring test case fixtures in Django</title>
    <link href="https://lubomir.github.io//en/2014-09-18-exploring-django-fixtures.html" />
    <id>https://lubomir.github.io//en/2014-09-18-exploring-django-fixtures.html</id>
    <published>2014-09-18T00:00:00Z</published>
    <updated>2014-09-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://www.djangoproject.com/">Django</a> has a nice feature for exploring the environment in which the tests run via the <code>testserver</code> command. You can give it paths to fixture files used in the test case you want and go crazy.</p>
<p>However, this use case becomes really unpleasant once you need to load bigger number of fixtures. It would be much more user friendly if you could instead tell it what test case you want to explore and the script automatically inferred what fixtures to load.</p>
<p>The <code>--help</code> output is silent on this, so let's roll our own solution to this. The script will have two mandatory arguments: module containing the tests and the actual test case name.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">run-test-server.py</span> myapp.tests MyComplicatedTestCase</code></pre></div>
<p>The first idea how to proceed is to simply import the module and look at <code>fixtures</code> attribute of the test case. Sadly, it is not that easy. Importing the module fails with <code>ImproperlyConfiguredException</code> because simply importing a module would be too much to ask for without loading all the <a href="https://www.djangoproject.com/">Django</a> settings. This could be a whole other rant.</p>
<p>Since <code>__import__</code> is slightly more complicated that necessary, let's offload the actual importing to <code>importlib.import_module</code> which works exactly as expected. However, it is only available since Python 2.7.</p>
<p>Once the module is imported, all that needs to be done is to retrieve the test case, its fixtures and fire out the <code>testserver</code> command with appropriate arguments.</p>
<p>The whole script looks as follows. The only unexplained part is the modification of path. This needs to be done so that the script can be located anywhere and still manage to import modules from current directory.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">#! /usr/bin/env python</span>

<span class="im">import</span> argparse
<span class="im">from</span> subprocess <span class="im">import</span> call
<span class="im">import</span> sys
<span class="im">import</span> importlib

<span class="im">from</span> django.conf <span class="im">import</span> settings


<span class="kw">def</span> get_fixtures(module, case):
    settings.configure()
    parts <span class="op">=</span> module.split(<span class="st">&#39;.&#39;</span>)

    app <span class="op">=</span> importlib.import_module(module)
    <span class="cf">return</span> <span class="bu">getattr</span>(app, case).fixtures


<span class="kw">def</span> main():
    parser <span class="op">=</span> argparse.ArgumentParser()
    parser.add_argument(<span class="st">&#39;MODULE&#39;</span>, <span class="bu">type</span><span class="op">=</span><span class="bu">str</span>)
    parser.add_argument(<span class="st">&#39;TEST_CASE&#39;</span>, <span class="bu">type</span><span class="op">=</span><span class="bu">str</span>)

    args <span class="op">=</span> parser.parse_args()
    fixtures <span class="op">=</span> get_fixtures(args.MODULE, args.TEST_CASE)

    call([<span class="st">&quot;python&quot;</span>, <span class="st">&quot;manage.py&quot;</span>, <span class="st">&quot;testserver&quot;</span>] <span class="op">+</span> fixtures)


<span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:
    sys.path.append(<span class="st">&#39;.&#39;</span>)
    main()</code></pre></div>
<h2 id="further-improvements">Further improvements</h2>
<p>This script could obviously use a bit more polish:</p>
<ul>
<li>The help output could be more helpful.</li>
<li>If something breaks, the user is presented with a stack trace. Not nice.</li>
</ul>]]></summary>
</entry>
<entry>
    <title>Simulating an elevator</title>
    <link href="https://lubomir.github.io//en/2014-08-31-simulating-an-elevator.html" />
    <id>https://lubomir.github.io//en/2014-08-31-simulating-an-elevator.html</id>
    <published>2014-08-31T00:00:00Z</published>
    <updated>2014-08-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Recently I lived in a building with twelve floors and a very dumb elevator. Multiple times have I stood in front of an elevator and watched as it went by repeatedly refusing to stop and let me on.</p>
<p>There were two elevators, each equipped with a single button that should tell the elevator to come to your floor. However, if the elevator is currently going somewhere, it will ignore your request. You have to wait for it to stop and press the button again. Should someone press it faster, you are out of luck and have to wait for next try.</p>
<p>Obviously, the two elevators do not communicate in any way, so in fact you gamble with two elevators at the same time.</p>
<p>This system seemed very stupid to me, so I decided to create a simple model to verify how much better it would be if the elevator was somewhat smarter.</p>
<h2 id="the-model">The model</h2>
<p>So let's model a building with a single elevator. The simulation will run in turns. At the beginning of each turn, a person can appear at each floor with some probability. All people want to go to the lowest floor (think busy morning). Next, the elevator must decide whether to go up, down, load or unload people or wait.</p>
<p>We will test three different elevator logics. In the simulation, the elevator is represented by a <code>Haskell</code> function with type <code>Building -&gt; Decision</code>, where <code>Building</code> is a data type with information about waiting people and actual position of the elevator.</p>
<p>Note that even the simplest elevator in the simulation is still more elaborate than the one in my building. To simulate that, it would be necessary to choose floor to pick people up at random. This would require the elevator logic to retain some state between each call, which currently is not possible.</p>
<h2 id="the-elevators">The elevators</h2>
<p>The simplest elevator is called <code>dumbElevator</code>, but none-the-less it still is a bit smarter that the one in my former building. This elevator stores each request in a queue and works in a first-come-first-served fashion.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">dumbElevator b
  <span class="fu">|</span> hasPeople b <span class="fu">=</span> <span class="kw">if</span> inBasement b <span class="kw">then</span> <span class="dt">Unload</span> <span class="kw">else</span> <span class="dt">GoDown</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">case</span> (<span class="fu">==</span> b <span class="fu">^.</span> curPosition) <span class="ot">`fmap`</span> (b <span class="fu">^.</span> queue <span class="fu">^?</span> _head) <span class="kw">of</span>
        <span class="dt">Just</span> <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="dt">Load</span>
        <span class="dt">Just</span> <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">GoUp</span>
        <span class="dt">Nothing</span>    <span class="ot">-&gt;</span> <span class="dt">Wait</span></code></pre></div>
<p>If there are people on the elevator, it will take them to the basement and unload. Otherwise it will go to the next floor in the queue and load all the people there.</p>
<p>We will improve this elevator with slightly nicer behavior in <code>niceElevator</code>: when it goes down through a floor with people, it will stop and let them on.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">niceElevator b
  <span class="fu">|</span> hasPeople b <span class="fu">=</span> <span class="kw">if</span> inBasement b
                    <span class="kw">then</span> <span class="dt">Unload</span>
                    <span class="kw">else</span> <span class="kw">if</span> peopleOnCurrentFloor b <span class="kw">then</span> <span class="dt">Load</span> <span class="kw">else</span> <span class="dt">GoDown</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> dumbElevator b</code></pre></div>
<p>The last modeled elevator behaves the same as <code>niceElevator</code> when going down. Where it differs is that when it decides where to start loading people, it ignores the order of requests and goes to the highest floor with waiting people.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">smartElevator b
  <span class="fu">|</span> hasPeople b <span class="fu">=</span> niceElevator b
  <span class="fu">|</span> any (<span class="fu">&gt;</span> b <span class="fu">^.</span> curPosition) (b <span class="fu">^.</span> queue) <span class="fu">=</span> <span class="dt">GoUp</span>
  <span class="fu">|</span> peopleOnCurrentFloor b <span class="fu">=</span> <span class="dt">Load</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Wait</span></code></pre></div>
<p>It does not preserve any state. In each turn, it will check if there is a floor above it with people. If so, it will go for them. If not and there are people on current floor, it lets them on, otherwise it will wait. Note that a situation when people are waiting below the elevator can never happen, as the elevator goes up only if it can pick someone up there.</p>
<h2 id="results">Results</h2>
<p>It should not be a surprise that the dumb elevator does not behave very well. The metric that I measured is the average waiting time. Every time a person got on the elevator, their waiting time (current time minus the appearance of this person) was recorded. This way we can determine how bad the elevator is. The number itself does not say much, but a comparison of different elevators does.</p>
<p>The first graph displays the average waiting time with regards to the probability of a person appearing.</p>
<figure>
<img src="/images/elevator/wait-vs-prob-5.png" alt="In a 5 floor building" /><figcaption>In a 5 floor building</figcaption>
</figure>
<p>If the building has more floors, the trend remains the same. The wait time for <em>dumb</em> elevator goes much higher than for the other two elevators. However, the additional cunning of <em>smart</em> elevator does not seem to bring much.</p>
<figure>
<img src="/images/elevator/wait-vs-prob-10.png" alt="In a 10 floor building" /><figcaption>In a 10 floor building</figcaption>
</figure>
<p>It seems from the graphs that at certain point the elevators can no longer deal with the amount of people appearing in the building. The simulation was run for 10000 turns and people who were never picked up do not have any effect on the average time, thus the upper bound on the wait time.</p>
<p>It might also be interesting to have a look at the relation between waiting time and number of floors.</p>
<figure>
<img src="/images/elevator/wait-vs-floors-5.png" alt="For probability 5 %" /><figcaption>For probability 5 %</figcaption>
</figure>
<p>Interestingly, the probability of people appearing has pretty much no influence on the results.</p>
<figure>
<img src="/images/elevator/wait-vs-floors-15.png" alt="For probability 15 %" /><figcaption>For probability 15 %</figcaption>
</figure>
<h2 id="conclusion">Conclusion</h2>
<p>There is one positive result: I don't have to live a with a dumb elevator anymore. The simulation confirmed that a slight improvement in the logic – letting people get on the elevator when it is going down – can have significant impact on average waiting time.</p>
<p>The code used for this is available at <a href="https://github.com/lubomir/elevator">GitHub</a>.</p>]]></summary>
</entry>

</feed>
