<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>lsedlar – Posts tagged compose</title>
    <link href="https://lubomir.github.io/en/tags/compose.atom" rel="self" />
    <link href="https://lubomir.github.io" />
    <id>https://lubomir.github.io/en/tags/compose.atom</id>
    <author>
        <name>Lubomír Sedlář</name>
        <email>lubomir.sedlar@gmail.com</email>
    </author>
    <updated>2017-07-13T08:28:59Z</updated>
    <entry>
    <title>A compose what?</title>
    <link href="https://lubomir.github.io/en/2017-07-12-a-compose-what.html" />
    <id>https://lubomir.github.io/en/2017-07-12-a-compose-what.html</id>
    <published>2017-07-12T00:00:00Z</published>
    <updated>2017-07-13T08:28:59Z</updated>
    <summary type="html"><![CDATA[<p>Kushal wrote <a href="https://kushaldas.in/posts/story-of-mashing-in-bodhi-fedora-updates-system.html">a nice post about how package updates</a> get into repositories. However he glosses over rawhide by saying it happens automatically. This is true, but I want to elaborate on the mechanism of how it happens..</p>
<p>A package build for Rawhide is not available in the repositories immediately. It has to wait until a nightly Rawhide compose runs that updates the repo.</p>
<p>Let's take a dive into what exactly the compose does and is.</p>
<h2 id="terminology">Terminology</h2>
<p>A compose is a snapshot of a release with a specific identity (which is determined by the actual release and date when it was created, like <code>Fedora-Rawhide-20170710.n.0</code>). It consists of at least one variant (such as <code>Server</code>, <code>Workstation</code> or <code>Everything</code>). A variant is a subset of the content from a release that is aimed for particular use case.</p>
<p>Generally a variant in the final compose contains a repo with RPMs and other artefacts like images of various kinds.</p>
<p>The compose is created by a tool called <a href="https://pagure.io/pungi">Pungi</a>. Current major version 4 is significantly different to previous version in that it integrates with Koji and delegates as much work as possible to it (for better tracking and reproducibility).</p>
<p>The main input for Pungi is <a href="https://pagure.io/pungi-fedora">a configuration file</a> that can get quite complicated, due to all the extra artifacts like images. I'm only going to focus on the most common use case here.</p>
<h2 id="getting-the-packages">Getting the packages</h2>
<p>The process for defining what packages will go into the compose actually consists of two steps. First we need to find out the latest builds in Koji and find appropriately signed copies of the packages on the local file system (we need to have the same volume that Koji uses mounted locally).</p>
<p>For nightly composes of Rawhide or branched the appropriate <code>f2X</code> tag is used. In milestone composes (where packages with freeze exception or fixes for accepted blockers are supposed to get in), there's a special <code>f2X-compose</code> tag that inherits from <code>f2X</code> and this way other packages can get into the compose.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">koji</span> list-tag-inheritance f26-compose
<span class="kw">f26-compose</span> (368)
  └─<span class="kw">f26</span> (357)</code></pre></div>
<p>The second step is to determine which packages are supposed to go into each variant. Each <a href="https://pagure.io/pungi-fedora/blob/master/f/variants-fedora.xml">variant defines a list of comps groups</a>. Packages from those groups will be pulled in together with all of their dependencies. This process needs to run once for each architecture on each variant.</p>
<p>There are of course exceptions here: additional packages not in comps can be pulled in, and also there are <a href="https://docs.pagure.org/pungi/configuration.html#gather-settings">configuration options</a> to customize multilib rules and tweak other things.</p>
<h2 id="creating-repositories">Creating repositories</h2>
<p>Once we have the package lists, we can call <code>createrepo_c</code> and create the actual metadata. The list of packages is actually part of the metadata in the final compose. Usually it's a really big file located in <code>compose/metadata/rpms.json</code> (which is way too big to link here, but you can read <a href="http://productmd.readthedocs.io/en/latest/rpms-1.1.html">description of the format</a>).</p>
<h2 id="building-images">Building images</h2>
<p>There are multiple different images that can be built as part of the compose. Most work starts by calling <a href="https://github.com/rhinstaller/lorax">lorax</a> to create <code>boot.iso</code> and boot configuration files. This image is directly used as the <em>netinstall</em> media.</p>
<p>Pungi can then create DVD images that include the repository. In Fedora this is currently only used for <em>Server</em> variant. This is done by basically taking the <code>boot.iso</code> and adding additional stuff to it.</p>
<p>Spins and Labs are created in Koji using <code>livemedia-creator</code> (a <code>livemedia</code> task). This takes additional input of <a href="https://pagure.io/fedora-kickstarts">a kickstart file</a> defining how that particular image should be created. The packages that are installed are taken from the repos created in the compose.</p>
<h2 id="how-is-it-triggered">How is it triggered?</h2>
<p>The nightly compose is started by a cron job that clones the latest configuration, runs the compose, and if it finishes successfully, it syncs the content to mirrors and sends e-mails about changes in packages.</p>
<p>Branched composes have the same nightly process. Milestone composes are created in a similar way, but are started manually (because they require label via a command line argument).</p>
<h2 id="conclusion">Conclusion</h2>
<p>That concludes the high level overview. <a href="https://docs.pagure.org/pungi/">The official documentation</a> will go into a bit more detail once Pungi 4.1.17 is released.</p>]]></summary>
</entry>

</feed>
