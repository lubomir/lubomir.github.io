<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>lsedlar – Posts tagged testing</title>
    <link href="https://lubomir.github.io/en/tags/testing.atom" rel="self" />
    <link href="https://lubomir.github.io" />
    <id>https://lubomir.github.io/en/tags/testing.atom</id>
    <author>
        <name>Lubomír Sedlář</name>
        <email>lubomir.sedlar@gmail.com</email>
    </author>
    <updated>2016-04-27T10:13:24Z</updated>
    <entry>
    <title>Slightly Richer Man's CI</title>
    <link href="https://lubomir.github.io/en/2016-04-26-slightly-richer-man-ci.html" />
    <id>https://lubomir.github.io/en/2016-04-26-slightly-richer-man-ci.html</id>
    <published>2016-04-26T00:00:00Z</published>
    <updated>2016-04-27T10:13:24Z</updated>
    <summary type="html"><![CDATA[<p>Not so long ago I have written about <a href="/en/2016-03-08-poor-man-ci.html">my attempts to bring CI to Pagure</a>. It was pointed out to me that a couple assumptions I've made are actually incorrect.</p>
<p>Here are the errata:</p>
<ul>
<li><p>When a pull request is updated or rebased, there is no need to check the message body. <a href="https://pagure.io/">Pagure</a> already puts this information into the message (look for <code>notification: true</code>).</p></li>
<li><p>Using comments for indicating status is too clumsy, especially given the fact there is a feature designed to communicate exactly this type of information – flags. Setting a flag is pretty much the same as posting a comment, but they appear in a sidebar with a link and some text. You can also add a percentage to it that will determine the color of a badge.</p></li>
<li><p>The <em>Fedmsg</em> hook that you can enable in the project settings is actually not required. I misunderstood what it does. The notifications on new pull requests get send automatically without any change in configuration required.</p>
<p>The hook is actually git <code>post-receive</code> hook that will send you <del>tons of</del> e-mail through the <a href="https://apps.fedoraproject.org/notifications">Fedora notification</a> system whenever a commit is pushed to master without going through a pull-request.</p>
<p>UPDATE: Since Pagure 2.0 the hook will send only one e-mail on each push.</p></li>
</ul>
<p>Anyway, fixing these is quite simple.</p>
<p>While the setup described in previous post worked fine for my use case, it was not ideal. One of the biggest issues is the configuration: adding stuff to <code>/etc</code> is not a scalable model. First order of business was to create a web interface where the configuration could be managed. Added benefit: with a decent authentication system (yes, FAS does nicely) it's possible for anyone to configure their integration points.</p>
<figure>
<img src="/images/poormanci/index.png" alt="Screenshot of index page" /><figcaption>Screenshot of index page</figcaption>
</figure>
<h2 id="jenkins-wants-a-voice-too">Jenkins wants a voice too</h2>
<p>Another big drawback is the dependency on Fedora Infrastructure Jenkins. While setting up your own Jenkins is easy (approx. three clicks on <a href="https://www.openshift.com/">OpenShift</a>), connecting it to production <em>Fedmsg</em> is probably not (I don't know, did not try).</p>
<p>Since there is now a web server for the interface, it is not a big step to support web hooks. There is a <a href="https://wiki.jenkins-ci.org/display/JENKINS/Notification+Plugin">Notification plugin</a> for Jenkins that can ping a URL with JSON data whenever a job finishes.</p>
<p>The real message contains a ton of data, but for this use-case only project name and build number are really interesting. As long as this data is supplied, we are happy.</p>
<div class="sourceCode"><pre class="sourceCode json"><code class="sourceCode json"><span class="fu">{</span>
    <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;asgard&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;build&quot;</span><span class="fu">:</span> <span class="fu">{</span>
        <span class="dt">&quot;number&quot;</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span>
    <span class="fu">}</span>
<span class="fu">}</span></code></pre></div>
<p>If instead of web requests the plugin gives you stack traces, try setting log lines to 1.</p>
<figure>
<img src="/images/poormanci/notification.png" alt="Plugin configuration" /><figcaption>Plugin configuration</figcaption>
</figure>
<p>(No, that is not an actual token in the shown URL. No need to try.)</p>
<h2 id="here-we-are-and-there-we-go">Here we are and there we go</h2>
<p>The semi-finished service is available at <a href="http://poormanci.lsedlar.cz/" class="uri">http://poormanci.lsedlar.cz/</a>. The documentation really is lacking, though. The best guide how to use it is <a href="/en/2016-03-08-poor-man-ci.html">the previous blog post</a> or <a href="http://poormanci.lsedlar.cz/help">a somewhat work-in-progress help page</a>.</p>
<p>Now there is still a ton of things to improve. Currently, all requests to external services are sent directly from the fedmsg consumer or web app process. Since these are blocking and could potentially take a long time, it's a prime candidate for denial-of-service. I need to refactor this into a separate worker process.</p>
<p>Another thing to add would be the support for a web hook sent from Pagure. This would make it possible to use a custom instance. First I need to learn what data is actually sent in the HTTP request.</p>
<p>UPDATE: This is actually <a href="https://docs.pagure.org/pagure/usage/using_webhooks.html">documented</a> and the hook contains the same information that the Fedmsg notification has.</p>
<p>Another point of improvement is the deployment of the whole thing. Currently, I build everything <a href="https://copr.fedorainfracloud.org/coprs/lsedlar/poor-man-ci/">in COPR</a>, install the RPM and do any database migrations almost by hand. The initial setup was also manual. I plan to write an Ansible playbook to make future deployments simpler. It will also document the process a bit.</p>
<p>Next item on the list is support for multi-configuration projects in Jenkins. The Matrix plugin in Jenkins allows a single test suite to run on multiple builders (e.g. with different Python versions). I want to support such configuration too, but the <em>Fedmsg</em> integration will not do here. <a href="https://apps.fedoraproject.org/datagrepper/id?id=2016-ef190673-90c3-4947-b82f-a909d870d53f&amp;is_raw=true&amp;size=extra-large">The messages</a> from such builds are not particularly helpful. I have reported <a href="https://github.com/fedora-infra/jenkins-fedmsg-emit/issues/3">the issue</a> upstream, but I'm really in no position to go fix the Java code.</p>
<p>The reporting from the notification plugin works well, though.</p>]]></summary>
</entry>
<entry>
    <title>Poor Man's CI</title>
    <link href="https://lubomir.github.io/en/2016-03-08-poor-man-ci.html" />
    <id>https://lubomir.github.io/en/2016-03-08-poor-man-ci.html</id>
    <published>2016-03-08T00:00:00Z</published>
    <updated>2016-03-08T20:39:11Z</updated>
    <summary type="html"><![CDATA[<p>I have been using <a href="https://pagure.io/">Pagure</a> quite intensively recently and the one thing I miss the most compared to GitHub is some sort of continuous integration. I just want to see the green check appear on my pull requests.</p>
<p>There is a not-very-advertised <a href="https://fedoraproject.org/wiki/Jenkins@infra">Jenkins server</a> used for Fedora Infrastructure. The project I'm working on primarily, <a href="https://pagure.io/pungi">Pungi</a>, has a couple unit tests that are run there after every push to <code>master</code> or some other long-lived branch.</p>
<p>This is a nice start, but leads to problems when new contributors submit their pull requests. Unless someone runs the tests manually, we won't know if they break.</p>
<p>As it turns out, it is quite possible to roll your own service to integrate the two.</p>
<h2 id="apply-mutagen-to-jenkins">Apply mutagen to Jenkins</h2>
<p>Step one on my journey to having CI was to customize the Jenkins job definition to be able to merge pull requests from any repository.</p>
<p>To be able to do so, I added two parameters. One is for the URL to the remote repository, the other for the branch.</p>
<figure>
<img src="/images/poormanci/parameters.png" alt="Jenkins Parameters" /><figcaption>Jenkins Parameters</figcaption>
</figure>
<p>These parameters are available as environment variables in the script that runs the tests. This snippet will add the repo with changes to be tested as a remote and merge the proposed branch on top of master.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">if [</span> <span class="ot">-n</span> <span class="st">&quot;</span><span class="ot">$REPO</span><span class="st">&quot;</span> <span class="ot">-a</span> <span class="ot">-n</span> <span class="st">&quot;</span><span class="ot">$BRANCH</span><span class="st">&quot;</span><span class="kw"> ]</span>; <span class="kw">then</span>
    <span class="kw">git</span> remote rm proposed <span class="kw">||</span> <span class="kw">true</span>
    <span class="kw">git</span> remote add proposed <span class="st">&quot;</span><span class="ot">$REPO</span><span class="st">&quot;</span>
    <span class="kw">git</span> fetch proposed
    <span class="kw">git</span> checkout origin/master
    <span class="kw">git</span> merge --no-ff <span class="st">&quot;proposed/</span><span class="ot">$BRANCH</span><span class="st">&quot;</span> -m <span class="st">&quot;Merge PR&quot;</span>
<span class="kw">fi</span></code></pre></div>
<p>Last part of the Jenkins change is allowing remotely triggered builds. To do this, it is necessary to set up an authentication token. Triggering a build is then a simple HTTP <code>POST</code> request with a <code>?cause=203&amp;REPO=https://example.com/repo.git&amp;BRANCH=merge-this-plz&amp;token=BEEFCAFE</code>.</p>
<p>The <code>cause</code> part is used to keep track of the pull request in question. It will come in handy later.</p>
<p>Since we need to get information about the builds in some way, it is necessary to enable sending messages to Fedmsg as a post-build action.</p>
<h2 id="supercharge-pagure-configuration">Supercharge Pagure configuration</h2>
<p>The configuration on Pagure side is not that complicated. All that needs to be done is enable Fedmsg integration and set up an API key. This key needs to be able to post comments to pull requests.</p>
<h2 id="one-integration-point-to-bind-them-all">One integration point to bind them all</h2>
<p>The last part is to run a service that will listen to the messaging bus and trigger actions as needed. When it hears about new or changed pull request, it should trigger a build in Jenkins. When a build finishes (and is actually a build that verified a pull request), a comment with details should be posted to proper place.</p>
<p>I put the code to do exactly this into a <a href="https://pagure.io/poor-man-ci">poor-man-ci</a> repo on Pagure.</p>
<p>I have deployed this thing on my VPS and so far it seems to be working quite well. Open infrastructure for the win!</p>
<h2 id="implementation-details">Implementation details</h2>
<p>The service is based on the <a href="https://github.com/fedora-infra/pdc-updater">pdc-updater</a> model. There is a consumer running as part of <code>fedmsg-hub</code>. It subscribes to three topics: one from Jenkins, one for new pull requests on Pagure and one for comments on existing pull requests.</p>
<p>As far as I could tell, Pagure does not send a separate message when pull request is updated or rebased. It does however add a comment with this information.</p>
<p>When a message from Pagure is received, the contents must be examined to determine if a build should be triggered. For new pull requests this is completely straightforward. For the update part we need to check if the last comment is one of the known strings and if the pull request is still open.</p>
<p>Messages from Jenkins are a lot simpler. In fact they don't contain pretty much anything but the build number. This is where <a href="http://python-jenkins.readthedocs.org/en/latest/">python-jenkins</a> comes into play. It is a library on top of Jenkins API which makes it relatively easy to get more details about the build. The only part I was interested in was the result (this is actually in the message directly) and the note with pull request number.</p>
<p>Finally the last part is to post a comment to Pagure. This is really trivial, just submit an HTTP <code>POST</code> request.</p>
<h2 id="deploying">Deploying</h2>
<p>Implementation wise, the hardest part for me was to package the whole service and get it running. During most of the development I was using the <code>fedmsg.tail_messages()</code> function, which was probably not meant for this use case.</p>
<p>Ultimately, I just ripped of existing projects, mostly <a href="https://github.com/fedora-infra/pdc-updater">pdc-updater</a> and <a href="https://github.com/fedora-infra/the-new-hotness">the-new-hotness</a>. That helped some, but there are still a couple open questions. For example, I have no idea why the packages do not depend on <code>fedmsg-hub</code> when they clearly need it to run.</p>
<p>My take away points for developing with Fedmsg are these:</p>
<p><strong>Point 1</strong>: Your <code>setup.py</code> must specify an entrypoint for <em>moksha</em>.</p>
<div class="sourceCode"><pre class="sourceCode ini"><code class="sourceCode ini"><span class="kw">[moksha.consumer]</span>
<span class="dt">integrator </span><span class="ot">=</span><span class="st"> poormanci.consumer:Integrator</span></code></pre></div>
<p>This will get installed together with egg-info and the hub will somehow pick it up. The name of the key is not important. The value should point to a Python module containing a subclass of the <code>FedmsgConsumer</code>.</p>
<p><strong>Point 2</strong>: The consumer class should have <code>topic</code> attribute listing all the topics you are interested in, a <code>config_key</code> attribute with the name of the configuration key that controls whether this consumer is enabled and finally a <code>consume</code> method that will be called with the message received.</p>
<p><strong>Point 3</strong>: The configuration file needs to live in <code>/etc/fedmsg.d</code>. Its name is not important. It must be a Python module that defines a single value <code>config</code> as a dict. It should contain at least the configuration code mentioned above to enable the consumer, but can have arbitrary other stuff. I put the API keys there, for example.</p>
<p><strong>Point 4</strong>: The actual packaging (as in how to install the software) is not really important as long as the module with the consumer can be imported and the egg-info directory gets install into Python site lib.</p>
<p><strong>Point 5</strong>: I had to restart the hub to have it pick up updates. This is as easy as <code>systemctl restart fedmsg-hub.service</code>.</p>
<p><strong>Point 6</strong>: I found it helpful to tail the hub logs to see what is happening – <code>journalctl -f -u fedmsg-hub.service</code>. This log also contains traceback when the consumer crashes.</p>]]></summary>
</entry>

</feed>
