<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>lsedlar – Posts tagged Haskell</title>
    <link href="https://lubomir.github.io//en/tags/haskell.atom" rel="self" />
    <link href="https://lubomir.github.io/" />
    <id>https://lubomir.github.io//en/tags/haskell.atom</id>
    <author>
        <name>Lubomír Sedlář</name>
        <email>lubomir.sedlar@gmail.com</email>
    </author>
    <updated>2016-01-24T00:00:00Z</updated>
    <entry>
    <title>Watching process outputs with Haskell</title>
    <link href="https://lubomir.github.io//en/2016-01-24-watching-process-outputs.html" />
    <id>https://lubomir.github.io//en/2016-01-24-watching-process-outputs.html</id>
    <published>2016-01-24T00:00:00Z</published>
    <updated>2016-01-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>When using <em>docker-compose</em>, I really like how the output printed by the running containers gets interleaved in different colors. I wanted something like that, but for arbitrary commands.</p>
<p>A recent <a href="https://www.reddit.com/r/haskell/comments/41za4n/streaming_a_unix_tools_output_to_haskell/">post on Reddit</a> actually reminded me of that.</p>
<p>I will call the program <code>race</code>, although there are not going to be any winners.</p>
<p>The idea of the program is simple: it will run each process in a separate thread. This runner thread will read the output of the program (both <code>stdout</code> and <code>stderr</code>, I just don't care) and send this to the main thread. This way, there will always single thread writing the actual output.</p>
<p>The communication between threads will happen through <code>Control.Concurrent.Chan</code>, and we will be sending simple messages:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Msg</span> <span class="fu">=</span> <span class="dt">Quit</span>                 <span class="co">-- ^The process finished</span>
         <span class="fu">|</span> <span class="dt">Msg</span> <span class="dt">Int</span> <span class="dt">ByteString</span>   <span class="co">-- ^A single line of output</span></code></pre></div>
<p>The number in the message will indicate which child process is sending the line and will be used to pick a color.</p>
<p>The thread for consuming these messages and printing the data is not too complex. It's a loop that keeps track of the number of running processes. In each iteration, we read a single message from the channel and depending on what it is, we either decrement the process counter or print the message wrapped in ANSI color sequences.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">printer ::</span> <span class="dt">Chan</span> <span class="dt">Msg</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
printer _ <span class="dv">0</span> <span class="fu">=</span> return ()
printer chan num <span class="fu">=</span> <span class="kw">do</span>
    msg <span class="ot">&lt;-</span> readChan chan
    <span class="kw">case</span> msg <span class="kw">of</span>
        <span class="dt">Quit</span> <span class="ot">-&gt;</span> printer chan (num <span class="fu">-</span> <span class="dv">1</span>)
        <span class="dt">Msg</span> i d <span class="ot">-&gt;</span> <span class="kw">do</span>
            B.putStr <span class="fu">$</span> colored i d
            reader chan num

<span class="ot">colored ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span>
colored i d <span class="fu">=</span> <span class="kw">let</span> col <span class="fu">=</span> colors <span class="fu">!!</span> i
              <span class="kw">in</span> <span class="st">&quot;\ESC[&quot;</span> <span class="fu">&lt;&gt;</span> col <span class="fu">&lt;&gt;</span> <span class="st">&quot;;1m&quot;</span> <span class="fu">&lt;&gt;</span> d <span class="fu">&lt;&gt;</span> <span class="st">&quot;\ESC[0m\n&quot;</span>
  <span class="kw">where</span>
    colors <span class="fu">=</span> cycle [<span class="st">&quot;36&quot;</span>, <span class="st">&quot;35&quot;</span>, <span class="st">&quot;32&quot;</span>, <span class="st">&quot;33&quot;</span>, <span class="st">&quot;34&quot;</span>, <span class="st">&quot;31&quot;</span>]</code></pre></div>
<p>Reading the output of a random program is a bit more involved. As input, we will submit the channel, process number and a string with the command.</p>
<p>There is a very <a href="https://www.schoolofhaskell.com/user/snoyberg/library-documentation/data-conduit-process">helpful tutorial</a> for <code>Data.Conduit.Process</code> which contains an example. We can adapt this to our needs.</p>
<p>The biggest hurdle here is that <em>glibc</em> will by default line-buffer standard output if it goes to interactive terminal, but as soon as we redirect it to a pipe, it gets fully buffered in 4 KiB blocks.</p>
<p>This is definitely not what we want. There are a few ways to mitigate this: the easiest is to use <code>stdbuf</code> executable, which modifies the buffering mode. The problem with it is that it does not work for all cases, especially for commands involving piping data between multiple processes.</p>
<p>Another attempt that I made was to use a pseudoterminal. This approach is however quite complex, and I failed to get it running reliably.</p>
<p>In the end I settled for <code>script</code> command. By using the <code>-c</code> argument it can run a complex command and it handles buffering just the way I wanted.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runProcess ::</span> <span class="dt">Chan</span> <span class="dt">Msg</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
runProcess chan&#39; i cmd <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">let</span> cmd&#39; <span class="fu">=</span> <span class="st">&quot;script -qfc \&quot;&quot;</span> <span class="fu">&lt;&gt;</span> cmd <span class="fu">&lt;&gt;</span> <span class="st">&quot;\&quot; /dev/null&quot;</span>
    (<span class="dt">ClosedStream</span>, fromProcess, fromProcessErr, cph) <span class="ot">&lt;-</span>
        streamingProcess (shell cmd&#39;)

    <span class="kw">let</span> output h <span class="fu">=</span> CB.sourceHandle h <span class="fu">$$</span> CB.lines <span class="fu">=$</span> CL.mapM_
            (writeChan chan <span class="fu">.</span> <span class="dt">Msg</span> i)

    _ <span class="ot">&lt;-</span> runConcurrently <span class="fu">$</span>
        <span class="dt">Concurrently</span> (output fromProcess) <span class="fu">*&gt;</span>
        <span class="dt">Concurrently</span> (output fromProcessErr) <span class="fu">*&gt;</span>
        <span class="dt">Concurrently</span> (waitForStreamingProcess cph)

    writeChan chan <span class="dt">Quit</span></code></pre></div>
<p>All that is left to do is to tie it all together: get command line arguments, spawn a thread for each one and run the printer function in the main thread. We will create the channel with one duplicate: the copy will be shared by all worker threads.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    args <span class="ot">&lt;-</span> getArgs
    readEnd <span class="ot">&lt;-</span> newChan
    writeEnd <span class="ot">&lt;-</span> dupChan readEnd

    mapM_ (forkIO <span class="fu">.</span> uncurry (runProcess writeEnd)) (zip [<span class="dv">0</span><span class="fu">..</span>] args)

    reader readEnd (length args)</code></pre></div>
<p>The program can now be used like this:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">race</span> <span class="st">&quot;python -m SimpleHTTPServer&quot;</span> <span class="st">&quot;make rebuild-on-change&quot;</span></code></pre></div>
<p>Arguably, it is just a glorified wrapper for the <code>&amp;</code> Bash functionality and <code>wait</code> command. Nonetheless, I still consider it useful.</p>
<p>You can get <a href="https://github.com/lubomir/race">the whole project</a> including cabal file with list of dependencies on GitHub.</p>]]></summary>
</entry>
<entry>
    <title>Simulating an elevator</title>
    <link href="https://lubomir.github.io//en/2014-08-31-simulating-an-elevator.html" />
    <id>https://lubomir.github.io//en/2014-08-31-simulating-an-elevator.html</id>
    <published>2014-08-31T00:00:00Z</published>
    <updated>2014-08-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Recently I lived in a building with twelve floors and a very dumb elevator. Multiple times have I stood in front of an elevator and watched as it went by repeatedly refusing to stop and let me on.</p>
<p>There were two elevators, each equipped with a single button that should tell the elevator to come to your floor. However, if the elevator is currently going somewhere, it will ignore your request. You have to wait for it to stop and press the button again. Should someone press it faster, you are out of luck and have to wait for next try.</p>
<p>Obviously, the two elevators do not communicate in any way, so in fact you gamble with two elevators at the same time.</p>
<p>This system seemed very stupid to me, so I decided to create a simple model to verify how much better it would be if the elevator was somewhat smarter.</p>
<h2 id="the-model">The model</h2>
<p>So let's model a building with a single elevator. The simulation will run in turns. At the beginning of each turn, a person can appear at each floor with some probability. All people want to go to the lowest floor (think busy morning). Next, the elevator must decide whether to go up, down, load or unload people or wait.</p>
<p>We will test three different elevator logics. In the simulation, the elevator is represented by a <code>Haskell</code> function with type <code>Building -&gt; Decision</code>, where <code>Building</code> is a data type with information about waiting people and actual position of the elevator.</p>
<p>Note that even the simplest elevator in the simulation is still more elaborate than the one in my building. To simulate that, it would be necessary to choose floor to pick people up at random. This would require the elevator logic to retain some state between each call, which currently is not possible.</p>
<h2 id="the-elevators">The elevators</h2>
<p>The simplest elevator is called <code>dumbElevator</code>, but none-the-less it still is a bit smarter that the one in my former building. This elevator stores each request in a queue and works in a first-come-first-served fashion.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">dumbElevator b
  <span class="fu">|</span> hasPeople b <span class="fu">=</span> <span class="kw">if</span> inBasement b <span class="kw">then</span> <span class="dt">Unload</span> <span class="kw">else</span> <span class="dt">GoDown</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">case</span> (<span class="fu">==</span> b <span class="fu">^.</span> curPosition) <span class="ot">`fmap`</span> (b <span class="fu">^.</span> queue <span class="fu">^?</span> _head) <span class="kw">of</span>
        <span class="dt">Just</span> <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="dt">Load</span>
        <span class="dt">Just</span> <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">GoUp</span>
        <span class="dt">Nothing</span>    <span class="ot">-&gt;</span> <span class="dt">Wait</span></code></pre></div>
<p>If there are people on the elevator, it will take them to the basement and unload. Otherwise it will go to the next floor in the queue and load all the people there.</p>
<p>We will improve this elevator with slightly nicer behavior in <code>niceElevator</code>: when it goes down through a floor with people, it will stop and let them on.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">niceElevator b
  <span class="fu">|</span> hasPeople b <span class="fu">=</span> <span class="kw">if</span> inBasement b
                    <span class="kw">then</span> <span class="dt">Unload</span>
                    <span class="kw">else</span> <span class="kw">if</span> peopleOnCurrentFloor b <span class="kw">then</span> <span class="dt">Load</span> <span class="kw">else</span> <span class="dt">GoDown</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> dumbElevator b</code></pre></div>
<p>The last modeled elevator behaves the same as <code>niceElevator</code> when going down. Where it differs is that when it decides where to start loading people, it ignores the order of requests and goes to the highest floor with waiting people.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">smartElevator b
  <span class="fu">|</span> hasPeople b <span class="fu">=</span> niceElevator b
  <span class="fu">|</span> any (<span class="fu">&gt;</span> b <span class="fu">^.</span> curPosition) (b <span class="fu">^.</span> queue) <span class="fu">=</span> <span class="dt">GoUp</span>
  <span class="fu">|</span> peopleOnCurrentFloor b <span class="fu">=</span> <span class="dt">Load</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Wait</span></code></pre></div>
<p>It does not preserve any state. In each turn, it will check if there is a floor above it with people. If so, it will go for them. If not and there are people on current floor, it lets them on, otherwise it will wait. Note that a situation when people are waiting below the elevator can never happen, as the elevator goes up only if it can pick someone up there.</p>
<h2 id="results">Results</h2>
<p>It should not be a surprise that the dumb elevator does not behave very well. The metric that I measured is the average waiting time. Every time a person got on the elevator, their waiting time (current time minus the appearance of this person) was recorded. This way we can determine how bad the elevator is. The number itself does not say much, but a comparison of different elevators does.</p>
<p>The first graph displays the average waiting time with regards to the probability of a person appearing.</p>
<figure>
<img src="/images/elevator/wait-vs-prob-5.png" alt="In a 5 floor building" /><figcaption>In a 5 floor building</figcaption>
</figure>
<p>If the building has more floors, the trend remains the same. The wait time for <em>dumb</em> elevator goes much higher than for the other two elevators. However, the additional cunning of <em>smart</em> elevator does not seem to bring much.</p>
<figure>
<img src="/images/elevator/wait-vs-prob-10.png" alt="In a 10 floor building" /><figcaption>In a 10 floor building</figcaption>
</figure>
<p>It seems from the graphs that at certain point the elevators can no longer deal with the amount of people appearing in the building. The simulation was run for 10000 turns and people who were never picked up do not have any effect on the average time, thus the upper bound on the wait time.</p>
<p>It might also be interesting to have a look at the relation between waiting time and number of floors.</p>
<figure>
<img src="/images/elevator/wait-vs-floors-5.png" alt="For probability 5 %" /><figcaption>For probability 5 %</figcaption>
</figure>
<p>Interestingly, the probability of people appearing has pretty much no influence on the results.</p>
<figure>
<img src="/images/elevator/wait-vs-floors-15.png" alt="For probability 15 %" /><figcaption>For probability 15 %</figcaption>
</figure>
<h2 id="conclusion">Conclusion</h2>
<p>There is one positive result: I don't have to live a with a dumb elevator anymore. The simulation confirmed that a slight improvement in the logic – letting people get on the elevator when it is going down – can have significant impact on average waiting time.</p>
<p>The code used for this is available at <a href="https://github.com/lubomir/elevator">GitHub</a>.</p>]]></summary>
</entry>

</feed>
