<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>lsedlar – Příspěvky označené jako vyčíslitelnost</title>
    <link href="https://lubomir.github.io//cs/tags/vycislitelnost.atom" rel="self" />
    <link href="https://lubomir.github.io/" />
    <id>https://lubomir.github.io//cs/tags/vycislitelnost.atom</id>
    <author>
        <name>Lubomír Sedlář</name>
        <email>lubomir.sedlar@gmail.com</email>
    </author>
    <updated>2015-06-10T15:42:16Z</updated>
    <entry>
    <title>CPO a spojité funkce</title>
    <link href="https://lubomir.github.io//cs/2011-01-24-cpo-a-spojite-funkce.html" />
    <id>https://lubomir.github.io//cs/2011-01-24-cpo-a-spojite-funkce.html</id>
    <published>2011-01-24T00:00:00Z</published>
    <updated>2015-06-10T15:42:16Z</updated>
    <summary type="html"><![CDATA[<p>Každý typ se dá charakterizovat jako částečně uspořádaná množina hodnot. Pokud platí, že každý spočetný řetězec má supremum, potom se jedná o <a href="http://en.wikipedia.org/wiki/Complete_partial_order">Complete Partial Order</a>.</p>
<h2 id="primitivní-typy----příklady">Primitivní typy -- příklady</h2>
<figure>
<img src="/images/unitt.png" alt="Unit⊥" /><figcaption>Unit<sub>⊥</sub></figcaption>
</figure>
<figure>
<img src="/images/boolt.png" alt="Bool⊥" /><figcaption>Bool<sub>⊥</sub></figcaption>
</figure>
<p>Značky <code>tt</code> a <code>ff</code> jsou jednoduše symboly pro pravdivou a nepravdivou hodnotu. Další primitivní typ je třeba typ všech celých čísel <code>Int</code>.</p>
<h2 id="operace-nad-typy">Operace nad typy</h2>
<p>Z primitivních typů je možné pomocí operací vytvářet další, bohatší typy.</p>
<dl>
<dt>Lift X</dt>
<dd>přidá ⊥ jako nejméně definovaný prvek do typu X. Dno (⊥) je menší než všechny původní prvky v X a jinak se touto operací uspořádání nemění.
</dd>
<dt>X × Y</dt>
<dd>kartézský součin dvou typů (typ všech dvojic, kde první složka je typu X a druhá složka má typ Y). Pokud <span class="math inline"><em>x</em><sub>1</sub>, <em>x</em><sub>2</sub> ∈ <em>X</em>, <em>x</em><sub>1</sub> ≤ <em>x</em><sub>2</sub></span> a <span class="math inline"><em>y</em><sub>1</sub>, <em>y</em><sub>2</sub> ∈ <em>Y</em>, <em>y</em><sub>1</sub> ≤ <em>y</em><sub>2</sub></span>, potom platí <span class="math inline">(<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>)≤(<em>x</em><sub>2</sub>, <em>y</em><sub>2</sub>)</span>. <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>
</dd>
<dt>X + Y</dt>
<dd>disjunktní sjednocení, hodnota tohoto typu obsahuje buď nějakou hodnotu typu X, nebo hodnotu typu Y (např. takto funguje <code>union</code> v C nebo <code>Either</code> v Haskellu)
</dd>
<dt>X → Y</dt>
<dd>mocninný typ; typ všech spojitých funkcí, které hodnotu typu X zobrazí na hodnotu typu Y
</dd>
</dl>
<p>Další příklady jsou ve slidech z přednášky na straně 167.</p>
<figure>
<img src="/images/bool-x-bool.png" alt="Bool⊥ × Bool⊥" /><figcaption>Bool<sub>⊥</sub> × Bool<sub>⊥</sub></figcaption>
</figure>
<h2 id="spojitost-funkce">Spojitost funkce</h2>
<blockquote>
<p>Funkce <span class="math inline"><em>f</em></span> je monotonní právě tehdy, když platí <span class="math inline">∀<em>a</em>, <em>b</em> : <em>a</em> ≤ <em>b</em> ⇒ <em>f</em>(<em>a</em>)≤<em>f</em>(<em>b</em>)</span>.</p>
</blockquote>
<p>Tedy: funkce <span class="math inline"><em>f</em></span> je monotonní, pokud pro každé dva prvky jejího definičního oboru platí, že pokud je jeden méně definovaný než jiný, tak potom jejich obrazy na tom budou stejně.</p>
<p>Takže například funkce <span class="math inline"><em>f</em></span> je monotonní, ale funkce <span class="math inline"><em>g</em></span> monotonní není.</p>
<pre><code>f () = True
f ⊥ = True

g () = True
g ⊥ = False</code></pre>
<p>Spojitost funkce je ještě trochu silnější pojem. Každá spojitá funkce je i monotonní. Obrácené tvrzení neplatí, existují i nespojité monotonní funkce. Platí ale, že každá monotonní funkce s konečným definičním oborem (doménou) je spojitá<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>.</p>
<blockquote>
<p>Funkce <span class="math inline"><em>f</em></span> je spojitá, pokud pro každý spočetný řetězec <span class="math inline"><em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, …</span> platí <span class="math inline"><em>f</em>(⨆(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, …)) = ⨆(<em>f</em>(<em>x</em><sub>1</sub>),<em>f</em>(<em>x</em><sub>2</sub>),…)</span></p>
</blockquote>
<p>(Značka <span class="math inline">⨆</span> značí supremum, nejmenší horní závoru, least upper bound. Horní závora nějaké podmnožiny je prvek, který je větší než libovolný prvek dané podmnožiny.)</p>
<p>Definice tedy říká, že obraz suprema libovolného řetězce musí být supremem obrazů jednotlivých prvků řetězce.</p>
<p>Česky: pokud se vezme libovolný spočetný řetězec a funkcí <span class="math inline"><em>f</em></span> zobrazíme jeho supremum, tak musíme dostat totéž, jako kdybychom postupně zobrazili všechny prvky daného řetězce a našli supremum obrazů.</p>
<h2 id="všechny-unit-bool">Všechny Unit<sub>⊥</sub> → Bool<sub>⊥</sub></h2>
<p>Zadání: Napište všechny spojité funkce typu Unit<sub>⊥</sub> → Bool<sub>⊥</sub>. Co je to funkce s tímto typem? Takováto funkce musí každé hodnotě z Unit<sub>⊥</sub> přiřadit něco z Bool<sub>⊥</sub>.</p>
<figure>
<img src="/images/unit-bool2.png" alt="Všechny funkce Unit⊥ → Bool⊥" /><figcaption>Všechny funkce Unit<sub>⊥</sub> → Bool<sub>⊥</sub></figcaption>
</figure>
<p>Tyto funkce by bylo vhodné taky seřadit do diagramu, aby bylo patrné, jak to uspořádání na nich funguje. Pro jednoduchost je každou funkci možné zakreslit jako diagram ve tvaru definičního oboru, kde se místo původních prvků na stejná místa doplní hodnota, na kterou se ten který prvek zobrazí.</p>
<figure>
<img src="/images/unit-bool.png" alt="Uspořádání na Unit⊥ → Bool⊥" /><figcaption>Uspořádání na Unit<sub>⊥</sub> → Bool<sub>⊥</sub></figcaption>
</figure>
<p>Pro jiný typ funkcí to může dopadnout třeba tak, jako na obrázku níž.</p>
<figure>
<img src="/images/bool-bool.png" alt="Bool⊥ → Bool⊥" /><figcaption>Bool<sub>⊥</sub> → Bool<sub>⊥</sub></figcaption>
</figure>
<h2 id="striktní-funkce">Striktní funkce</h2>
<p>Striktní funkce je taková funkce, která nejdříve vyhodnotí svůj argument a potom s ním teprve něco počítá. Pokud je tedy argument nedefinovaný, nemůže být definovaný ani výsledek výpočtu. Pro striktní funkci tedy platí <strong>f ⊥ = ⊥</strong>.</p>
<h2 id="odkazy">Odkazy</h2>
<ol type="1">
<li><a href="http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/">Hussling Haskell types into Hasse diagrams</a></li>
<li><a href="http://blog.ezyang.com/2010/12/gin-and-monotonic/">Gin and monotonic</a></li>
<li><a href="http://blog.ezyang.com/2010/12/getting-a-fix-on-fixpoints/">Getting a fix on fixpoints</a></li>
</ol>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>drobný detail: pokaždé se jedná o jiné <span class="math inline">≤</span>, protože se porovnává v jiné doméně<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>takže pro naprostou většinu příkladů na zkoušce PB006 stačí ověřovat monotonicitu<a href="#fnref2">↩</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>Poznámky k IB107</title>
    <link href="https://lubomir.github.io//cs/2011-01-02-poznamky-k-ib107.html" />
    <id>https://lubomir.github.io//cs/2011-01-02-poznamky-k-ib107.html</id>
    <published>2011-01-02T00:00:00Z</published>
    <updated>2015-06-10T15:42:16Z</updated>
    <summary type="html"><![CDATA[<h2 id="věta-o-numeraci">Věta o numeraci</h2>
<blockquote>
<p>Pro každé <span class="math inline"><em>j</em> ≥ 1</span> existuje vyčíslitelná funkce <span class="math inline"><em>Φ</em> : <em>N</em><sup><em>j</em> + 1</sup> → <em>N</em></span>, která je univerzální pro standardní numeraci j-árních funkcí. Tedy pro každé <span class="math inline"><em>e</em> ∈ <em>N</em></span> a <span class="math inline">(<em>a</em><sub>1</sub>, …<em>a</em><sub><em>j</em></sub>)∈<em>N</em><sup><em>j</em></sup></span> platí <img src="/images/veta-o-numeraci.png" alt="Věta o numeraci" /></p>
</blockquote>
<p>Pro každou aritu tedy existuje funkce <span class="math inline"><em>Φ</em></span>, která bere o jeden argument víc -- potřebuje ještě index programu, který má simulovat. Důkaz věty spočívá v definici interpretu -- programu, který bude simulovat jiné programy.</p>
<h2 id="věta-o-parametrizaci">Věta o parametrizaci</h2>
<blockquote>
<p>Ke každému <span class="math inline"><em>n</em> ≥ 1</span>, <span class="math inline"><em>m</em> ≥ 1</span> existuje totálně vyčíslitelná funkce <span class="math inline"><em>s</em><sup><em>m</em></sup><sub><em>n</em></sub> : <em>N</em><sup><em>m</em> + 1</sup> → <em>N</em></span>, taková, že platí <img src="/images/veta-o-parametrizaci.png" alt="Věta o parametrizaci" /></p>
</blockquote>
<p>Takže: existuje funkce <span class="math inline"><em>s</em></span>, která pro index programu <span class="math inline"><em>i</em></span> a <span class="math inline"><em>m</em></span> jeho argumentů spočítá index jiného programu, který bude dělat totéž co <span class="math inline"><em>i</em></span>, ale bude potřebovat o <span class="math inline"><em>m</em></span> argumentů méně. Funkce <span class="math inline"><em>s</em></span> vlastně zafixuje prvních <span class="math inline"><em>m</em></span> argumentů na nějaké konstanty. <span class="math inline"><em>m</em></span> je tady počet fixovaných parametrů, <span class="math inline"><em>n</em></span> počet těch, které se nefixují.</p>
<p>Dokazuje se pomocí programu, který celou konstrukci realizuje -- má <span class="math inline"><em>m</em></span> konstant a přesypává argumenty tak, aby to sedělo. Prvních <span class="math inline"><em>n</em></span> argumentů posune o <span class="math inline"><em>m</em></span> pozic doprava a na uvolněná místa dosadí konstanty. Pozor, aby se při posunování nepřepsalo něco, co bude ještě potřeba.</p>
<h2 id="první-riceova-věta">První Riceova věta</h2>
<blockquote>
<p>Nechť <span class="math inline"><em>I</em> ⊂ <em>N</em></span> je netriviální (není prázdná ani se nerovná <span class="math inline"><em>N</em></span>) a rekurzivní. Potom existují indexy programů <span class="math inline"><em>i</em> ∈ <em>I</em></span> a <span class="math inline"><em>j</em> ∈ <em>I</em>′</span><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> tak, že <span class="math inline"><em>ϕ</em><sub><em>i</em></sub> = <em>ϕ</em><sub><em>j</em></sub></span>.</p>
</blockquote>
<p>Tedy pokud je netriviální podmnožina <span class="math inline"><em>N</em></span> rekurzivní, potom nerespektuje funkce a naopak pokud nějaká množina respektuje funkce a je netriviální, potom nemůže být rekurzivní.</p>
<p>Důkaz se provede sporem: předpokládejme, že množina respektuje funkce a že množina <span class="math inline"><em>I</em></span> obsahuje index nějaké vyčíslitelné funkce<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> <span class="math inline"><em>θ</em></span>, která není prázdná. <span class="math inline"><em>I</em>′</span> potom obsahuje indexy prázdné funkce. Kdyby tomu tak nebylo, tak se prohodí <span class="math inline"><em>I</em></span> a <span class="math inline"><em>I</em>′</span>.</p>
<p>Nechť <span class="math inline"><em>P</em><sub><em>f</em>(<em>i</em>)</sub></span> je program <code>begin</code> <span class="math inline"><em>x</em><sub>2</sub></span> <code>:=</code> <span class="math inline"><em>Φ</em>(<em>i</em>, <em>i</em>)</span><code>;</code> <span class="math inline"><em>x</em><sub>1</sub></span> <code>:=</code> <span class="math inline"><em>θ</em>(<em>x</em><sub>1</sub>)</span> <code>end</code>. Zřejmě program <span class="math inline"><em>P</em></span> počítá funkci <span class="math inline"><em>θ</em></span>, pokud <span class="math inline"><em>ϕ</em><sub><em>i</em></sub>(<em>i</em>)</span> je definované a jinak počítá prázdnou funkci.</p>
<p>Tedy pro všechna <span class="math inline"><em>i</em> ∈ <em>N</em></span> platí <span class="math inline"><em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub> = <em>θ</em></span> právě tehdy když <span class="math inline"><em>i</em> ∈ <em>K</em></span>.</p>
<p>Pokud tedy <span class="math inline"><em>f</em>(<em>i</em>)∈<em>I</em></span>, pak <span class="math inline"><em>f</em>(<em>i</em>)</span> není index prázdné funkce. Je to index <span class="math inline"><em>θ</em></span>. Obráceně pokud <span class="math inline"><em>f</em>(<em>i</em>)</span> je indexem funkce <span class="math inline"><em>θ</em></span>, pak <span class="math inline"><em>f</em>(<em>i</em>)∈<em>I</em></span>. Nechť <span class="math inline"><em>χ</em><sub><em>I</em></sub></span> je charakteristická funkce <span class="math inline"><em>I</em></span>. Pro všechna <span class="math inline"><em>i</em> ∈ <em>N</em></span> musí platit <img src="/images/prvni-riceova-veta-tvrzeni.png" alt="Tvrzení 1" /></p>
<p>Protože <span class="math inline"><em>χ</em><sub><em>I</em></sub> ∘ <em>f</em></span> je totálně vyčíslitelná, musela by <span class="math inline"><em>K</em></span> být rekurzivní, což zřejmě není.</p>
<h2 id="druhá-riceova-věta">Druhá Riceova věta</h2>
<blockquote>
<p>Necht <span class="math inline"><em>I</em> ⊂ <em>N</em></span> respektuje funkce a nechť existuje funkce <span class="math inline"><em>θ</em></span> taková, že všechny její indexy jsou v <span class="math inline"><em>I</em></span> a má vyčíslitelné rozšíření <span class="math inline"><em>θ</em>′</span> takové, že jeho indexy patří do <span class="math inline"><em>I</em>′</span>.</p>
<p><span class="math inline"><em>I</em></span> potom není rekurzivně spočetná.</p>
</blockquote>
<p>Důkaz půjde zase sporem. Nechť funkce <span class="math inline"><em>ξ</em>(<em>i</em>, <em>j</em>)</span> se rovná <span class="math inline"><em>θ</em>′(<em>j</em>)</span>, pokud <span class="math inline"><em>ϕ</em><sub><em>i</em></sub>(<em>i</em>)</span> je definováno a jinak se rovná <span class="math inline"><em>θ</em>(<em>j</em>)</span>. Tato funkce je vyčíslitelná<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>. Podle <a href="#věta-o-parametrizaci">věty o parametrizaci</a> existuje totálně vyčíslitelná funkce <span class="math inline"><em>f</em> : <em>N</em> → <em>N</em></span> taková, že <span class="math inline"><em>ξ</em>(<em>i</em>, <em>j</em>)=<em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub>(<em>j</em>)</span>. <span class="math inline"><em>f</em>(<em>i</em>)</span> potom patří do <span class="math inline"><em>I</em></span> právě tehdy, když <span class="math inline"><em>ϕ</em><sub><em>i</em></sub>(<em>i</em>)</span> není definováno. Tj. <span class="math inline"><em>f</em>(<em>i</em>)∈<em>I</em> ≡ <em>i</em> ∈ <em>K</em>′</span>.</p>
<p>Pokud by tedy <span class="math inline"><em>I</em></span> byla rekurzivně spočetná, tak i <span class="math inline"><em>K</em>′</span> by musela být rekurzivně spočetná. To ale není.</p>
<p>Při použití druhé Riceovy věty je tedy zřejmě potřeba zvolit <span class="math inline"><em>θ</em></span> tak, aby nebyla totální. Jinak by totiž neměla potřebné rozšíření.</p>
<h2 id="třetí-riceova-věta">Třetí Riceova věta</h2>
<blockquote>
<p>Nechť <span class="math inline"><em>I</em> ⊂ <em>N</em></span> respektuje funkce a nechť existuje funkce <span class="math inline"><em>θ</em></span> taková, že všechny její indexy patří do <span class="math inline"><em>I</em></span> a navíc všechna její konečná zúžení patří do <span class="math inline"><em>I</em>′</span>.</p>
<p><span class="math inline"><em>I</em></span> potom není rekurzivně spočetná.</p>
</blockquote>
<p>Důkaz se opět provede sporem. Nechť funkce <span class="math inline"><em>μ</em>(<em>i</em>, <em>j</em>)</span> počítá <span class="math inline"><em>θ</em>(<em>j</em>)</span>, pokud <span class="math inline"><em>P</em><sub><em>i</em></sub></span> nezastaví pro vstup <span class="math inline"><em>i</em></span> během nejvýše <span class="math inline"><em>j</em></span> kroků. Pokud zastaví během nejvýše <span class="math inline"><em>j</em></span> kroků, <span class="math inline"><em>μ</em></span> se zacyklí. Funkce <span class="math inline"><em>μ</em></span> je zřejmě vyčíslitelná.</p>
<p>Podle <a href="#věta-o-parametrizaci">věty o parametrizaci</a> existuje totálně vyčíslitelná funkce <span class="math inline"><em>f</em></span> tak, že <span class="math inline"><em>μ</em>(<em>i</em>, <em>j</em>)=<em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub>(<em>j</em>)</span>.</p>
<p>Dostaneme tedy, že pokud <span class="math inline"><em>i</em> ∈ <em>K</em></span>, tak <span class="math inline"><em>P</em><sub><em>i</em></sub></span> zastaví pro <span class="math inline"><em>i</em></span>. Tedy existuje <span class="math inline"><em>j</em></span> takové, že <span class="math inline"><em>P</em><sub><em>i</em></sub></span> zastaví pro <span class="math inline"><em>i</em></span> po <strong>přesně</strong> <span class="math inline"><em>j</em></span> krocích. Tj. existuje <span class="math inline"><em>j</em></span> takové, že <span class="math inline"><em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub>(<em>x</em>)</span> počítá <span class="math inline"><em>θ</em>(<em>x</em>)</span> pro všechna <span class="math inline"><em>x</em></span> menší než <span class="math inline"><em>j</em></span> a jinak je nedefinované. Potom ale <span class="math inline"><em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub></span> je zúžením <span class="math inline"><em>θ</em></span> a její definiční obor je konečný, tedy <span class="math inline"><em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub> ∈ <em>I</em>′</span>.</p>
<p>Z druhé strany platí, že když <span class="math inline"><em>i</em> ∈ <em>K</em>′</span>, tak <span class="math inline"><em>P</em><sub><em>i</em></sub></span> nikdy nezastaví a <span class="math inline"><em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub></span> počítá celou <span class="math inline"><em>θ</em></span> a tedy patří do <span class="math inline"><em>I</em></span>.</p>
<p>Tedy <span class="math inline"><em>i</em> ∈ <em>K</em>′≡<em>f</em>(<em>i</em>)∈<em>I</em></span> a <span class="math inline"><em>I</em></span> nemůže být rekurzivně spočetná.</p>
<p>Třetí Riceovu větu tedy zřejmě nejde použít, pokud <span class="math inline"><em>I</em></span> obsahuje prázdnou funkci. Ta je totiž konečným zúžením každé funkce.</p>
<h2 id="časová-složitost">Časová složitost</h2>
<h3 id="f-in-og"><span class="math inline"><em>f</em> ∈ <em>O</em>(<em>g</em>)</span></h3>
<p>Funkce <span class="math inline"><em>f</em></span> roste nejvýše tak rychle jako <span class="math inline"><em>g</em></span>.</p>
<blockquote>
<p><span class="math inline">∃<em>c</em>, <em>n</em><sub>0</sub> : ∀<em>n</em> ≥ <em>n</em><sub>0</sub> : <em>f</em>(<em>n</em>)≤<em>c</em><em>g</em>(<em>n</em>)</span></p>
</blockquote>
<h3 id="f-in-og-1"><span class="math inline"><em>f</em> ∈ <em>o</em>(<em>g</em>)</span></h3>
<p>Funkce <span class="math inline"><em>f</em></span> roste pomaleji než <span class="math inline"><em>g</em></span></p>
<figure>
<img src="/images/f-in-og.png" title="\lim{n \to \infty}\frac{f(n)}{g(n)} = 0" alt="" />
</figure>
<h3 id="f-in-omegag"><span class="math inline"><em>f</em> ∈ <em>Ω</em>(<em>g</em>)</span></h3>
<p>Funkce <span class="math inline"><em>f</em></span> roste alespoň tak rychle jako <span class="math inline"><em>g</em></span></p>
<figure>
<img src="/images/f-in-Omega-g.png" title="\exists n_0, c: \forall n \geq n_0 : f(n) \geq \frac{1}{c} g(n)" alt="" />
</figure>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>apostrofem označím doplněk množiny<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>a tedy všechny její indexy<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Nejdřív se začne paralelně (pomocí step counteru) počítat <span class="math inline"><em>θ</em>(<em>j</em>)</span> a <span class="math inline"><em>ϕ</em><sub><em>i</em></sub>(<em>i</em>)</span>. Pokud první skončí <span class="math inline"><em>θ</em>(<em>j</em>)</span>, vrátí se její výsledek. Pokud by první skončil výpočet <span class="math inline"><em>ϕ</em><sub><em>i</em></sub>(<em>i</em>)</span>, začne se přímo simulovat <span class="math inline"><em>θ</em>′(<em>j</em>)</span>.<a href="#fnref3">↩</a></p></li>
</ol>
</section>]]></summary>
</entry>

</feed>
