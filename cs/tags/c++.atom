<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>lsedlar – Příspěvky označené jako C++</title>
    <link href="https://lubomir.github.io/cs/tags/c%2B%2B.atom" rel="self" />
    <link href="https://lubomir.github.io" />
    <id>https://lubomir.github.io/cs/tags/c%2B%2B.atom</id>
    <author>
        <name>Lubomír Sedlář</name>
        <email>lubomir.sedlar@gmail.com</email>
    </author>
    <updated>2016-06-26T13:24:29Z</updated>
    <entry>
    <title>UnitTest v C++</title>
    <link href="https://lubomir.github.io/cs/2010-12-19-unittest.html" />
    <id>https://lubomir.github.io/cs/2010-12-19-unittest.html</id>
    <published>2010-12-19T00:00:00Z</published>
    <updated>2016-06-26T13:24:29Z</updated>
    <summary type="html"><![CDATA[<p>Unit testy jsou užitečná věc, pokud je třeba testovat jednotlivé funkce, třídy nebo metody. Většinou využívá nějakou knihovnu, což má oproti psaní testovacích kódů ručně výhodu v tom, že knihovna minimalizuje potřebu psát zbytečný kód okolo a rovnou poskytuje metody pro testování a případně i měření výkonu.</p>
<p>Já používám knihovnu <a href="https://github.com/unittest-cpp/unittest-cpp">UnitTest++</a>, která je rozumným kompromisem mezi funkcionalitou a jednoduchostí.</p>
<h2 id="použití">Použití</h2>
<p>Testy pomocí UnitTest++ je možné psát do libovolného souboru s příponou <code>.cpp</code> i <code>.cc</code>, jak je komu libo. Pro kompilaci je potřeba kompilátoru předat informace o tom, kde najde příslušné hlavičkové soubory a potom i knihovnu. Obojí jsem zkompiloval a je na Aise dostupné v adresáři <code>/home/~xsedlar3/include</code>.</p>
<p>Na začátku testovacího souboru je pochopitelně třeba vložit hlavičky knihovny vlastního kódu, který je třeba testovat.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;unittest++/UnitTest++.h&gt;</span></code></pre></div>
<p>Ke spouštění testů je třeba přidat i funkci <code>main</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main() {
    <span class="kw">return</span> UnitTest::RunAllTests();
}</code></pre></div>
<h2 id="testy">Testy</h2>
<p>Jednotlivé testy se píšou pomocí maker <code>TEST</code>, které má jeden parametr -- identifikátor, podle kterého půjde dohledávat, který test selhal. Následuje blok, ve kterém se provádí test.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">TEST(Addition) {
    CHECK(someFunction());
}</code></pre></div>
<p>K usnadnění psaní testů je definováno několik šikovných maker jako je výše uvedené <code>CHECK</code>. To jednoduše kontroluje, jestli se jeho argument vyhodnotí na <code>true</code>. Další možnosti jsou třeba <code>CHECK_EQUAL(co_cekam, testovany_vyraz)</code>, které ověří, že testovaný výraz vrací určenou hodnotu. Pořadí argumentů je tady docela důležité, pokud bude očekávaná hodnota jako druhá, případně chyby budou hlášené dost chaoticky. Další makra jsou popsána v <a href="https://github.com/unittest-cpp/unittest-cpp/wiki">dokumentaci</a>.</p>
<p>Aby se i ve velkém souboru s testy dalo dobře orientovat, je možné jednotlivé testy dělit do sad pomocí makra <code>SUITE(nazev)</code>, případně je rozdělit do více souborů.</p>
<p>Jednoduchý test tedy může vypadat takto:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">TEST(InsertValueAtStart) {
    List&lt;<span class="dt">int</span>&gt; list;
    List&lt;<span class="dt">int</span>&gt;::ItemType *iter;

    iter = list.push_front(<span class="dv">10</span>);
    CHECK( ! list.empty());
    CHECK_EQUAL(<span class="dv">10</span>, it-&gt;getValue());
    CHECK_EQUAL(<span class="dv">10</span>, list.first()-&gt;getValue());
    CHECK_EQUAL(<span class="dv">10</span>, list.last()-&gt;getValue());
}</code></pre></div>
<h2 id="fixtures">Fixtures</h2>
<p>Při psaní testů se dá velice rychle narazit na situaci, že se na začátku několika testů opakuje stejná část, která jenom chystá objekt na další testovaní, např. plní seznam daty. Toto se dá zjednodušit přesunutím takovéto inicializace do tzv. fixture.</p>
<p>V případě knihovny UnitTest++ se jedná o definici třídy, jejíž konstruktor se zavolá na začátku testu, kde je použitá, a celý test se potom vykonává tak, že má přímo přístup k členským prvkům dané třídy. Místo makra <code>TEST</code> se potom použije <code>TEST_FIXTURE</code> se dvěma argumenty. Prvním je právě název fixture.</p>
<p>Může to tedy vypadat takto:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> LongList {
    LongList() {
        it1 = list.push_back(<span class="dv">10</span>);
        it2 = list.push_back(<span class="dv">20</span>);
        it3 = list.push_back(<span class="dv">30</span>);
        it4 = list.push_back(<span class="dv">40</span>);
        it5 = list.push_back(<span class="dv">50</span>);
        it6 = list.push_back(<span class="dv">60</span>);
    }

    std::string to_str() { <span class="kw">return</span> list_to_str(list); }

    List&lt;<span class="dt">int</span>&gt; list;
    List&lt;<span class="dt">int</span>&gt;::ItemType *it1, *it2, *it3, *it4, *it5, *it6;
};

TEST_FIXTURE(LongList, SwapTwoDistinctIntervals) {
    list.push_back(<span class="dv">70</span>);
    list.swap(it2, it3, it5, it6);
    CHECK_EQUAL(<span class="st">&quot;{ 10, 50, 60, 40, 20, 30, 70 }&quot;</span>, to_str());
    list.swap(it5, it6, it2, it3);
    CHECK_EQUAL(<span class="st">&quot;{ 10, 20, 30, 40, 50, 60, 70 }&quot;</span>, to_str());
}</code></pre></div>]]></summary>
</entry>

</feed>
