<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>lsedlar – Příspěvky označené jako testy</title>
    <link href="https://lubomir.github.io//cs/tags/testy.atom" rel="self" />
    <link href="https://lubomir.github.io/" />
    <id>https://lubomir.github.io//cs/tags/testy.atom</id>
    <author>
        <name>Lubomír Sedlář</name>
        <email>lubomir.sedlar@gmail.com</email>
    </author>
    <updated>2016-06-26T13:24:29Z</updated>
    <entry>
    <title>UnitTest v C++</title>
    <link href="https://lubomir.github.io//cs/2010-12-19-unittest.html" />
    <id>https://lubomir.github.io//cs/2010-12-19-unittest.html</id>
    <published>2010-12-19T00:00:00Z</published>
    <updated>2016-06-26T13:24:29Z</updated>
    <summary type="html"><![CDATA[<p>Unit testy jsou užitečná věc, pokud je třeba testovat jednotlivé funkce, třídy nebo metody. Většinou využívá nějakou knihovnu, což má oproti psaní testovacích kódů ručně výhodu v tom, že knihovna minimalizuje potřebu psát zbytečný kód okolo a rovnou poskytuje metody pro testování a případně i měření výkonu.</p>
<p>Já používám knihovnu <a href="https://github.com/unittest-cpp/unittest-cpp">UnitTest++</a>, která je rozumným kompromisem mezi funkcionalitou a jednoduchostí.</p>
<h2 id="použití">Použití</h2>
<p>Testy pomocí UnitTest++ je možné psát do libovolného souboru s příponou <code>.cpp</code> i <code>.cc</code>, jak je komu libo. Pro kompilaci je potřeba kompilátoru předat informace o tom, kde najde příslušné hlavičkové soubory a potom i knihovnu. Obojí jsem zkompiloval a je na Aise dostupné v adresáři <code>/home/~xsedlar3/include</code>.</p>
<p>Na začátku testovacího souboru je pochopitelně třeba vložit hlavičky knihovny vlastního kódu, který je třeba testovat.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;unittest++/UnitTest++.h&gt;</span></code></pre></div>
<p>Ke spouštění testů je třeba přidat i funkci <code>main</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main() {
    <span class="kw">return</span> UnitTest::RunAllTests();
}</code></pre></div>
<h2 id="testy">Testy</h2>
<p>Jednotlivé testy se píšou pomocí maker <code>TEST</code>, které má jeden parametr -- identifikátor, podle kterého půjde dohledávat, který test selhal. Následuje blok, ve kterém se provádí test.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">TEST(Addition) {
    CHECK(someFunction());
}</code></pre></div>
<p>K usnadnění psaní testů je definováno několik šikovných maker jako je výše uvedené <code>CHECK</code>. To jednoduše kontroluje, jestli se jeho argument vyhodnotí na <code>true</code>. Další možnosti jsou třeba <code>CHECK_EQUAL(co_cekam, testovany_vyraz)</code>, které ověří, že testovaný výraz vrací určenou hodnotu. Pořadí argumentů je tady docela důležité, pokud bude očekávaná hodnota jako druhá, případně chyby budou hlášené dost chaoticky. Další makra jsou popsána v <a href="https://github.com/unittest-cpp/unittest-cpp/wiki">dokumentaci</a>.</p>
<p>Aby se i ve velkém souboru s testy dalo dobře orientovat, je možné jednotlivé testy dělit do sad pomocí makra <code>SUITE(nazev)</code>, případně je rozdělit do více souborů.</p>
<p>Jednoduchý test tedy může vypadat takto:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">TEST(InsertValueAtStart) {
    List&lt;<span class="dt">int</span>&gt; list;
    List&lt;<span class="dt">int</span>&gt;::ItemType *iter;

    iter = list.push_front(<span class="dv">10</span>);
    CHECK( ! list.empty());
    CHECK_EQUAL(<span class="dv">10</span>, it-&gt;getValue());
    CHECK_EQUAL(<span class="dv">10</span>, list.first()-&gt;getValue());
    CHECK_EQUAL(<span class="dv">10</span>, list.last()-&gt;getValue());
}</code></pre></div>
<h2 id="fixtures">Fixtures</h2>
<p>Při psaní testů se dá velice rychle narazit na situaci, že se na začátku několika testů opakuje stejná část, která jenom chystá objekt na další testovaní, např. plní seznam daty. Toto se dá zjednodušit přesunutím takovéto inicializace do tzv. fixture.</p>
<p>V případě knihovny UnitTest++ se jedná o definici třídy, jejíž konstruktor se zavolá na začátku testu, kde je použitá, a celý test se potom vykonává tak, že má přímo přístup k členským prvkům dané třídy. Místo makra <code>TEST</code> se potom použije <code>TEST_FIXTURE</code> se dvěma argumenty. Prvním je právě název fixture.</p>
<p>Může to tedy vypadat takto:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> LongList {
    LongList() {
        it1 = list.push_back(<span class="dv">10</span>);
        it2 = list.push_back(<span class="dv">20</span>);
        it3 = list.push_back(<span class="dv">30</span>);
        it4 = list.push_back(<span class="dv">40</span>);
        it5 = list.push_back(<span class="dv">50</span>);
        it6 = list.push_back(<span class="dv">60</span>);
    }

    std::string to_str() { <span class="kw">return</span> list_to_str(list); }

    List&lt;<span class="dt">int</span>&gt; list;
    List&lt;<span class="dt">int</span>&gt;::ItemType *it1, *it2, *it3, *it4, *it5, *it6;
};

TEST_FIXTURE(LongList, SwapTwoDistinctIntervals) {
    list.push_back(<span class="dv">70</span>);
    list.swap(it2, it3, it5, it6);
    CHECK_EQUAL(<span class="st">&quot;{ 10, 50, 60, 40, 20, 30, 70 }&quot;</span>, to_str());
    list.swap(it5, it6, it2, it3);
    CHECK_EQUAL(<span class="st">&quot;{ 10, 20, 30, 40, 50, 60, 70 }&quot;</span>, to_str());
}</code></pre></div>]]></summary>
</entry>
<entry>
    <title>Testování binárky</title>
    <link href="https://lubomir.github.io//cs/2010-12-19-testovani-binarky.html" />
    <id>https://lubomir.github.io//cs/2010-12-19-testovani-binarky.html</id>
    <published>2010-12-19T00:00:00Z</published>
    <updated>2015-05-08T21:19:03Z</updated>
    <summary type="html"><![CDATA[<p>Pro usnadnění testování úkolů do PB071 a PB161 jsem si napsal jednoduchý skript. Vlastně jenom vezme spustitelný soubor, postupně mu předhazuje definované vstupy a kontroluje, co je na standardním výstupu, chybovém výstupu a s jakým kódem skončil. Volitelně se to celé dá prohánět valgrindem.</p>
<h2 id="formát-testů">Formát testů</h2>
<p>Všechny testy se ukládají do speciálního adresáře. Já používám název <code>tests</code>, ale prakticky na tom nezáleží. Každý tests se skládá alespoň ze dvou souborů s názvy třeba <code>01_valid_input.*</code>. Přípona souboru specifikuje, co soubor testuje.</p>
<dl>
<dt><code>*.in</code></dt>
<dd>toto přijde na standardní vstup
</dd>
<dt><code>*.args</code></dt>
<dd>toto se předá jako argumenty (a zatím pořádně nefunguje, pokud některý argument má obsahovat mezeru.)
</dd>
<dt><code>*.out</code></dt>
<dd>očekávaný výstup na stdout
</dd>
<dt><code>*.err</code></dt>
<dd>očekávaný chybový výstup
</dd>
<dt><code>*.ret</code></dt>
<dd>návratový kód programu
</dd>
</dl>
<p>Pokud některý soubor neexistuje, tak se příslušná část netestuje.</p>
<h2 id="použití">Použití</h2>
<p>Stáhněte si <a href="/data/stest.tar.bz2">archiv s testovacím skriptem</a> a pomocným souborem, který umožňuje vypisovat výsledky barevně. Skript <code>stest</code> je dobré mít v cestě, <code>.term_colors</code> může být buď přímo v domovském adresáři nebo na stejném místě jako <code>stest</code>.</p>
<p>K testování stačí spustit příkaz <code>stest ./NAZEV_BINARKY</code>, případně přidat ještě cestu k adresáři s testy. Další možnosti shrnuje nápověda <code>stest --help</code>.</p>]]></summary>
</entry>

</feed>
