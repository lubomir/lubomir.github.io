<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>lsedlar – Příspěvky označené jako programování</title>
    <link href="http://lubomir.github.io//cs/tags/programovani.atom" rel="self" />
    <link href="http://lubomir.github.io/" />
    <id>http://lubomir.github.io//cs/tags/programovani.atom</id>
    <author>
        <name>Lubomír Sedlář</name>
        <email>lubomir.sedlar@gmail.com</email>
    </author>
    <updated>2012-01-24T00:00:00Z</updated>
    <entry>
    <title>Rychlost prohledávání adresáře</title>
    <link href="http://lubomir.github.io//cs/2012-01-24-prochazeni-adresare.html" />
    <id>http://lubomir.github.io//cs/2012-01-24-prochazeni-adresare.html</id>
    <published>2012-01-24T00:00:00Z</published>
    <updated>2012-01-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Procházení všech souborů v adresáři je velice často se objevující potřeba. Navíc je v takovém případě obvykle potřeba rozlišit, jestli nalezená položka je soubor, adresář nebo ještě něco jiného. Je řada možností, jak tohle provést. Zkusil jsem porovnat, jak moc se časově liší různé varianty programu, který projde všechny položky adresáře a nejdříve vypíše soubory, potom adresáře.</p>
<h2 id="hřiště">Hřiště</h2>
<p>Použil jsem tři různé testovací adresáře. Jeden obsahoval jenom soubory, a to třicet tisíc, druhý obsahoval třicet tisíc adresářů a třetí po patnácti tisících od obojího. Počty v třetím případe nejsou naprosto přesné, adresářů tam může být o něco méně. Způsobené je to tím, že názvy jsou generovány skoro náhodně, aby se zajistilo náhodné pořadí.</p>
<p>Vygenerovat to jde dvěma jednoduchými cykly v Bashi.</p>
<pre class="bash"><code>for i in $(seq 1 30000); do
    touch bench1/file-$i
    mkdir bench2/dir-$i
done

for i in $(seq 1 15000); do
    touch bench3/$(mkpasswd &quot;file-$i&quot; | sed &quot;s@/@_@g&quot;)
    mkdir bench3/$(mkpasswd &quot;dir-$i&quot; | sed &quot;s@/@_@g&quot;)
done</code></pre>
<h2 id="metody">Metody</h2>
<p>První rozdíl v testovaných programech spočíval v tom, jak se zajistí, aby soubory byly vypsané dříve než adresáře. Nejjednodušší přístup spočívá v tom, že se adresář projde dvakrát, v prvním průchodu se ignorují adresáře, v druhém soubory.</p>
<p>Druhá a třetí metoda adresář procházejí jenom jednou a nalezené adresáře si pro pozdější zpracování ukládají buď do pole nebo spojového seznamu. Pole je po naplnění vždycky potřeba zvětšit, pokud se ale jeho velikost vždycky zdvojnásobí, složitost uložení nakonec vyjde konstantní. Každý uložený řetězec je taky potřeba naalokovat. Spojový seznam má sice taky konstantní složitost přidání prvku, ovšem vyžaduje na rozdíl od pole dvě alokace paměti.</p>
<p>Druhý rozdíl v testovaných programech spočívá v metodě určování typu položky. Použil jsem zase tři možnosti: pomocí funkce <code>stat()</code>, pomocí položky <code>d_type</code> ve struktuře <code>dirent</code> a pomocí lehce uhozené heuristiky s <code>opendir()</code>.</p>
<pre class="c"><code>int is_dir(const char *path)
{
    struct DIR *dir = opendir(path);
    if (dir == NULL) {
        return 0;
    } else {
        closedir(dir);
        return 1;
    }
}</code></pre>
<p>Tato heuristika má ovšem zásadní problém v tom, že i adresáře, které se nepodařilo otevřít třeba kvůli oprávněním, nahlásí jako soubory.</p>
<p>Rozpoznávání pomocí <code>d_type</code> je nejjednodušší, ale opět má nevýhody:</p>
<ul>
<li>nemusí existovat (pozná se podle makra <code>_DIRENT_HAVE_D_TYPE</code></li>
<li>i když existuje, může (v závislosti na souborovém systému) obsahovat hodnotu <code>DT_UNKNOWN</code> a tedy je potřeba se s tím vyrovnat</li>
</ul>
<h2 id="výsledky">Výsledky</h2>
<p>Každý z devíti programů jsem spustil stokrát a výsledné časy zprůměroval. Metodika nic moc, ale nějaká představa se z toho udělat dá.</p>
<table>
<tr>
<th>
</th>
<pre><code>       &lt;th&gt;Soubory&lt;/th&gt; &lt;th&gt;Adresáře&lt;/th&gt; &lt;th&gt;Mix&lt;/th&gt;&lt;/tr&gt;</code></pre>
<tr>
<th>
dvojitý průchod
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
<tr>
<td>
<code>stat()</code>
</td>
<td>
0,109
</td>
<td>
0,106
</td>
<pre><code>&lt;td&gt;0.107&lt;/td&gt;&lt;/tr&gt;</code></pre>
<tr>
<td>
<code>opendir()</code>
</td>
<td>
0,133
</td>
<td>
0,177
</td>
<pre><code>&lt;td&gt;0.155&lt;/td&gt;&lt;/tr&gt;</code></pre>
<tr>
<td>
<code>d_type</code>
</td>
<td>
0,043
</td>
<td>
0,040
</td>
<pre><code>&lt;td&gt;0.042&lt;/td&gt;&lt;/tr&gt;</code></pre>
<tr>
<th>
Pole
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
<tr>
<td>
<code>stat()</code>
</td>
<td>
0,054
</td>
<td>
0,057
</td>
<pre><code>&lt;td&gt;0.053&lt;/td&gt;&lt;/tr&gt;</code></pre>
<tr>
<td>
<code>opendir()</code>
</td>
<td>
0,067
</td>
<td>
0,091
</td>
<pre><code>&lt;td&gt;0.080&lt;/td&gt;&lt;/tr&gt;</code></pre>
<tr>
<td>
<code>d_type</code>
</td>
<td>
0,021
</td>
<td>
0,021
</td>
<pre><code>&lt;td&gt;0.020&lt;/td&gt;&lt;/tr&gt;</code></pre>
<tr>
<th>
Seznam
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
<tr>
<td>
<code>stat()</code>
</td>
<td>
0,053
</td>
<td>
0,060
</td>
<pre><code>&lt;td&gt;0.058&lt;/td&gt;&lt;/tr&gt;</code></pre>
<tr>
<td>
<code>opendir()</code>
</td>
<td>
0,065
</td>
<td>
0,091
</td>
<pre><code>&lt;td&gt;0.081&lt;/td&gt;&lt;/tr&gt;</code></pre>
<tr>
<td>
<code>d_type</code>
</td>
<td>
0,020
</td>
<td>
0,029
</td>
<pre><code>&lt;td&gt;0.022&lt;/td&gt;&lt;/tr&gt;</code></pre>
</table>
<p>Ponaučení na závěr? Na metodě procházení příliš nezáleží. To, co se s nalezenými položkami bude dít, pravděpodobně zabere výrazně víc času, takže jinou metodou procházení se nedá nic ušetřit.</p>
<p>Všechny <a href="/data/benchmark-dir.tar.bz2">zdrojové soubory</a> je možné si stáhnout včetně měřících skriptů. Skript <code>prepare.sh</code> vytvoří testovací složky, <code>measure.sh</code> spustí měření a <code>test.sh</code> ověřuje, že všechny programy dávají stejný výstup na třetím testovacím adresáři.</p>]]></summary>
</entry>
<entry>
    <title>Kódování čísel</title>
    <link href="http://lubomir.github.io//cs/2011-06-06-kodovani-cisel.html" />
    <id>http://lubomir.github.io//cs/2011-06-06-kodovani-cisel.html</id>
    <published>2011-06-06T00:00:00Z</published>
    <updated>2011-06-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>V předmětu <a href="https://is.muni.cz/auth/predmety/predmet.pl?id=585364">IB047</a> se dá mimo jiné potkat s problémem, jak co nejúsporněji uložit data do souboru. Jako ideální řešení se ukáže použít nějaké vhodné kódování. A protože nejlépe člověk něco pochopí tak, že si to vyzkouší, napsal jsem si funkce pro kódování i dekódování různými metodami.</p>
<h2 id="varianty">Varianty</h2>
<p>První myslitelné kódování je klasický zápis čísla ve dvojkové soustavě. Jeho výhoda je velká úspornost, na druhou stranu každá posloupnost nul a jedniček se dá interpretovat jako číslo. My bychom ale chtěli poznat, kde jedno číslo končí a druhé začíná. Proto potřebujeme <em>bezprefixový</em> kód, tedy takový, aby žádné slovo nebylo prefixem jiného. Zároveň ale nechceme používat žádnou překladovou tabulku, takže <a href="http://cs.wikipedia.org/wiki/Huffmanovo_kódování">Huffmanovo kódování</a> je ze hry.</p>
<p>Nejjednodušší variantou, jak toho dosáhnout, je použít <em>unární</em> kódování. Číslo <span class="math"><em>n</em></span> zakóduje pomocí <span class="math"><em>n</em></span> nul následovaných jedničkou. Zřejmě je tedy bezprefixové, ale zároveň i paměťově neefektivní, protože délka kódu je lineární k velikosti kódovaného čísla.</p>
<p>Jako lepší nápad vypadá zapsání čísla binárně a přidání jeho délky pomocí nějakého bezprefixového kódu. To ale také není optimální, protože bychom nevyužili mnoho možností. Konkrétně jde o slova, která začínají nulami. V klasickém dvojkovém zápisu jsou čísla 00 a 0 stejná. Z našeho pohledu je ale užitečné je rozlišit. Proto pro každou délku kódu využijeme všechny možnosti, tedy pro slovem délky jedna budeme kódovat dvě čísla, délkou dvě čtyři atd.</p>
<p>Pro každé číslo tedy určíme délku slova, odečteme od něj nějakou hodnotu a převedeme do dvojkové soustavy. Délku určíme jako <span class="math">⌊log<sub>2<sub></sub></sub>(<em>n</em> + 1)⌋</span>. Zároveň z délky můžeme určit, o kolik zmenšit kódované číslo před převodem: <span class="math">2<sup><em>l</em></sup> − 1</span>.</p>
<h2 id="implementace">Implementace</h2>
<p>Nejdříve tedy definice typů.</p>
<pre class="haskell"><code>data Bit = Zero | One deriving (Eq)

instance Show Bit where
    show Zero = &quot;0&quot;
    show One  = &quot;1&quot;

type Stream = [Bit]</code></pre>
<p>Typy požadovaných funkcí vypadají následovně. Kódovací funkce pro číslo vrátí posloupnost bitů, dekódovací naopak z proudy bitů vytáhnou první číslo a vrátí ho společně se zbytkem proudu. Funkce <code>fromBinary</code> se liší v tom, že zpracuje celý proud.</p>
<pre class="haskell"><code>unary, binary, gamma, delta        :: Int -&gt; Stream
parseUnary, parseGamma, parseDelta :: Stream -&gt; (Int, Stream)
fromBinary :: Stream -&gt; Int</code></pre>
<p>Unární kódování je velice jednoduché. Operátor <code>(***) :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; (a, c) -&gt; (b, d)</code> se nachází v modulu <code>Control.Arrow</code> a jeho jediný účel je aplikace funkcí na složky dvojice.</p>
<pre class="haskell"><code>unary n    = replicate n Zero ++ [One]
parseUnary = (length *** tail) . span (== Zero)</code></pre>
<p>Funkce pro binární kódování čísla jsou trošku složitější, ale pořád tam není žádná magie. Provádí klasický přepis čísla do dvojkové soustavy. Pomocná funkce <code>binary'</code> navíc výsledný kód doplní zleva do požadované délky nulami. Také 0 při délce kódu 0 reprezentuje prázdným seznamem.</p>
<pre class="haskell"><code>binary = bin []
  where
    bin acc 0 = Zero : acc
    bin acc 1 = One  : acc
    bin acc n = bin ((if odd n then One else Zero) : acc) (n `div` 2)

binary&#39; :: Int -&gt; Int -&gt; Stream
binary&#39; 0 0 = []
binary&#39; len n = padding ++ code
  where code = binary n
        padding = replicate (len - length code) Zero

fromBinary = foldl (\num x -&gt; num * 2 + (if x == Zero then 0 else 1)) 0</code></pre>
<p>Myšlenku popsanou na začátku realizují mimo jiné <span class="math"><em>γ</em></span> a <span class="math"><em>δ</em></span> kódy. <span class="math"><em>γ</em></span>-kód pro délku slova používá unární kódování, <span class="math"><em>δ</em></span>-kód jde ještě dál a používá pro zapsání délky <span class="math"><em>γ</em></span>-kód. Zřejmě jsou si tedy v mnohém podobná a má smysl nejdřív napsat obecnější funkci.</p>
<pre class="haskell"><code>encodeWith :: (Int -&gt; Stream) -&gt; Int -&gt; Stream
encodeWith f n = f len ++ binary&#39; len (n - 2^len + 1)
  where len = floor . logBase 2 . fromIntegral $ n + 1

parseWith :: (Stream -&gt; (Int, Stream)) -&gt; Stream -&gt; (Int, Stream)
parseWith f s = (fromBinary bin + 2^len - 1, ss)
  where (len, rest) = f s
        (bin, ss)   = splitAt len rest</code></pre>
<p>S funkcemi <code>encodeWith</code>, <code>parseWith</code> je tedy implementace <span class="math"><em>γ</em></span> i <span class="math"><em>δ</em></span> kódování poměrně triviální.</p>
<pre class="haskell"><code>gamma = encodeWith unary
parseGamma = parseWith parseUnary

delta = encodeWith gamma
parseDelta = parseWith parseGamma</code></pre>
<p>Odtud už je jednoduché napsat funkci, které bude kódovat nebo dekódovat seznam čísel.</p>
<pre class="haskell"><code>encode :: (Int -&gt; Stream) -&gt; [Int] -&gt; Stream
encode = concatMap

decode :: (Stream -&gt; (Int, Stream)) -&gt; Stream -&gt; [Int]
decode f s = let (n, ss) = f s
             in case ss of
                  [] -&gt; [n]
                  _  -&gt; n : decode f ss</code></pre>
<p><strong>Upozornění</strong>: toto není úplně ideální implementace, protože umožňuje práci pouze s čísly omezené velikosti, navíc jsem se nesnažil o efektivitu, takže je to velice pomalé. Taky chybí jakákoli kontrola chyb.</p>]]></summary>
</entry>
<entry>
    <title>XMonad a okna s pevnou velikostí</title>
    <link href="http://lubomir.github.io//cs/2011-04-04-xmonad-a-okna-s-pevnou-velikosti.html" />
    <id>http://lubomir.github.io//cs/2011-04-04-xmonad-a-okna-s-pevnou-velikosti.html</id>
    <published>2011-04-04T00:00:00Z</published>
    <updated>2011-04-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Už docela dlouho k téměř úplné spokojenosti používám XMonad jako správce oken. Sice má své mouchy, ale přednosti to dostatečně vyvažují. Navíc se i ty mouchy dají odstranit.</p>
<p>Poslední věc, na kterou jsem narazil a která mě donutila upravit <code>xmonad.hs</code> bylo ne zrovna přátelské chování k oknům, která si nastavují nějakou požadovanou velikost. XMonad tyto rady totiž totálně ignoruje. Ve většině případů je to docela žádoucí chování, jediná výjimka jsou okna, u kterých nemá moc smysl měnit velikost. V mém případě šlo hlavně o <a href="http://www.frozen-bubble.org/">Frozen Bubble</a> a <a href="http://www.dosbox.com/">dosbox</a>.</p>
<p>Jedna možnost řešení by bylo vyjmenovat dotyčné aplikace a přímo oknům nastavit režim floating. To se mi ale nelíbilo, protože by to nebylo ani pohodlné, ani spolehlivé, a často bych musel měnit konfiguraci.</p>
<p>Společným znakem oken, která mají fixní velikost, je nastavení minimální a maximální velikosti okna na stejnou hodnotu. Toto nastavení je v <code>WM_NORMAL_HINTS</code> a dá se zjistit třeba přes <code>xprop</code>. Toto pole má typ <code>XSizeHints</code> a nejpřesnější popis, který jsem našel, vypadá takto:</p>
<pre class="c"><code>typedef struct {
    long flags;                /* marks which fields in this
                                  structure are defined */
    int x, y;                  /* Obsolete */
    int width, height;         /* Obsolete */
    int min_width, min_height;
    int max_width, max_height;
    int width_inc, height_inc;
    struct {
           int x;              /* numerator */
           int y;              /* denominator */
    } min_aspect, max_aspect;
    int base_width, base_height;
    int win_gravity;
    /* this structure may be extended in the future */
} XSizeHints;</code></pre>
<p>To jistě není žádný zázrak, ale už se s tím dá něco dělat. Zajímavé hodnoty jsou ty s prefixem <code>min_</code> a <code>max_</code>. Pokud jsou nastavené na jinou hodnotu než 0 a zároveň se rovnají odpovídající si hodnoty, okno má zřejmě nastavenou fixní velikost.</p>
<pre class="haskell"><code>isFixed :: [CLong] -&gt; Bool
isFixed h = minWidth h == maxWidth h
         &amp;&amp; minHeight h == maxHeight h
         &amp;&amp; all (&gt;0) [minWidth h, maxWidth h, minHeight h, maxHeight h]</code></pre>
<p>V modulu <code>XMonad.Util.WindowProperties</code> je k dispozici funkce <code>getProp32s :: String -&gt; Window -&gt; X (Maybe [CLong])</code>, s jejíž pomocí už se dá napsat potřebná funkce pro manage hook. Definice typu <code>CLong</code> je v modulu <code>Foreign.C.Types</code>.</p>
<pre class="haskell"><code>isNonResizable :: Query Bool
isNonResizable = ask &gt;&gt;= \w -&gt; liftX $ do
    atom &lt;- getProp32s &quot;WM_NORMAL_HINTS&quot; w
    return $ case atom of
        Just hints  -&gt; hasFixedSize hints
        Nothing     -&gt; False</code></pre>
<p>Poslední chybějící kus jsou funkce na vrácení požadovaných rozměrů. Vlastně jde jenom o čitelnější zápisy vytažení příslušné hodnoty ze seznamu:</p>
<pre class="haskell"><code>minWidth  = (!! 5) :: [CLong] -&gt; CLong
minHeight = (!! 6) :: [CLong] -&gt; CLong
maxWidth  = (!! 7) :: [CLong] -&gt; CLong
maxHeight = (!! 8) :: [CLong] -&gt; CLong</code></pre>
<p>A to je asi tak všechno. Zatím mám pocit, že to funguje, žádné chyby jsem nepozoroval. <a href="/data/HandleFixedWindows.hs">Kompletní soubor</a> stačí nakopírovat do <code>~/.xmonad/lib/</code>, naimportovat do konfiguračního souboru a použít.</p>]]></summary>
</entry>
<entry>
    <title>UnitTest v C++</title>
    <link href="http://lubomir.github.io//cs/2010-12-19-unittest.html" />
    <id>http://lubomir.github.io//cs/2010-12-19-unittest.html</id>
    <published>2010-12-19T00:00:00Z</published>
    <updated>2010-12-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Unit testy jsou užitečná věc, pokud je třeba testovat jednotlivé funkce, třídy nebo metody. Většinou využívá nějakou knihovnu, což má oproti psaní testovacích kódů ručně výhodu v tom, že knihovna minimalizuje potřebu psát zbytečný kód okolo a rovnou poskytuje metody pro testování a případně i měření výkonu.</p>
<p>Já používám knihovnu <a href="http://unittest-cpp.sourceforge.net/">UnitTest++</a>, která je rozumným kompromisem mezi funkcionalitou a jednoduchostí.</p>
<h2 id="použití">Použití</h2>
<p>Testy pomocí UnitTest++ je možné psát do libovolného souboru s příponou <code>.cpp</code> i <code>.cc</code>, jak je komu libo. Pro kompilaci je potřeba kompilátoru předat informace o tom, kde najde příslušné hlavičkové soubory a potom i knihovnu. Obojí jsem zkompiloval a je na Aise dostupné v adresáři <code>/home/~xsedlar3/include</code>.</p>
<p>Na začátku testovacího souboru je pochopitelně třeba vložit hlavičky knihovny vlastního kódu, který je třeba testovat.</p>
<pre class="cpp"><code>#include &lt;unittest++/UnitTest++.h&gt;</code></pre>
<p>Ke spouštění testů je třeba přidat i funkci <code>main</code>:</p>
<pre class="cpp"><code>int main() {
    return UnitTest::RunAllTests();
}</code></pre>
<h2 id="testy">Testy</h2>
<p>Jednotlivé testy se píšou pomocí maker <code>TEST</code>, které má jeden parametr -- identifikátor, podle kterého půjde dohledávat, který test selhal. Následuje blok, ve kterém se provádí test.</p>
<pre class="cpp"><code>TEST(Addition) {
    CHECK(someFunction());
}</code></pre>
<p>K usnadnění psaní testů je definováno několik šikovných maker jako je výše uvedené <code>CHECK</code>. To jednoduše kontroluje, jestli se jeho argument vyhodnotí na <code>true</code>. Další možnosti jsou třeba <code>CHECK_EQUAL(co_cekam, testovany_vyraz)</code>, které ověří, že testovaný výraz vrací určenou hodnotu. Pořadí argumentů je tady docela důležité, pokud bude očekávaná hodnota jako druhá, případně chyby budou hlášené dost chaoticky. Další makra jsou popsána v <a href="http://unittest-cpp.sourceforge.net/UnitTest++.html">dokumentaci</a>.</p>
<p>Aby se i ve velkém souboru s testy dalo dobře orientovat, je možné jednotlivé testy dělit do sad pomocí makra <code>SUITE(nazev)</code>, případně je rozdělit do více souborů.</p>
<p>Jednoduchý test tedy může vypadat takto:</p>
<pre class="cpp"><code>TEST(InsertValueAtStart) {
    List&lt;int&gt; list;
    List&lt;int&gt;::ItemType *iter;

    iter = list.push_front(10);
    CHECK( ! list.empty());
    CHECK_EQUAL(10, it-&gt;getValue());
    CHECK_EQUAL(10, list.first()-&gt;getValue());
    CHECK_EQUAL(10, list.last()-&gt;getValue());
}</code></pre>
<h2 id="fixtures">Fixtures</h2>
<p>Při psaní testů se dá velice rychle narazit na situaci, že se na začátku několika testů opakuje stejná část, která jenom chystá objekt na další testovaní, např. plní seznam daty. Toto se dá zjednodušit přesunutím takovéto inicializace do tzv. fixture.</p>
<p>V případě knihovny UnitTest++ se jedná o definici třídy, jejíž konstruktor se zavolá na začátku testu, kde je použitá, a celý test se potom vykonává tak, že má přímo přístup k členským prvkům dané třídy. Místo makra <code>TEST</code> se potom použije <code>TEST_FIXTURE</code> se dvěma argumenty. Prvním je právě název fixture.</p>
<p>Může to tedy vypadat takto:</p>
<pre class="cpp"><code>struct LongList {
    LongList() {
        it1 = list.push_back(10);
        it2 = list.push_back(20);
        it3 = list.push_back(30);
        it4 = list.push_back(40);
        it5 = list.push_back(50);
        it6 = list.push_back(60);
    }

    std::string to_str() { return list_to_str(list); }

    List&lt;int&gt; list;
    List&lt;int&gt;::ItemType *it1, *it2, *it3, *it4, *it5, *it6;
};

TEST_FIXTURE(LongList, SwapTwoDistinctIntervals) {
    list.push_back(70);
    list.swap(it2, it3, it5, it6);
    CHECK_EQUAL(&quot;{ 10, 50, 60, 40, 20, 30, 70 }&quot;, to_str());
    list.swap(it5, it6, it2, it3);
    CHECK_EQUAL(&quot;{ 10, 20, 30, 40, 50, 60, 70 }&quot;, to_str());
}</code></pre>]]></summary>
</entry>
<entry>
    <title>Testování binárky</title>
    <link href="http://lubomir.github.io//cs/2010-12-19-testovani-binarky.html" />
    <id>http://lubomir.github.io//cs/2010-12-19-testovani-binarky.html</id>
    <published>2010-12-19T00:00:00Z</published>
    <updated>2010-12-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Pro usnadnění testování úkolů do PB071 a PB161 jsem si napsal jednoduchý skript. Vlastně jenom vezme spustitelný soubor, postupně mu předhazuje definované vstupy a kontroluje, co je na standardním výstupu, chybovém výstupu a s jakým kódem skončil. Volitelně se to celé dá prohánět valgrindem.</p>
<h2 id="formát-testů">Formát testů</h2>
<p>Všechny testy se ukládají do speciálního adresáře. Já používám název <code>tests</code>, ale prakticky na tom nezáleží. Každý tests se skládá alespoň ze dvou souborů s názvy třeba <code>01_valid_input.*</code>. Přípona souboru specifikuje, co soubor testuje.</p>
<dl>
<dt><code>*.in</code></dt>
<dd>toto přijde na standardní vstup <code>*.args</code>
</dd>
<dd>toto se předá jako argumenty (a zatím pořádně nefunguje, pokud některý argument má obsahovat mezeru.) <code>*.out</code>
</dd>
<dd>očekávaný výstup na stdout <code>*.err</code>
</dd>
<dd>očekávaný chybový výstup <code>*.ret</code>
</dd>
<dd>návratový kód programu
</dd>
</dl>
<p>Pokud některý soubor neexistuje, tak se příslušná část netestuje.</p>
<h2 id="použití">Použití</h2>
<p>Stáhněte si <a href="/data/stest.tar.bz2">archiv s testovacím skriptem</a> a pomocným souborem, který umožňuje vypisovat výsledky barevně. Skript <code>stest</code> je dobré mít v cestě, <code>.term_colors</code> může být buď přímo v domovském adresáři nebo na stejném místě jako <code>stest</code>.</p>
<p>K testování stačí spustit příkaz <code>stest ./NAZEV_BINARKY</code>, případně přidat ještě cestu k adresáři s testy. Další možnosti shrnuje nápověda <code>stest --help</code>.</p>]]></summary>
</entry>
<entry>
    <title>Inicializační funkce NCurses</title>
    <link href="http://lubomir.github.io//cs/2010-12-19-ncurses.html" />
    <id>http://lubomir.github.io//cs/2010-12-19-ncurses.html</id>
    <published>2010-12-19T00:00:00Z</published>
    <updated>2010-12-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Tato stránka je částečným překladem <a href="http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/">tutoriálu NCurses</a>, konkrétně <a href="http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/init.html">této části</a>. Tento text tedy není mým dílem a vztahuje se na něj licence původního návodu.</p>
<h2 id="inicializační-funkce">4 Inicializační funkce</h2>
<ol type="1">
<li><p><strong>raw() a cbreak()</strong></p>
<p>Normálně ovladač terminálu ukládá uživatelem zadané znaky do bufferu, dokud uživatel nestiskne enter. Většina programů ale potřebuje, aby byly znaky dostupné hned, když je uživatel zadá. Tyto dvě funkce zakazují bufferování řádků. Rozdíl mezi nimi je ve zpracování ovládacích znaků zadávaných z klávesnice (např. Ctrl-Z, Ctrl-C). Po zavolání raw() jsou tyto znaky předány programu a nevygenerují signál. V režimu cbreak() jsou tyto znaky interpretovány přímo ovladačem terminálu.</p></li>
<li><p><strong>echo() a noecho()</strong></p>
<p>Tyto funkce ovládají, jestli se znaky zadávané uživatelem zobrazují na obrazovku či nikoli. Většina interaktivních programů volá na začátku noecho() a pokud to potřebuje, tak znaky vypisuje kontrolovaně sama.</p></li>
<li><p><strong>keypad()</strong></p>
<p>Tato inicializační funkce umožňuje čtení funkčních kláves jako F1,, kurzorové klávesy atd. Téměř každý interaktivní program toto povoluje, protože šipky jsou zásadní částí každé uživatelského rozhraní. Abyste povolili tuto vlastnost pro standardní obrazovku (stdscr), zavolejte <code>keypad(stdscr,TRUE)</code>.</p></li>
<li><p><strong>halfdelay()</strong></p>
<p>Přestože tato funkce není používaná příliš často, je občas velice užitečná. Vstup je okamžitě předán programu jako po zavolání <code>cbreak()</code> s tím rozdílem, že čeká X desetin sekundy na vstup a jestliže potom není vstup dostupný, vrátí ERR. X je interval zadaný jako argument při volání halfdelay(). Tato funkce je užitečná, pokud potřebujete nějaký vstup, ale když uživatel neodpoví dostatečně rychle, chcete udělat něco jiného.</p></li>
</ol>]]></summary>
</entry>
<entry>
    <title>Jak se projevuje 'const'</title>
    <link href="http://lubomir.github.io//cs/2010-12-19-const.html" />
    <id>http://lubomir.github.io//cs/2010-12-19-const.html</id>
    <published>2010-12-19T00:00:00Z</published>
    <updated>2010-12-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Toto je testovací kód, který se pochopitelně nezkompiluje, a i kdyby, nic rozumného dělat nebude. Stejně jako <code>strcpy</code> se chová i <code>free</code>.</p>
<pre class="c"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main (void)
{
  const char *       str1 = (char*) malloc(10*sizeof(char));
  char * const       str2 = (char*) malloc(10*sizeof(char));
  const char * const str3 = (char*) malloc(10*sizeof(char));

  str1 = NULL;
  str2 = NULL;
  str3 = NULL;

  strcpy(str1, &quot;a&quot;);
  strcpy(str2, &quot;a&quot;);
  strcpy(str3, &quot;a&quot;);

  return 0;
}</code></pre>
<h2 id="jak-to-vidí-gcc-4.4.5">Jak to vidí <a href="http://gcc.gnu.org/">GCC</a> 4</h2>
<table>
<tr>
<pre><code>&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;x = NULL&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;strcpy(x, &quot;a&quot;)&lt;/code&gt;&lt;/th&gt;</code></pre>
</tr>
<tr>
<pre><code>&lt;th&gt;&lt;code&gt;const char *&lt;/code&gt;&lt;/th&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;&lt;code&gt;error: invalid conversion from &#39;const char*&#39; to &#39;char*&#39;&lt;/code&gt;&lt;/td&gt;</code></pre>
</tr>
<tr>
<pre><code>&lt;th&gt;&lt;code&gt;char * const&lt;/code&gt;&lt;/th&gt;
&lt;td&gt;&lt;code&gt;error: assignment to read-only variable&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;</code></pre>
</tr>
<tr>
<pre><code>&lt;th&gt;&lt;code&gt;const char * const&lt;/code&gt;&lt;/th&gt;
&lt;td&gt;&lt;code&gt;error: assignment to read-only variable&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;error: invalid conversion from &#39;const char*&#39; to &#39;char*&#39;&lt;/code&gt;&lt;/td&gt;</code></pre>
</tr>
</table>
<h2 id="jak-to-vidí-clang-1.1">Jak to vidí <a href="http://clang.llvm.org/">CLang</a> 1</h2>
<table>
<tr>
<pre><code>&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;x = NULL&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;strcpy(x, &quot;a&quot;)&lt;/code&gt;&lt;/th&gt;</code></pre>
</tr>
<tr>
<pre><code>&lt;th&gt;&lt;code&gt;const char *&lt;/code&gt;&lt;/th&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;&lt;pre&gt;&lt;code class=&quot;long&quot;&gt;error: no matching function for call to &#39;strcpy&#39;</code></pre>
note: candidate function not viable: 1 argument ('char const *const') would lose const qualifier</code>
</pre>
</td>
</tr>
<tr>
<pre><code>&lt;th&gt;&lt;code&gt;char * const&lt;/code&gt;&lt;/th&gt;
&lt;td&gt;&lt;code&gt;error: read-only variable is not assignable&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;</code></pre>
</tr>
<tr>
<pre><code>&lt;th&gt;&lt;code&gt;const char * const&lt;/code&gt;&lt;/th&gt;
&lt;td&gt;&lt;code&gt;error: read-only variable is not assignable&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;pre&gt;&lt;code class=&quot;long&quot;&gt;error: no matching function for call to &#39;strcpy&#39;</code></pre>
note: candidate function not viable: 1 argument ('char const *const') would lose const qualifier</code>
</pre>
</td>
</tr>
</table>]]></summary>
</entry>

</feed>
