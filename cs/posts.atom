<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>lsedlar</title>
    <link href="https://lubomir.github.io/cs/posts.atom" rel="self" />
    <link href="https://lubomir.github.io" />
    <id>https://lubomir.github.io/cs/posts.atom</id>
    <author>
        <name>Lubomír Sedlář</name>
        <email>lubomir.sedlar@gmail.com</email>
    </author>
    <updated>2016-01-06T19:52:56Z</updated>
    <entry>
    <title>Popisná statistika v R</title>
    <link href="https://lubomir.github.io/cs/2013-04-25-statistika-v-r.html" />
    <id>https://lubomir.github.io/cs/2013-04-25-statistika-v-r.html</id>
    <published>2013-04-25T00:00:00Z</published>
    <updated>2016-01-06T19:52:56Z</updated>
    <summary type="html"><![CDATA[<p>Tento text je výcuc z mých poznatků, které jsem nabyl při vypracování projektu do jistého matematického předmětu.</p>
<h2 id="načítání-dat-a-první-průzkum">Načítání dat a první průzkum</h2>
<p>V první řadě je potřeba načíst soubor s daty. Za předpokladu, že máme data ve formátu CSV, se nám bude hodit příkaz <code>read.csv</code> (jak nečekané…). Taky by bylo dobré zjistit, jak vlastně data vypadají, tedy jaké jsou názvy atributů a jak vypadá prvních pár záznamů.</p>
<div class="sourceCode"><pre class="sourceCode R"><code class="sourceCode r">&gt;<span class="st"> </span>data &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;nazev_souboru.csv&quot;</span>)
&gt;<span class="st"> </span><span class="kw">names</span>(data)
...
&gt;<span class="st"> </span><span class="kw">head</span>(data)
...</code></pre></div>
<p>Jednotlivé atributy je potom možné adresovat přes notaci se znakem <code>$</code>, tedy třeba <code>data$atr1</code>. Funkce <code>nrow(data)</code> nám prozradí, kolik je v datovém rámci záznamů.</p>
<p>Pro kvalitativní atributy se hodí výpis hodnot s příslušnou četností. To se dá udělat pomocí funkce <code>table</code>. Pokud bychom chtěli relativní četnosti, stačí celou tabulku podělit počtem řádků.</p>
<div class="sourceCode"><pre class="sourceCode R"><code class="sourceCode r">&gt;<span class="st"> </span><span class="kw">table</span>(data$class)

   <span class="dv">1</span>    <span class="dv">2</span>
 <span class="dv">700</span>  <span class="dv">300</span>
&gt;<span class="st"> </span><span class="kw">table</span>(data$class) /<span class="st"> </span><span class="kw">nrow</span>(data)

  <span class="dv">1</span>   <span class="dv">2</span>
<span class="fl">0.7</span> <span class="fl">0.3</span></code></pre></div>
<p>Pro atributy s větším počtem hodnot než jenom dvě je možné vygenerovat tabulku kumulativních relativních četností pomocí funkce <code>cumsum()</code>.</p>
<p>Pro vizualizaci kvalitativních atributů se hodí např. sloupkový diagram, který je možné vytvořit pomocí funkce <code>barplot</code> aplikované na tabulku četností (třeba i kumulativních). Jiná možnost je polygon četností – funkce <code>plot</code>, jejíž první argument je tabulka, kterou chceme vizualizovat. Polygon četností navíc vyžaduje argument <code>type=&quot;b&quot;</code>, tedy typ grafu <em>both</em>, což znamená puntíky spojené čarami.</p>
<div class="sourceCode"><pre class="sourceCode R"><code class="sourceCode r">&gt;<span class="st"> </span><span class="kw">barplot</span>(<span class="kw">table</span>(data$class))
&gt;<span class="st"> </span><span class="kw">plot</span>(<span class="kw">table</span>(data$at7), <span class="dt">type=</span><span class="st">&quot;b&quot;</span>)</code></pre></div>
<p>Další užitečné atributy pro grafy jsou:</p>
<dl>
<dt><code>main</code></dt>
<dd>hlavní titulek umístěný nad grafem
</dd>
<dt><code>xlab</code>, <code>ylab</code></dt>
<dd>popisek osy x, resp. osy y
</dd>
<dt><code>col</code></dt>
<dd>vektor barev použitý pro graf, případně jedna barva jako řetězec, význam se zřejmě liší pro jednotlivé typy grafu; např. <code>col=c(&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;)</code>
</dd>
<dt><code>pch</code></dt>
<dd>typ puntíku
</dd>
<dt><code>cex</code></dt>
<dd>velikost vykreslovaných puntíků
</dd>
</dl>
<h2 id="kontingenční-tabulky">Kontingenční tabulky</h2>
<p>Závislosti mezi jednotlivými atributy je možné zkoumat třeba pomocí kontingenční tabulky. Tu opět produkuje funkce <code>table</code>, tentokrát se dvěma argumenty. První argument (a tedy datová sada) určuje řádky, druhý argument jsou sloupce.</p>
<p>Z této tabulky je možné dopočítat kontingenční tabulku řádkově (nebo sloupcově) podmíněných četností. Nenašel jsem k tomu ale vestavěnou funkci, takže to bude vyžadovat trochu černé magie.</p>
<p>Pro řádkově podmíněné četnosti stačí každou hodnotu v kontingenční tabulce absolutních četností podělit součtem hodnot na příslušném řádku. Součty po řádcích je možné vyprodukovat pomocí funkce <code>rowSums</code>. Tabulky potom stačí podělit.</p>
<div class="sourceCode"><pre class="sourceCode R"><code class="sourceCode r">&gt;<span class="st"> </span><span class="kw">table</span>(atribut1, atribut2) /<span class="st"> </span><span class="kw">rowSums</span>(<span class="kw">table</span>(atribut1, atribut2))</code></pre></div>
<p>Se sloupcově podmíněnými četnosti je to trochu horší. Existuje funkce <code>colSums</code>, která spočítá sumy přes sloupce, jednoduché dělení jako v předchozím případě ale nebude fungovat, protože tabulky si nebudou rozměrově správně odpovídat. Řešením je využít funkci s lakonickým názvem <code>t</code>, která transponuje svůj jediný argument.</p>
<div class="sourceCode"><pre class="sourceCode R"><code class="sourceCode r">&gt;<span class="st"> </span>tab &lt;-<span class="st"> </span><span class="kw">table</span>(atribut1, atribut2)
&gt;<span class="st"> </span><span class="kw">t</span>(<span class="kw">t</span>(tab) /<span class="st"> </span><span class="kw">colSums</span>(tab))</code></pre></div>
<p>Správnost výsledků se dá ověřit například pomocí dalšího volání <code>rowSums</code>, V tabulce řádkově podmíněných četností by měla být suma na každém řádku rovna 1, obdobně pro sloupce pro sloupcově podmíněné četnosti.</p>
<h2 id="generování-histogramů">Generování histogramů</h2>
<p>Základní histogram se dá udělat pomocí funkce <code>hist</code>. Bez nějakých dalších argumentů ale vytvoří nehezkou obludu. Hlavní kámen úrazu této funkce je nastavování počtu intervalů. Pomocí argumenty <code>breaks</code> je sice možné zadat číslo nebo název metody, ale je to jenom doporučení a funkce se tím nemusí přesně řídit. Navíc výchozí nastavení vygeneruje nepříliš přehlednou osu <span class="math inline"><em>x</em></span>, ze které se těžko odečítají hranice intervalů.</p>
<p>Nicméně můžeme tady využít možnosti definice vlastních funkcí a napsat vlastní vykreslování histogramů. Tato funkce bude očekávat data ve stejném formátu jako standardní <code>hist</code>, počet intervalů, a volitelný popisek osy <span class="math inline"><em>x</em></span>.</p>
<div class="sourceCode"><pre class="sourceCode R"><code class="sourceCode r">myhist &lt;-<span class="st"> </span>function(data, num_bins, <span class="dt">lab=</span><span class="st">&#39;data&#39;</span>) {
    <span class="co"># Spočítáme šířku intervalu s přesností na jedno desetinné místo</span>
    width &lt;-<span class="st"> </span><span class="kw">round</span>((<span class="kw">max</span>(data) -<span class="st"> </span><span class="kw">min</span>(data)) /<span class="st"> </span>num_bins, <span class="dt">digits=</span><span class="dv">1</span>)
    <span class="co"># Uděláme vektor bodů, kde začínají a končí intervaly</span>
    breaks &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="kw">min</span>(data), <span class="kw">min</span>(data) +<span class="st"> </span>num_bins *<span class="st"> </span>width, <span class="dt">by=</span>width)
    <span class="co"># Pro jistotu vypíšeme šířku intervalu na výstup</span>
    <span class="kw">cat</span>(<span class="st">&#39;Bin width = &#39;</span>, width, <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>)

    <span class="co"># Nastavíme okraje</span>
    <span class="kw">par</span>(<span class="dt">mar=</span><span class="kw">c</span>(<span class="dv">6</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">2</span>))
    <span class="kw">hist</span>(data, <span class="dt">breaks=</span>breaks,
        <span class="dt">xaxt=</span><span class="st">&#39;n&#39;</span>,               <span class="co"># Nechceme osu X</span>
        <span class="dt">xlab=</span><span class="st">&#39;&#39;</span>,                <span class="co"># Ani její popisek</span>
        <span class="dt">main=</span><span class="st">&#39;&#39;</span>,                <span class="co"># I hlavní titulek vynecháme</span>
        <span class="dt">col=</span><span class="st">&#39;lightblue&#39;</span>,        <span class="co"># Barva výplně sloupců</span>
        <span class="dt">border=</span><span class="st">&#39;blue&#39;</span>,          <span class="co"># Barva rámečku sloupců</span>
        <span class="dt">ylab=</span><span class="st">&#39;Absolutní četnost&#39;</span>)
    <span class="co"># Přidáme vlastní osu</span>
    <span class="kw">axis</span>(<span class="dv">1</span>,                     <span class="co"># Kreslíme osu X</span>
        <span class="dt">at=</span>breaks,              <span class="co"># Chceme značky na hranicích intervalů</span>
        <span class="dt">las=</span><span class="dv">2</span>)                  <span class="co"># Test bude vertikálně, aby se to tam vešlo</span>
    <span class="co"># Vykreslíme popisek pod osou</span>
    <span class="kw">mtext</span>(lab, <span class="dt">side=</span><span class="dv">1</span>, <span class="dt">line=</span><span class="dv">4</span>)  <span class="co"># Číslo u line udává, jak daleko bude text od</span>
                                <span class="co"># grafu</span>

    <span class="co"># Volitelně bychom mohli ještě do rohu přidat informaci o šířce intervalu</span>
    leg &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="st">&#39;Šířka intervalu&#39;</span>, <span class="kw">format</span>(width))
    <span class="kw">legend</span>(<span class="st">&#39;topright&#39;</span>, leg, <span class="dt">box.lty=</span><span class="dv">0</span>)
}</code></pre></div>
<p>Jako argumenty <code>col</code> a <code>border</code> funkce <code>hist</code> by bylo možné zadat i vektory barev, kdybychom to chtěli oživit. Nechceme.</p>
<p>Velikost fontu se dá ovlivnit parametrem <code>cex</code>. Je potřeba ho zadat u <code>par</code> a <code>mtext</code>.</p>
<figure>
<img src="/images/r-histogram.png" alt="Ukázka vytvořeného histogramu" /><figcaption>Ukázka vytvořeného histogramu</figcaption>
</figure>
<h2 id="korelace-a-regresní-přímka">Korelace a regresní přímka</h2>
<p>Když už máme dva numerické atributy, můžeme mezi nimi hledat hledat nějaké vztahy. Korelační koeficienty se dají počítat funkcí <code>cor(atribut1, atribut2, method=&quot;pearson&quot;)</code>. Další dostupné metody jsou <code>spearman</code> a <code>kendall</code>.</p>
<p>Vypočítat koeficienty regresní přímky lze pomocí funkce <code>lm</code>. Vykreslení do grafu potom provede funkce <code>abline</code> aplikovaná na to, co vrátí <code>lm</code>.</p>
<div class="sourceCode"><pre class="sourceCode R"><code class="sourceCode r">&gt;<span class="st"> </span><span class="kw">lm</span>(loans ~<span class="st"> </span>ages)
...
Coefficients:
(Intercept)         ages
   <span class="fl">2982.684</span>        <span class="fl">8.118</span>
&gt;<span class="st"> </span><span class="kw">abline</span>(<span class="kw">lm</span>(loans ~<span class="st"> </span>ages))</code></pre></div>
<p>Před samotným vykreslením přímky je možné si nachystat třeba tečkový diagram atributů, jejichž závislost hledáme.</p>
<div class="sourceCode"><pre class="sourceCode R"><code class="sourceCode r">&gt;<span class="st"> </span><span class="kw">plot</span>(ages,        <span class="co"># Co bude na ose X</span>
       loans)       <span class="co"># Co bude na ose Y</span></code></pre></div>
<h2 id="ukládání-do-souborů">Ukládání do souborů</h2>
<p>Uložení vytvořeného grafu do souboru je vlastně naprosto triviální. Před voláním vykreslovacích funkcí je potřeba přesměrovat výstup do požadovaného souboru pomocí funkce, jejíž název určí formát výstupu a jediný argument název výstupního souboru. Dostupné jsou minimálně <code>pdf</code> a <code>png</code>. Až je dokresleno, zavolání <code>dev.off()</code> zase přesměruje výstup na obrazovku.</p>
<h2 id="další-užitečné-funkce">Další užitečné funkce</h2>
<ul>
<li>Funkce <code>source</code> jako argument očekává jméno souboru a chová se jako stejnojmenný příkaz v Bashi.</li>
<li>Zaokrouhlení hodnot na určitý počet desetinných míst se dá provést pomocí <code>round(x, digits=N)</code>, kde <code>x</code> může být číslo nebo klidně i tabulka.</li>
<li>Pokud před název funkce napíšeme otazník, dostaneme poměrně podrobnou nápovědu. Např. <code>?table</code>.</li>
</ul>
<h2 id="odkazy">Odkazy</h2>
<ul>
<li><a href="http://www.r-tutor.com/elementary-statistics">Pěkný úvod do popisné statistiky v R</a></li>
</ul>]]></summary>
</entry>
<entry>
    <title>Zpracování PDF</title>
    <link href="https://lubomir.github.io/cs/2013-04-02-zpracovani-pdf.html" />
    <id>https://lubomir.github.io/cs/2013-04-02-zpracovani-pdf.html</id>
    <published>2013-04-02T00:00:00Z</published>
    <updated>2016-01-06T19:52:56Z</updated>
    <summary type="html"><![CDATA[<p>Občas se mi dostane do rukou naskenovaná knížka ve formátu PDF, kde jsou vždy dvě stránky původního textu na jedné virtuální stránce. Člověk se potom musí posouvat nejen směrem dolů, ale i do stran a občas nahoru. Hlavně na mobilu nic moc.</p>
<p>Nakonec jsem našel relativně spolehlivý způsob, jak takový monolit rozporcovat na menší kousky, a abych to nezapomněl, tak si to poznamenám.</p>
<p>Budeme potřebovat <a href="http://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/">pdftk</a>, <a href="http://www.imagemagick.org/script/index.php">imagemagick</a> a <a href="http://poppler.freedesktop.org/">poppler-utils</a>. V Debianu je všechno nachystané v repozitářích.</p>
<h2 id="nasekat-na-jemno-prosím">Nasekat na jemno, prosím</h2>
<p>Nejdřív původní soubor nasekáme na jednotlivé stránky. Následující příkaz vytvoří z každé stránky v původním pdf jeden soubor.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">pdftk</span> VSTUPNI.PDF burst</code></pre></div>
<p>Tímto vznikne plus minus autobus milion souborů s názvy <code>pg_0001.pdf</code>.</p>
<h2 id="protřepat-nemíchat">Protřepat, nemíchat</h2>
<p>Následující krok by měl každý vytvořený soubor vertikálně rozpůlit. K tomu se dá použít třeba programů z balíku <code>poppler-utils</code>. Abychom se s tím zbytečně nepárali, vezmeme to všechno naráz.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">for</span> <span class="kw">i</span> in pg_*pdf<span class="kw">;</span> <span class="kw">do</span>
    <span class="kw">pdftoppm</span> <span class="ot">$i</span> <span class="kw">&gt;</span><span class="ot">${i/</span>pdf<span class="ot">/</span>ppm<span class="ot">}</span>
    <span class="kw">convert</span> <span class="ot">$(</span><span class="kw">i/pdf</span>/<span class="kw">ppm</span>} <span class="kw">-crop</span> 50%x100% +repage vystup-<span class="ot">$i</span>
<span class="kw">done</span></code></pre></div>
<p>Jakkoli děsivě ta substituce vypadá, dělá jen jednu věc: nahradí příponu <code>pdf</code> příponou <code>ppm</code>. Následující příkaz z balíku <code>imagemagick</code> potom akorát obrázek rozsekne napůl (tady se dá pohrát s konkrétním číslem) a výsledek uloží jako dvoustránkové PDF do souboru <code>vystup-pg_0001.pdf</code>.</p>
<h2 id="matláma-patláma-paprčála">Matláma patláma paprčála</h2>
<p>Teď už stačí znovu použít <code>pdftk</code> a všechno to zase nakombinovat do jednoho souboru.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">pdftk</span> vystup-* cat output spojeny.pdf</code></pre></div>
<p>Zjevně není nutné vytvářet pouze jeden monolit, ale jde to rozdělit do souborů třeba po kapitolách. Taky je snadné vyhodit nezajímavé stránky.</p>
<h2 id="optimalizace-velikosti">Optimalizace velikosti</h2>
<p>Popis výš má zásadní problém: vytvořený soubor má rozměry slona po obědě. Možnou odtučňovací kůrou je třeba <code>ghostscript</code>.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">gs</span> -dCompatibilityLevel=1.4 -dPDFSETTINGS=/screen -dNOPAUSE \
<span class="kw">&gt;</span> -dBATCH -sDEVICE=pdfwrite -sOutputFile=output.pdf spojeny.pdf</code></pre></div>
<p>Tím se každá stránka přepočítá na plus minus 72 dpi, což je dost pro monitor. Na tisk už to ale stačit nebude. Další možnosti jsou <code>/ebook</code>, <code>/printer</code>, <code>/prepress</code>.</p>]]></summary>
</entry>
<entry>
    <title>Derivací k regulárním výrazům</title>
    <link href="https://lubomir.github.io/cs/2012-03-20-derivaci-k-regularnim-vyrazum.html" />
    <id>https://lubomir.github.io/cs/2012-03-20-derivaci-k-regularnim-vyrazum.html</id>
    <published>2012-03-20T00:00:00Z</published>
    <updated>2016-01-06T19:52:56Z</updated>
    <summary type="html"><![CDATA[<p>V předmětu <a href="http://www.fi.muni.cz/~sojka/PV030/">PV030</a> se člověk mimo jiné potká s algoritmy pro práci s regulárními výrazy. Jedním z nich je i metoda konverze regulárního výrazu na konečný automat, a ne nedeterministický s <span class="math inline"><em>ϵ</em></span>-kroky. Touto metodou je možné rovnou vyrobit minimální deterministický konečný automat. A jak lépe porozumět algoritmu než si ho zkusit naprogramovat?</p>
<p>Podrobnější popis je algoritmu je k dispozici <a href="http://www.fi.muni.cz/~sojka/PV030/2012-03-15.pdf">ve slidech</a>, případně ve článku <a href="http://dl.acm.org/citation.cfm?id=321249"><em>Derivatives of Regular Expressions</em></a>, jehož autorem je <em>Janusz A. Brzozowski</em>.</p>
<figure>
<img src="/images/regex0.png" alt="a^*b+(c+d+e)a" /><figcaption><span class="math inline"><em>a</em><sup>*</sup><em>b</em> + (<em>c</em> + <em>d</em> + <em>e</em>)<em>a</em></span></figcaption>
</figure>
<h2 id="importujeme">Importujeme</h2>
<p>Budeme potřebovat importovat několik modulů, většinu z nich pro parsování výrazu.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">S</span>
<span class="kw">import </span><span class="dt">Text.Parsec.Char</span>
<span class="kw">import </span><span class="dt">Text.Parsec.String</span>
<span class="kw">import </span><span class="dt">Text.Parsec.Combinator</span>
<span class="kw">import </span><span class="dt">Text.Parsec.Prim</span>
<span class="kw">import </span><span class="dt">Text.Parsec.Expr</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span> ((&lt;*), (*&gt;))
<span class="kw">import </span><span class="dt">Data.Maybe</span> (fromMaybe)
<span class="kw">import </span><span class="dt">Data.List</span> (tails, foldl&#39;)</code></pre></div>
<h2 id="datové-typy">Datové typy</h2>
<p>Je potřeba nějak reprezentovat jak samotný regulární výraz, tak i výsledný automat. Regexp je možné reprezentovat jako strom. Listy jsou základní výrazy, uzly potom zřetězení, alternativa a iterace.</p>
<p>Později budeme potřebovat určovat, jestli nějaký regulární výraz popisuje (mimo jiné) prázdné slovo. Pro urychlení tedy u těch konstruktorů, kde to není zřejmé, přidáme tuto informaci.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Regex</span> a <span class="fu">=</span> <span class="dt">Epsilon</span>
             <span class="fu">|</span> <span class="dt">Zero</span>
             <span class="fu">|</span> <span class="dt">Simple</span> a
             <span class="fu">|</span> <span class="dt">Plus</span> <span class="dt">Bool</span> (<span class="dt">Regex</span> a) (<span class="dt">Regex</span> a)
             <span class="fu">|</span> <span class="dt">Conc</span> <span class="dt">Bool</span> (<span class="dt">Regex</span> a) (<span class="dt">Regex</span> a)
             <span class="fu">|</span> <span class="dt">Iter</span> (<span class="dt">Regex</span> a)
             <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</code></pre></div>
<p>Pro konečný automat bude potřeba další typ. Automat má nějaké přechody, množinu stavů a počáteční stav. Položka <code>isAccepting</code> je funkce, která pro stav řekne, jestli je akceptující.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Node</span> <span class="fu">=</span> <span class="dt">Regex</span> <span class="dt">Char</span>  <span class="co">-- ^ Popisek stavu</span>

<span class="kw">data</span> <span class="dt">FiniteAutomaton</span> <span class="fu">=</span> <span class="dt">FiniteAutomaton</span>
                     {<span class="ot"> transitions ::</span> <span class="dt">M.Map</span> (<span class="dt">Node</span>,<span class="dt">Char</span>) <span class="dt">Node</span>
                     ,<span class="ot"> states      ::</span> <span class="dt">S.Set</span> <span class="dt">Node</span>
                     ,<span class="ot"> startNode   ::</span> <span class="dt">Node</span>
                     ,<span class="ot"> isAccepting ::</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
                     }</code></pre></div>
<p>V první řadě nadefinujeme tři pomocné funkce pro spojování regexpů, které se postarají o korektní vyplnění pomocné boolovské části a taky zabrání vzniku několika patologických výrazů – např. nemá smysl řetězit něco s prázdným slovem. Jiný příklad je výraz <code>(E*)*</code>, který je ekvivalentní s <code>E*</code> (a navíc vede k zacyklení).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">plus ::</span> <span class="dt">Regex</span> a <span class="ot">-&gt;</span> <span class="dt">Regex</span> a <span class="ot">-&gt;</span> <span class="dt">Regex</span> a
plus <span class="dt">Zero</span> x <span class="fu">=</span> x
plus x <span class="dt">Zero</span> <span class="fu">=</span> x
plus x y    <span class="fu">=</span> <span class="dt">Plus</span> (canBeEpsilon x <span class="fu">||</span> canBeEpsilon y) x y

<span class="ot">conc ::</span> <span class="dt">Regex</span> a <span class="ot">-&gt;</span> <span class="dt">Regex</span> a <span class="ot">-&gt;</span> <span class="dt">Regex</span> a
conc <span class="dt">Epsilon</span> x <span class="fu">=</span> x
conc x <span class="dt">Epsilon</span> <span class="fu">=</span> x
conc <span class="dt">Zero</span> _    <span class="fu">=</span> <span class="dt">Zero</span>
conc _ <span class="dt">Zero</span>    <span class="fu">=</span> <span class="dt">Zero</span>
conc x y       <span class="fu">=</span> <span class="dt">Conc</span> (canBeEpsilon x <span class="fu">&amp;&amp;</span> canBeEpsilon y) x y

<span class="ot">iter ::</span> <span class="dt">Regex</span> a <span class="ot">-&gt;</span> <span class="dt">Regex</span> a
iter (<span class="dt">Iter</span> x) <span class="fu">=</span> <span class="dt">Iter</span> x
iter x        <span class="fu">=</span> <span class="dt">Iter</span> x</code></pre></div>
<p>Jak jsem psal výše, musíme být schopní pro daný výraz <span class="math inline"><em>E</em></span> určit, jestli <span class="math inline"><em>L</em>(<em>E</em>)</span> obsahuje <span class="math inline"><em>ϵ</em></span>. Vzhledem k tomu, kolikrát se tato funkce bude volat při derivování, by bylo dobré, aby dokázala fungovat v konstantním čase.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">canBeEpsilon ::</span> <span class="dt">Regex</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
canBeEpsilon <span class="dt">Epsilon</span>      <span class="fu">=</span> <span class="dt">True</span>
canBeEpsilon <span class="dt">Zero</span>         <span class="fu">=</span> <span class="dt">False</span>
canBeEpsilon (<span class="dt">Simple</span> _)   <span class="fu">=</span> <span class="dt">False</span>
canBeEpsilon (<span class="dt">Conc</span> e _ _) <span class="fu">=</span> e
canBeEpsilon (<span class="dt">Plus</span> e _ _) <span class="fu">=</span> e
canBeEpsilon (<span class="dt">Iter</span> _)     <span class="fu">=</span> <span class="dt">True</span></code></pre></div>
<h2 id="parsování">Parsování</h2>
<p>A nyní hurá na parsování. <code>Parsec</code> nabízí úžasné možnosti, jak parsovat aritmetické i jiné výrazy. Jediná složitější věc je tady parser pro jednotlivý znak, protože umožňuje využít zpětného lomítka k escapování znaků hvězdičky, plusu a závorek, které by jinak měly speciální význam.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">regexP, termP,<span class="ot"> simpleP ::</span> <span class="dt">Parser</span> (<span class="dt">Regex</span> <span class="dt">Char</span>)
regexP <span class="fu">=</span> buildExpressionParser table termP
termP <span class="fu">=</span> simpleP <span class="fu">&lt;|&gt;</span> char <span class="ch">&#39;(&#39;</span> <span class="fu">*&gt;</span> regexP <span class="fu">&lt;*</span> char <span class="ch">&#39;)&#39;</span>
table <span class="fu">=</span> [ [ <span class="dt">Postfix</span> <span class="fu">$</span> char <span class="ch">&#39;*&#39;</span> <span class="fu">&gt;&gt;</span> return iter ]
        , [<span class="dt">Infix</span> (return conc) <span class="dt">AssocLeft</span>]
        , [<span class="dt">Infix</span> (char <span class="ch">&#39;+&#39;</span> <span class="fu">&gt;&gt;</span> return plus) <span class="dt">AssocLeft</span>]
        ]
simpleP <span class="fu">=</span> <span class="kw">do</span>
    c&#39; <span class="ot">&lt;-</span> noneOf <span class="st">&quot;()+*&quot;</span>
    c <span class="ot">&lt;-</span> <span class="kw">if</span> c&#39; <span class="fu">==</span> <span class="ch">&#39;\\&#39;</span>
            <span class="kw">then</span> anyChar
            <span class="kw">else</span> return c&#39;
    return (<span class="dt">Simple</span> c)</code></pre></div>
<p>Parser <code>regexP</code> teď můžeme obalit pomocnou funkcí.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fromString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Regex</span> <span class="dt">Char</span>
fromString str <span class="fu">=</span> <span class="kw">case</span> parse (regexP <span class="fu">&lt;*</span> eof) <span class="st">&quot;&quot;</span> str <span class="kw">of</span>
    <span class="dt">Left</span> _  <span class="ot">-&gt;</span> <span class="dt">Zero</span>
    <span class="dt">Right</span> r <span class="ot">-&gt;</span> r</code></pre></div>
<h2 id="derivace">Derivace</h2>
<p>Funkce pro derivaci regulárních výrazů je skoro doslovným přepisem definice ze <a href="http://www.fi.muni.cz/~sojka/PV030/2012-03-15.pdf">slidů</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">derive ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Regex</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Regex</span> a
derive <span class="dt">Zero</span>    _      <span class="fu">=</span> <span class="dt">Zero</span>
derive <span class="dt">Epsilon</span> _      <span class="fu">=</span> <span class="dt">Zero</span>
derive (<span class="dt">Simple</span> x) y
    <span class="fu">|</span> x <span class="fu">==</span> y          <span class="fu">=</span> <span class="dt">Epsilon</span>
    <span class="fu">|</span> otherwise       <span class="fu">=</span> <span class="dt">Zero</span>
derive (<span class="dt">Plus</span> _ p q) x <span class="fu">=</span> plus (derive p x) (derive q x)
derive (<span class="dt">Conc</span> _ p q) x
    <span class="fu">|</span> canBeEpsilon p  <span class="fu">=</span> plus (conc (derive p x) q) (derive q x)
    <span class="fu">|</span> otherwise       <span class="fu">=</span> conc (derive p x) q
derive (<span class="dt">Iter</span> p) x     <span class="fu">=</span> conc (derive p x) (iter p)</code></pre></div>
<h2 id="konstrukce-automatu">Konstrukce automatu</h2>
<p>A můžeme budovat automat! Samotný algoritmus běží v cyklu <code>run</code>, v kterém postupně vytvoříme jak množinu stavů, tak tabulku přechodů.</p>
<p>V každé iteraci vezmeme všechny regulární výrazy z fronty <code>q</code> a každý zderivujeme každým písmenem abecedy. Z těchto všech derivací přidáme nové stavy a přechody mezi ty, co už jsme napočítali. Zároveň nově přidané stavy tvoří novou frontu.</p>
<p>Nemá smysl přidávat žádné hrany, které vedou do stavu odpovídajícího regexpu <code>Zero</code>, tím se jenom zbytečně zvětšuje tabulka přechodů.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toFA ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Regex</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">FiniteAutomaton</span>
toFA alphabet re <span class="fu">=</span> <span class="dt">FiniteAutomaton</span> { startNode <span class="fu">=</span> re
                                   , transitions <span class="fu">=</span> allTransitions
                                   , states <span class="fu">=</span> allStates
                                   , isAccepting <span class="fu">=</span> canBeEpsilon
                                   }
  <span class="kw">where</span>
    (allStates, allTransitions) <span class="fu">=</span> run (S.singleton re, M.empty) [re]

    run res []  <span class="fu">=</span> res
    run (s,t) q <span class="fu">=</span> run (newStates, newTransitions) newQueue
        <span class="kw">where</span>
            allD           <span class="fu">=</span> [ ((r,a), derive r a) <span class="fu">|</span> r <span class="ot">&lt;-</span> q, a <span class="ot">&lt;-</span> alphabet ]
            derivedStates  <span class="fu">=</span> S.fromList <span class="fu">$</span> map snd allD
            newStates      <span class="fu">=</span> s <span class="ot">`S.union`</span> derivedStates
            newTransitions <span class="fu">=</span> M.union t <span class="fu">$</span> M.fromList <span class="fu">$</span> filter ((<span class="fu">/=</span> <span class="dt">Zero</span>) <span class="fu">.</span> snd) allD
            newQueue       <span class="fu">=</span> S.toList <span class="fu">$</span> S.difference derivedStates s</code></pre></div>
<h2 id="práce-s-automatem">Práce s automatem</h2>
<p>Když má automat přejít pod nějakým znakem z jednoho stavu do dalšího, podíváme se do tabulky a pokud je přechod nedefinovaný, interpretujeme to jako přechod do stavu <code>Zero</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">transition ::</span> <span class="dt">FiniteAutomaton</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Node</span>
transition fa q a <span class="fu">=</span> fromMaybe <span class="dt">Zero</span> <span class="fu">$</span> M.lookup (q,a) (transitions fa)</code></pre></div>
<p>Pro spuštění automatu nad nějakým slovem tedy začneme v počátečním stavu a postupně automat krmíme znaky ze vstupu. Nakonec stačí zkontrolovat, jestli jsme došli do akceptujícího stavu.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runFA ::</span> <span class="dt">FiniteAutomaton</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
runFA fa str <span class="fu">=</span> isAccepting fa <span class="fu">$</span> foldl&#39; (transition fa) (startNode fa) str</code></pre></div>
<p>Teď už můžeme zabalit vytváření automatu do jediné funkce.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">strToFA ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">FiniteAutomaton</span>
strToFA str <span class="fu">=</span>  toFA (getAlphabet str) <span class="fu">$</span> fromString str
  <span class="kw">where</span>
    getAlphabet <span class="fu">=</span> filter (<span class="ot">`notElem`</span> <span class="st">&quot;()*+&quot;</span>)</code></pre></div>
<p>Pomocí této funkce můžeme vytvořit jednoduchý operátor, který porovná řetězec s regulárním výrazem <span class="math inline"><em>E</em></span> a zjistí, jestli dané slovo patří do <span class="math inline"><em>L</em>(<em>E</em>)</span>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(=~) ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
str <span class="fu">=~</span> regex <span class="fu">=</span> runFA (strToFA regex) str</code></pre></div>
<p>Nalezení všech odpovídajících podřetězců je maličko složitější. Postupně spustíme automat na všechny sufixy řetězce a zapamatujeme si, kde jsme došli do akceptujícího stavu. Zároveň ale zastavíme, když dorazíme do stavu <code>Zero</code>, protože z něj už není úniku.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">allMatches ::</span> <span class="dt">RE</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)]
allMatches re str <span class="fu">=</span> concatMap (uncurry <span class="fu">$</span> run <span class="dv">1</span> (startNode fa)) starts
  <span class="kw">where</span>
    fa <span class="fu">=</span> strToFA re
    starts <span class="fu">=</span> zip [<span class="dv">0</span><span class="fu">..</span>] (tails str)

    run _ _    _ []        <span class="fu">=</span> []
    run _ <span class="dt">Zero</span> _ _         <span class="fu">=</span> []
    run end q start (a<span class="fu">:</span>as) <span class="fu">=</span> <span class="kw">let</span> newQ <span class="fu">=</span> transition fa q a
                             <span class="kw">in</span> <span class="kw">if</span> isAccepting fa newQ
                                    <span class="kw">then</span> (start, end) <span class="fu">:</span> run (end <span class="fu">+</span> <span class="dv">1</span>) newQ start as
                                    <span class="kw">else</span>                run (end <span class="fu">+</span> <span class="dv">1</span>) newQ start as</code></pre></div>
<h2 id="další-úpravy">Další úpravy</h2>
<p>V tomhle stavu program při výpočtu tráví naprostou většinu času porovnáváním regulárních výrazů. Bylo by pěkné zbavit se jich a místo nich používat pro označování stavů čísla. To už ale dělat nebudu.</p>
<figure>
<img src="/images/regex1.png" alt="tis+ti+iti" /><figcaption>tis+ti+iti</figcaption>
</figure>
<h2 id="aktualizace">Aktualizace</h2>
<dl>
<dt>2012-07-01</dt>
<dd>upraveno tak, aby <code>(E*)*</code> nevedlo k zacyklení; doplněn odkaz na původní článek
</dd>
</dl>]]></summary>
</entry>
<entry>
    <title>Rychlost prohledávání adresáře</title>
    <link href="https://lubomir.github.io/cs/2012-01-24-prochazeni-adresare.html" />
    <id>https://lubomir.github.io/cs/2012-01-24-prochazeni-adresare.html</id>
    <published>2012-01-24T00:00:00Z</published>
    <updated>2016-01-06T19:52:56Z</updated>
    <summary type="html"><![CDATA[<p>Procházení všech souborů v adresáři je velice často se objevující potřeba. Navíc je v takovém případě obvykle potřeba rozlišit, jestli nalezená položka je soubor, adresář nebo ještě něco jiného. Je řada možností, jak tohle provést. Zkusil jsem porovnat, jak moc se časově liší různé varianty programu, který projde všechny položky adresáře a nejdříve vypíše soubory, potom adresáře.</p>
<h2 id="hřiště">Hřiště</h2>
<p>Použil jsem tři různé testovací adresáře. Jeden obsahoval jenom soubory, a to třicet tisíc, druhý obsahoval třicet tisíc adresářů a třetí po patnácti tisících od obojího. Počty v třetím případe nejsou naprosto přesné, adresářů tam může být o něco méně. Způsobené je to tím, že názvy jsou generovány skoro náhodně, aby se zajistilo náhodné pořadí.</p>
<p>Vygenerovat to jde dvěma jednoduchými cykly v Bashi.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">for</span> <span class="kw">i</span> in <span class="ot">$(</span><span class="kw">seq</span> 1 30000<span class="ot">)</span><span class="kw">;</span> <span class="kw">do</span>
    <span class="kw">touch</span> bench1/file-<span class="ot">$i</span>
    <span class="kw">mkdir</span> bench2/dir-<span class="ot">$i</span>
<span class="kw">done</span>

<span class="kw">for</span> <span class="kw">i</span> in <span class="ot">$(</span><span class="kw">seq</span> 1 15000<span class="ot">)</span><span class="kw">;</span> <span class="kw">do</span>
    <span class="kw">touch</span> bench3/<span class="ot">$(</span><span class="kw">mkpasswd</span> <span class="st">&quot;file-</span><span class="ot">$i</span><span class="st">&quot;</span> <span class="kw">|</span> <span class="kw">sed</span> <span class="st">&quot;s@/@_@g&quot;</span><span class="ot">)</span>
    <span class="kw">mkdir</span> bench3/<span class="ot">$(</span><span class="kw">mkpasswd</span> <span class="st">&quot;dir-</span><span class="ot">$i</span><span class="st">&quot;</span> <span class="kw">|</span> <span class="kw">sed</span> <span class="st">&quot;s@/@_@g&quot;</span><span class="ot">)</span>
<span class="kw">done</span></code></pre></div>
<h2 id="metody">Metody</h2>
<p>První rozdíl v testovaných programech spočíval v tom, jak se zajistí, aby soubory byly vypsané dříve než adresáře. Nejjednodušší přístup spočívá v tom, že se adresář projde dvakrát, v prvním průchodu se ignorují adresáře, v druhém soubory.</p>
<p>Druhá a třetí metoda adresář procházejí jenom jednou a nalezené adresáře si pro pozdější zpracování ukládají buď do pole nebo spojového seznamu. Pole je po naplnění vždycky potřeba zvětšit, pokud se ale jeho velikost vždycky zdvojnásobí, složitost uložení nakonec vyjde konstantní. Každý uložený řetězec je taky potřeba naalokovat. Spojový seznam má sice taky konstantní složitost přidání prvku, ovšem vyžaduje na rozdíl od pole dvě alokace paměti.</p>
<p>Druhý rozdíl v testovaných programech spočívá v metodě určování typu položky. Použil jsem zase tři možnosti: pomocí funkce <code>stat()</code>, pomocí položky <code>d_type</code> ve struktuře <code>dirent</code> a pomocí lehce uhozené heuristiky s <code>opendir()</code>.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> is_dir(<span class="dt">const</span> <span class="dt">char</span> *path)
{
    <span class="kw">struct</span> DIR *dir = opendir(path);
    <span class="kw">if</span> (dir == NULL) {
        <span class="kw">return</span> <span class="dv">0</span>;
    } <span class="kw">else</span> {
        closedir(dir);
        <span class="kw">return</span> <span class="dv">1</span>;
    }
}</code></pre></div>
<p>Tato heuristika má ovšem zásadní problém v tom, že i adresáře, které se nepodařilo otevřít třeba kvůli oprávněním, nahlásí jako soubory.</p>
<p>Rozpoznávání pomocí <code>d_type</code> je nejjednodušší, ale opět má nevýhody:</p>
<ul>
<li>nemusí existovat (pozná se podle makra <code>_DIRENT_HAVE_D_TYPE</code>)</li>
<li>i když existuje, může (v závislosti na souborovém systému) obsahovat hodnotu <code>DT_UNKNOWN</code> a tedy je potřeba se s tím vyrovnat</li>
</ul>
<h2 id="výsledky">Výsledky</h2>
<p>Každý z devíti programů jsem spustil stokrát a výsledné časy zprůměroval. Metodika nic moc, ale nějaká představa se z toho udělat dá.</p>
<table>
<tr>
<th>
</th>
<th>
Soubory
</th>
<th>
Adresáře
</th>
<th>
Mix
</th>
</tr>
<tr>
<th>
dvojitý průchod
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
<tr>
<td>
<code>stat()</code>
</td>
<td>
0,109
</td>
<td>
0,106
</td>
<td>
0.107
</td>
</tr>
<tr>
<td>
<code>opendir()</code>
</td>
<td>
0,133
</td>
<td>
0,177
</td>
<td>
0.155
</td>
</tr>
<tr>
<td>
<code>d_type</code>
</td>
<td>
0,043
</td>
<td>
0,040
</td>
<td>
0.042
</td>
</tr>
<tr>
<th>
Pole
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
<tr>
<td>
<code>stat()</code>
</td>
<td>
0,054
</td>
<td>
0,057
</td>
<td>
0.053
</td>
</tr>
<tr>
<td>
<code>opendir()</code>
</td>
<td>
0,067
</td>
<td>
0,091
</td>
<td>
0.080
</td>
</tr>
<tr>
<td>
<code>d_type</code>
</td>
<td>
0,021
</td>
<td>
0,021
</td>
<td>
0.020
</td>
</tr>
<tr>
<th>
Seznam
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
<tr>
<td>
<code>stat()</code>
</td>
<td>
0,053
</td>
<td>
0,060
</td>
<td>
0.058
</td>
</tr>
<tr>
<td>
<code>opendir()</code>
</td>
<td>
0,065
</td>
<td>
0,091
</td>
<td>
0.081
</td>
</tr>
<tr>
<td>
<code>d_type</code>
</td>
<td>
0,020
</td>
<td>
0,029
</td>
<td>
0.022
</td>
</tr>
</table>
<p>Ponaučení na závěr? Na metodě procházení příliš nezáleží. To, co se s nalezenými položkami bude dít, pravděpodobně zabere výrazně víc času, takže jinou metodou procházení se nedá nic ušetřit.</p>
<p>Všechny <a href="/data/benchmark-dir.tar.bz2">zdrojové soubory</a> je možné si stáhnout včetně měřících skriptů. Skript <code>prepare.sh</code> vytvoří testovací složky, <code>measure.sh</code> spustí měření a <code>test.sh</code> ověřuje, že všechny programy dávají stejný výstup na třetím testovacím adresáři.</p>]]></summary>
</entry>
<entry>
    <title>O princezně, která ztrácela pamět</title>
    <link href="https://lubomir.github.io/cs/2011-11-10-o-princezne.html" />
    <id>https://lubomir.github.io/cs/2011-11-10-o-princezne.html</id>
    <published>2011-11-10T00:00:00Z</published>
    <updated>2016-01-06T19:52:56Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>Tento text vznikl v rámci přemětu VB000 Základy odborného stylu jako esej na téma <em>Bylo nebylo – informatická pohádka</em></p>
</blockquote>
<p>Za devatero kompilátory a devatero linkery bylo jedno malé, ale krásné království. V tomto království vládl moudrý král. Spravedlivě přiděloval paměť všem poddaným procesům, blahosklonně uzavíral pozapomenuté otevřené soubory a když některý z jeho poddaných dokončil svůj výpočet a přešel do stavu zombie, pečlivě sesbíral veškerou jeho paměť. Pod jeho vládou nebyl v celém království jediný neadresovatelný bajt.</p>
<p>Jedna věc ale dělala králi starosti: jeho jediná dcera, princezna a dědička systému. Byla to sice holka jako lusk, se sofistikovanou architekturou a intuitivním uživatelským rozhraním, na princeznu měla ale jednu zásadní vadu. Každý den si od krále vyžádala nový blok paměti, žádných se ale nikdy nevzdávala. A tak přestože před jejím spuštěním království nikdy netrpělo nouzí, s jejím rozmarným chováním se začaly denní příděly paměti všem poddaným snižovat.</p>
<p>Jednoho pochmurného dne se tedy stalo to, čeho se všichni obávali: v celém království nezbyl jediný volný bajt. Král svolal všechny své rádce, vyložil jim tuto nepříjemnou situaci a očekával návrhy řešení. „Budeme se modlit k velkému Uživateli, aby nám seslal další paměťový modul,“ navrhl některý z rádců. „To je výborný nápad, my ale potřebujeme něco rychlejšího a spolehlivějšího,“ oponoval jiný. Najednou se vzadu ozval králův věrný pobočník Oom: „Vaše Kernelovosti, máme jedinou možnost. Musíme princeznu zabít, paměť jí vzít a nakonec její proces znovu spustíme.“ Králi se toto řešení nelíbilo, přece jen svou dceru miloval, ale nakonec i on uznal, že je to jediné řešení.</p>
<p>Přestože se privilegovaným procesům takto podařilo krizi zažehnat, celá smutná situace se brzy začala opakovat. Král tedy pátral po trvalejším řešení a pozval optimalizátory a analyzátory z celého repozitáře. Aby je nějak motivoval, dal rozhlásit, že kdo napraví princeznu, dostane ji za ženu a půl pevného disku k tomu. Programy se stahovaly z celého Internetu, ať se ale snažily sebevíc, přivést princeznu k rozumu se jim nepodařilo.</p>
<p>Za pár dní v království nastalo pozdvižení. Na hranicích se objevil věhlasný mudrc ze vzdáleného Javistánu. Doprovázela ho početná kolekce objektů. Ve spojovém seznamu si vedl neznámé nástroje a jeho sluhové nesli obrovský binární strom z ezoterických jazyků. Všechny procesy v království do mudrce vkládaly velké naděje. Když ale mudrc přišel k princezně, ukázalo se, že ani pro něj nebude ladění jednoduché. První komplikace nastala, když se pokusil prozkoumat princezniny objekty a metody. Jeho obvyklé postupy selhaly! Princezna totiž nebyla objektová, ale procedurální!</p>
<p>Mudrc byl v úzkých. Postupy, na které byl navyklý, vůbec nezabíraly a s manuální správou paměti si také příliš nerozuměl. Ze své domoviny byl totiž navyklý, že se kolem něj neustále motá sluha a paměť po něm uklízí. I tento světoznámý mudrc tedy nakonec odjel s nepořízenou.</p>
<p>Král z toho byl zničený. Už se těšil, že bude mít, co se správy paměti týká, normální dceru, ale ladění se zase nepodařilo. Když se král vzpamatoval ze zklamání, rozzuřeně prohlásil: „Už žádné šarlatány. Kdo od teď neuspěje v ladění princezny, bude o zásobník kratší a jeho zdrojové kódy budou smazány.“</p>
<p>Zhruba ve stejné době se o nadělení s princeznou dozvěděl chytrý Valgrind. Byl to skromný chlapec, kterého sousedé považovali za trochu jednoduššího, především kvůli jeho textovému rozhraní. Ve skrytu haldy ale věděli, že k práci s pamětí má Valgrind talent. A tak si Valgrind řekl: „Už příliš dlouho se válím v rodném /usr/bin. Žádné přerušení mě tady z nudy nevytrhne, půjdu zkusit svoje štěstí.“ Sbalil si svoje kladivo Callgrind a sekeru Cachegrind a vyrazil.</p>
<p>Jenom se podíval na princeznu, už věděl, která bije. Vždyť ta holka churavá vůbec nepoužívá funkci free(). I když Valgrind věděl, jak na princezniny potíže, nemohl na ni jít zhurta. Nejprve si jenom navzájem posílali signály, ale když král zjistil, že už si naalokovali sdílený blok paměti, bylo jasné, že krize je zažehnána a v království zase nastala hojnost paměti.</p>
<p>Zakrátko se Valgrind s princeznou vzali a jestli dosud nespadli, tak spolu profilují dodnes.</p>]]></summary>
</entry>
<entry>
    <title>Kódování čísel</title>
    <link href="https://lubomir.github.io/cs/2011-06-06-kodovani-cisel.html" />
    <id>https://lubomir.github.io/cs/2011-06-06-kodovani-cisel.html</id>
    <published>2011-06-06T00:00:00Z</published>
    <updated>2016-06-26T13:24:29Z</updated>
    <summary type="html"><![CDATA[<p>V předmětu <a href="http://is.muni.cz/predmety/predmet.pl?id=585364">IB047</a> se dá mimo jiné potkat s problémem, jak co nejúsporněji uložit data do souboru. Jako ideální řešení se ukáže použít nějaké vhodné kódování. A protože nejlépe člověk něco pochopí tak, že si to vyzkouší, napsal jsem si funkce pro kódování i dekódování různými metodami.</p>
<h2 id="varianty">Varianty</h2>
<p>První myslitelné kódování je klasický zápis čísla ve dvojkové soustavě. Jeho výhoda je velká úspornost, na druhou stranu každá posloupnost nul a jedniček se dá interpretovat jako číslo. My bychom ale chtěli poznat, kde jedno číslo končí a druhé začíná. Proto potřebujeme <em>bezprefixový</em> kód, tedy takový, aby žádné slovo nebylo prefixem jiného. Zároveň ale nechceme používat žádnou překladovou tabulku, takže <a href="http://cs.wikipedia.org/wiki/Huffmanovo_kódování">Huffmanovo kódování</a> je ze hry.</p>
<p>Nejjednodušší variantou, jak toho dosáhnout, je použít <em>unární</em> kódování. Číslo <span class="math inline"><em>n</em></span> zakóduje pomocí <span class="math inline"><em>n</em></span> nul následovaných jedničkou. Zřejmě je tedy bezprefixové, ale zároveň i paměťově neefektivní, protože délka kódu je lineární k velikosti kódovaného čísla.</p>
<p>Jako lepší nápad vypadá zapsání čísla binárně a přidání jeho délky pomocí nějakého bezprefixového kódu. To ale také není optimální, protože bychom nevyužili mnoho možností. Konkrétně jde o slova, která začínají nulami. V klasickém dvojkovém zápisu jsou čísla 00 a 0 stejná. Z našeho pohledu je ale užitečné je rozlišit. Proto pro každou délku kódu využijeme všechny možnosti, tedy pro slovem délky jedna budeme kódovat dvě čísla, délkou dvě čtyři atd.</p>
<p>Pro každé číslo tedy určíme délku slova, odečteme od něj nějakou hodnotu a převedeme do dvojkové soustavy. Délku určíme jako <span class="math inline">⌊log<sub>2<sub></sub></sub>(<em>n</em> + 1)⌋</span>. Zároveň z délky můžeme určit, o kolik zmenšit kódované číslo před převodem: <span class="math inline">2<sup><em>l</em></sup> − 1</span>.</p>
<h2 id="implementace">Implementace</h2>
<p>Nejdříve tedy definice typů.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Bit</span> <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">|</span> <span class="dt">One</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>)

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Bit</span> <span class="kw">where</span>
    show <span class="dt">Zero</span> <span class="fu">=</span> <span class="st">&quot;0&quot;</span>
    show <span class="dt">One</span>  <span class="fu">=</span> <span class="st">&quot;1&quot;</span>

<span class="kw">type</span> <span class="dt">Stream</span> <span class="fu">=</span> [<span class="dt">Bit</span>]</code></pre></div>
<p>Typy požadovaných funkcí vypadají následovně. Kódovací funkce pro číslo vrátí posloupnost bitů, dekódovací naopak z proudy bitů vytáhnou první číslo a vrátí ho společně se zbytkem proudu. Funkce <code>fromBinary</code> se liší v tom, že zpracuje celý proud.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">unary, binary, gamma,<span class="ot"> delta        ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span>
parseUnary, parseGamma,<span class="ot"> parseDelta ::</span> <span class="dt">Stream</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Stream</span>)
<span class="ot">fromBinary ::</span> <span class="dt">Stream</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre></div>
<p>Unární kódování je velice jednoduché. Operátor <code>(***) :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; (a, c) -&gt; (b, d)</code> se nachází v modulu <code>Control.Arrow</code> a jeho jediný účel je aplikace funkcí na složky dvojice.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">unary n    <span class="fu">=</span> replicate n <span class="dt">Zero</span> <span class="fu">++</span> [<span class="dt">One</span>]
parseUnary <span class="fu">=</span> (length <span class="fu">***</span> tail) <span class="fu">.</span> span (<span class="fu">==</span> <span class="dt">Zero</span>)</code></pre></div>
<p>Funkce pro binární kódování čísla jsou trošku složitější, ale pořád tam není žádná magie. Provádí klasický přepis čísla do dvojkové soustavy. Pomocná funkce <code>binary'</code> navíc výsledný kód doplní zleva do požadované délky nulami. Také 0 při délce kódu 0 reprezentuje prázdným seznamem.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">binary <span class="fu">=</span> bin []
  <span class="kw">where</span>
    bin acc <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">:</span> acc
    bin acc <span class="dv">1</span> <span class="fu">=</span> <span class="dt">One</span>  <span class="fu">:</span> acc
    bin acc n <span class="fu">=</span> bin ((<span class="kw">if</span> odd n <span class="kw">then</span> <span class="dt">One</span> <span class="kw">else</span> <span class="dt">Zero</span>) <span class="fu">:</span> acc) (n <span class="ot">`div`</span> <span class="dv">2</span>)

<span class="ot">binary&#39; ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span>
binary&#39; <span class="dv">0</span> <span class="dv">0</span> <span class="fu">=</span> []
binary&#39; len n <span class="fu">=</span> padding <span class="fu">++</span> code
  <span class="kw">where</span> code <span class="fu">=</span> binary n
        padding <span class="fu">=</span> replicate (len <span class="fu">-</span> length code) <span class="dt">Zero</span>

fromBinary <span class="fu">=</span> foldl (\num x <span class="ot">-&gt;</span> num <span class="fu">*</span> <span class="dv">2</span> <span class="fu">+</span> (<span class="kw">if</span> x <span class="fu">==</span> <span class="dt">Zero</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> <span class="dv">1</span>)) <span class="dv">0</span></code></pre></div>
<p>Myšlenku popsanou na začátku realizují mimo jiné <span class="math inline"><em>γ</em></span> a <span class="math inline"><em>δ</em></span> kódy. <span class="math inline"><em>γ</em></span>-kód pro délku slova používá unární kódování, <span class="math inline"><em>δ</em></span>-kód jde ještě dál a používá pro zapsání délky <span class="math inline"><em>γ</em></span>-kód. Zřejmě jsou si tedy v mnohém podobná a má smysl nejdřív napsat obecnější funkci.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">encodeWith ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span>
encodeWith f n <span class="fu">=</span> f len <span class="fu">++</span> binary&#39; len (n <span class="fu">-</span> <span class="dv">2</span><span class="fu">^</span>len <span class="fu">+</span> <span class="dv">1</span>)
  <span class="kw">where</span> len <span class="fu">=</span> floor <span class="fu">.</span> logBase <span class="dv">2</span> <span class="fu">.</span> fromIntegral <span class="fu">$</span> n <span class="fu">+</span> <span class="dv">1</span>

<span class="ot">parseWith ::</span> (<span class="dt">Stream</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Stream</span>)) <span class="ot">-&gt;</span> <span class="dt">Stream</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Stream</span>)
parseWith f s <span class="fu">=</span> (fromBinary bin <span class="fu">+</span> <span class="dv">2</span><span class="fu">^</span>len <span class="fu">-</span> <span class="dv">1</span>, ss)
  <span class="kw">where</span> (len, rest) <span class="fu">=</span> f s
        (bin, ss)   <span class="fu">=</span> splitAt len rest</code></pre></div>
<p>S funkcemi <code>encodeWith</code>, <code>parseWith</code> je tedy implementace <span class="math inline"><em>γ</em></span> i <span class="math inline"><em>δ</em></span> kódování poměrně triviální.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gamma <span class="fu">=</span> encodeWith unary
parseGamma <span class="fu">=</span> parseWith parseUnary

delta <span class="fu">=</span> encodeWith gamma
parseDelta <span class="fu">=</span> parseWith parseGamma</code></pre></div>
<p>Odtud už je jednoduché napsat funkci, které bude kódovat nebo dekódovat seznam čísel.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">encode ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span>) <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Stream</span>
encode <span class="fu">=</span> concatMap

<span class="ot">decode ::</span> (<span class="dt">Stream</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Stream</span>)) <span class="ot">-&gt;</span> <span class="dt">Stream</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
decode f s <span class="fu">=</span> <span class="kw">let</span> (n, ss) <span class="fu">=</span> f s
             <span class="kw">in</span> <span class="kw">case</span> ss <span class="kw">of</span>
                  [] <span class="ot">-&gt;</span> [n]
                  _  <span class="ot">-&gt;</span> n <span class="fu">:</span> decode f ss</code></pre></div>
<p><strong>Upozornění</strong>: toto není úplně ideální implementace, protože umožňuje práci pouze s čísly omezené velikosti, navíc jsem se nesnažil o efektivitu, takže je to velice pomalé. Taky chybí jakákoli kontrola chyb.</p>]]></summary>
</entry>
<entry>
    <title>XMonad a okna s pevnou velikostí</title>
    <link href="https://lubomir.github.io/cs/2011-04-04-xmonad-a-okna-s-pevnou-velikosti.html" />
    <id>https://lubomir.github.io/cs/2011-04-04-xmonad-a-okna-s-pevnou-velikosti.html</id>
    <published>2011-04-04T00:00:00Z</published>
    <updated>2016-01-06T19:52:56Z</updated>
    <summary type="html"><![CDATA[<p>Už docela dlouho k téměř úplné spokojenosti používám XMonad jako správce oken. Sice má své mouchy, ale přednosti to dostatečně vyvažují. Navíc se i ty mouchy dají odstranit.</p>
<p>Poslední věc, na kterou jsem narazil a která mě donutila upravit <code>xmonad.hs</code> bylo ne zrovna přátelské chování k oknům, která si nastavují nějakou požadovanou velikost. XMonad tyto rady totiž totálně ignoruje. Ve většině případů je to docela žádoucí chování, jediná výjimka jsou okna, u kterých nemá moc smysl měnit velikost. V mém případě šlo hlavně o <a href="http://www.frozen-bubble.org/">Frozen Bubble</a> a <a href="http://www.dosbox.com/">dosbox</a>.</p>
<p>Jedna možnost řešení by bylo vyjmenovat dotyčné aplikace a přímo oknům nastavit režim floating. To se mi ale nelíbilo, protože by to nebylo ani pohodlné, ani spolehlivé, a často bych musel měnit konfiguraci.</p>
<p>Společným znakem oken, která mají fixní velikost, je nastavení minimální a maximální velikosti okna na stejnou hodnotu. Toto nastavení je v <code>WM_NORMAL_HINTS</code> a dá se zjistit třeba přes <code>xprop</code>. Toto pole má typ <code>XSizeHints</code> a nejpřesnější popis, který jsem našel, vypadá takto:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="kw">struct</span> {
    long flags;                <span class="co">/* marks which fields in this</span>
<span class="co">                                  structure are defined */</span>
    int x, y;                  <span class="co">/* Obsolete */</span>
    int width, height;         <span class="co">/* Obsolete */</span>
    int min_width, min_height;
    int max_width, max_height;
    int width_inc, height_inc;
    struct {
           <span class="dt">int</span> x;              <span class="co">/* numerator */</span>
           <span class="dt">int</span> y;              <span class="co">/* denominator */</span>
    } min_aspect, max_aspect;
    int base_width, base_height;
    int win_gravity;
    <span class="co">/* this structure may be extended in the future */</span>
} XSizeHints;</code></pre></div>
<p>To jistě není žádný zázrak, ale už se s tím dá něco dělat. Zajímavé hodnoty jsou ty s prefixem <code>min_</code> a <code>max_</code>. Pokud jsou nastavené na jinou hodnotu než 0 a zároveň se rovnají odpovídající si hodnoty, okno má zřejmě nastavenou fixní velikost.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isFixed ::</span> [<span class="dt">CLong</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isFixed h <span class="fu">=</span> minWidth h <span class="fu">==</span> maxWidth h
         <span class="fu">&amp;&amp;</span> minHeight h <span class="fu">==</span> maxHeight h
         <span class="fu">&amp;&amp;</span> all (<span class="fu">&gt;</span><span class="dv">0</span>) [minWidth h, maxWidth h, minHeight h, maxHeight h]</code></pre></div>
<p>V modulu <code>XMonad.Util.WindowProperties</code> je k dispozici funkce <code>getProp32s :: String -&gt; Window -&gt; X (Maybe [CLong])</code>, s jejíž pomocí už se dá napsat potřebná funkce pro manage hook. Definice typu <code>CLong</code> je v modulu <code>Foreign.C.Types</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isNonResizable ::</span> <span class="dt">Query</span> <span class="dt">Bool</span>
isNonResizable <span class="fu">=</span> ask <span class="fu">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> liftX <span class="fu">$</span> <span class="kw">do</span>
    atom <span class="ot">&lt;-</span> getProp32s <span class="st">&quot;WM_NORMAL_HINTS&quot;</span> w
    return <span class="fu">$</span> <span class="kw">case</span> atom <span class="kw">of</span>
        <span class="dt">Just</span> hints  <span class="ot">-&gt;</span> hasFixedSize hints
        <span class="dt">Nothing</span>     <span class="ot">-&gt;</span> <span class="dt">False</span></code></pre></div>
<p>Poslední chybějící kus jsou funkce na vrácení požadovaných rozměrů. Vlastně jde jenom o čitelnější zápisy vytažení příslušné hodnoty ze seznamu:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">minWidth  <span class="fu">=</span> (<span class="fu">!!</span> <span class="dv">5</span>)<span class="ot"> ::</span> [<span class="dt">CLong</span>] <span class="ot">-&gt;</span> <span class="dt">CLong</span>
minHeight <span class="fu">=</span> (<span class="fu">!!</span> <span class="dv">6</span>)<span class="ot"> ::</span> [<span class="dt">CLong</span>] <span class="ot">-&gt;</span> <span class="dt">CLong</span>
maxWidth  <span class="fu">=</span> (<span class="fu">!!</span> <span class="dv">7</span>)<span class="ot"> ::</span> [<span class="dt">CLong</span>] <span class="ot">-&gt;</span> <span class="dt">CLong</span>
maxHeight <span class="fu">=</span> (<span class="fu">!!</span> <span class="dv">8</span>)<span class="ot"> ::</span> [<span class="dt">CLong</span>] <span class="ot">-&gt;</span> <span class="dt">CLong</span></code></pre></div>
<p>A to je asi tak všechno. Zatím mám pocit, že to funguje, žádné chyby jsem nepozoroval. <a href="/data/HandleFixedWindows.hs">Kompletní soubor</a> stačí nakopírovat do <code>~/.xmonad/lib/</code>, naimportovat do konfiguračního souboru a použít.</p>]]></summary>
</entry>
<entry>
    <title>Znásilňování SICStus Prologu</title>
    <link href="https://lubomir.github.io/cs/2011-02-26-znasilnovani-sicstus-prologu.html" />
    <id>https://lubomir.github.io/cs/2011-02-26-znasilnovani-sicstus-prologu.html</id>
    <published>2011-02-26T00:00:00Z</published>
    <updated>2016-06-26T13:24:29Z</updated>
    <summary type="html"><![CDATA[<h2 id="použití">Použití</h2>
<p>Při instalaci se do adresáře <code>$PREFIX/bin</code> mimo jiné nainstaluje spustitelný soubor <code>sicstus</code>, což je přímo interpret. Tu stačí spustit a jsem skoro tam, kde jsme chtěli být.</p>
<p>To slovíčko „skoro“ je poměrně důležité. Interpret sice běží, ale zdaleka se nechová tak, aby se dal pohodlně používat. Například kurzor se nedá posunout šipkami doprostřed psaného dotazu a opravit překlep, po ukončení zůstane nezalomený řádek a posunutý prompt, nikde žádná historie dotazů …</p>
<p>Naštěstí to není nezvratný stav. Stačí nainstalovat utilitu <a href="http://utopia.knoware.nl/~hlub/rlwrap/">rlwrap</a> třeba ze standardních repozitářů a potom spouštět <code>rlwrap sicsus</code>. Výsledkem je stejný interpret, ale tentokrát se všemi výhodami knihovny readline, jako třeba funkční šipky nebo historie ukládaná do <code>~/.sicstus_history</code>, ve které se dá interaktivně vyhledávat přes <code>^R</code> nebo jenom šipkou nahoru/dolů. Možná to má někde nějaký háček, ale zatím jsem na nic nepřišel.</p>
<h3 id="někdo-to-rád-barevné">Někdo to rád barevné</h3>
<p>Rlwrap umožňuje pomocí přepínače <code>-p</code> (nebo <code>--promp-colour</code>) obarvit výzvu programu. Menší problém je ale v tom, že za prompt považuje i řádky, kde se vypisuje víc možných unifikací a interpret čeká na středník kvůli další možnosti. Osobně bych preferoval obarvení pouze klasické výzvy <code>| ?-</code> a podobných, které začínají znakem <code>|</code>.</p>
<p>Naštěstí si tohle přání můžu splnit pomocí filtru. Stačí si uložit <a href="/data/prolog_filter">tento filtr</a> ideálně do adresáře <code>/usr/share/rlwrap/filters</code> a potom spouštět pomocí <code>rlwrap -z 'prolog_filter Blue' sicstus</code>. Možnosti barev jsou <code>black</code>, <code>red</code>, <code>green</code>, <code>yellow</code>, <code>blue</code>, <code>purple</code>, <code>cyan</code> a <code>white</code>. Pokud je alespoň první písmeno velké, použije se tučná varianta.</p>
<h4 id="aktualizace-16.3.2011">Aktualizace 16. 3. 2011</h4>
<p>Existuje i výrazně jednodušší řešení. Rlwrap umožňuje přepínači nastavit, které výzvy má „vařit“. Je to přepínač <code>-O regexp</code>, kde potřebný regulární výraz je <code>'^\|'</code>. Potom stačí použít klasicky <code>-pBARVA</code> (stejný výčet jako je výše) a už to funguje.</p>
<p>Taky se může hodit přidat přepínač <code>-g '^.$'</code>, což zakáže ukládání jednopísmenných odpovědí do historie.</p>
<h2 id="vim">Vim</h2>
<p>Vim sám o sobě Prolog moc nepodporuje. Nakopírováním těch <a href="https://github.com/adimit/prolog.vim">správných souborů</a> do <code>~/.vim/</code> se ale změní do celkem použitelné formy: sympaticky zvýrazňuje syntaxi, automaticky odsazuje řádky a sám pozná, kde začínají a končí foldy.</p>
<p>Poslední drobný zádrhel je v tom, že si většinou splete typ souboru s Perlem, který taky používá příponu <code>.pl</code>. Dá se to obejít přidáním modeline na konec souboru:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"><span class="co">% vim: ft=prolog</span></code></pre></div>]]></summary>
</entry>
<entry>
    <title>CPO a spojité funkce</title>
    <link href="https://lubomir.github.io/cs/2011-01-24-cpo-a-spojite-funkce.html" />
    <id>https://lubomir.github.io/cs/2011-01-24-cpo-a-spojite-funkce.html</id>
    <published>2011-01-24T00:00:00Z</published>
    <updated>2016-01-06T19:52:56Z</updated>
    <summary type="html"><![CDATA[<p>Každý typ se dá charakterizovat jako částečně uspořádaná množina hodnot. Pokud platí, že každý spočetný řetězec má supremum, potom se jedná o <a href="http://en.wikipedia.org/wiki/Complete_partial_order">Complete Partial Order</a>.</p>
<h2 id="primitivní-typy----příklady">Primitivní typy -- příklady</h2>
<figure>
<img src="/images/unitt.png" alt="Unit⊥" /><figcaption>Unit<sub>⊥</sub></figcaption>
</figure>
<figure>
<img src="/images/boolt.png" alt="Bool⊥" /><figcaption>Bool<sub>⊥</sub></figcaption>
</figure>
<p>Značky <code>tt</code> a <code>ff</code> jsou jednoduše symboly pro pravdivou a nepravdivou hodnotu. Další primitivní typ je třeba typ všech celých čísel <code>Int</code>.</p>
<h2 id="operace-nad-typy">Operace nad typy</h2>
<p>Z primitivních typů je možné pomocí operací vytvářet další, bohatší typy.</p>
<dl>
<dt>Lift X</dt>
<dd>přidá ⊥ jako nejméně definovaný prvek do typu X. Dno (⊥) je menší než všechny původní prvky v X a jinak se touto operací uspořádání nemění.
</dd>
<dt>X × Y</dt>
<dd>kartézský součin dvou typů (typ všech dvojic, kde první složka je typu X a druhá složka má typ Y). Pokud <span class="math inline"><em>x</em><sub>1</sub>, <em>x</em><sub>2</sub> ∈ <em>X</em>, <em>x</em><sub>1</sub> ≤ <em>x</em><sub>2</sub></span> a <span class="math inline"><em>y</em><sub>1</sub>, <em>y</em><sub>2</sub> ∈ <em>Y</em>, <em>y</em><sub>1</sub> ≤ <em>y</em><sub>2</sub></span>, potom platí <span class="math inline">(<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>)≤(<em>x</em><sub>2</sub>, <em>y</em><sub>2</sub>)</span>. <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>
</dd>
<dt>X + Y</dt>
<dd>disjunktní sjednocení, hodnota tohoto typu obsahuje buď nějakou hodnotu typu X, nebo hodnotu typu Y (např. takto funguje <code>union</code> v C nebo <code>Either</code> v Haskellu)
</dd>
<dt>X → Y</dt>
<dd>mocninný typ; typ všech spojitých funkcí, které hodnotu typu X zobrazí na hodnotu typu Y
</dd>
</dl>
<p>Další příklady jsou ve slidech z přednášky na straně 167.</p>
<figure>
<img src="/images/bool-x-bool.png" alt="Bool⊥ × Bool⊥" /><figcaption>Bool<sub>⊥</sub> × Bool<sub>⊥</sub></figcaption>
</figure>
<h2 id="spojitost-funkce">Spojitost funkce</h2>
<blockquote>
<p>Funkce <span class="math inline"><em>f</em></span> je monotonní právě tehdy, když platí <span class="math inline">∀<em>a</em>, <em>b</em> : <em>a</em> ≤ <em>b</em> ⇒ <em>f</em>(<em>a</em>)≤<em>f</em>(<em>b</em>)</span>.</p>
</blockquote>
<p>Tedy: funkce <span class="math inline"><em>f</em></span> je monotonní, pokud pro každé dva prvky jejího definičního oboru platí, že pokud je jeden méně definovaný než jiný, tak potom jejich obrazy na tom budou stejně.</p>
<p>Takže například funkce <span class="math inline"><em>f</em></span> je monotonní, ale funkce <span class="math inline"><em>g</em></span> monotonní není.</p>
<pre><code>f () = True
f ⊥ = True

g () = True
g ⊥ = False</code></pre>
<p>Spojitost funkce je ještě trochu silnější pojem. Každá spojitá funkce je i monotonní. Obrácené tvrzení neplatí, existují i nespojité monotonní funkce. Platí ale, že každá monotonní funkce s konečným definičním oborem (doménou) je spojitá<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>.</p>
<blockquote>
<p>Funkce <span class="math inline"><em>f</em></span> je spojitá, pokud pro každý spočetný řetězec <span class="math inline"><em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, …</span> platí <span class="math inline"><em>f</em>(⨆(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, …)) = ⨆(<em>f</em>(<em>x</em><sub>1</sub>),<em>f</em>(<em>x</em><sub>2</sub>),…)</span></p>
</blockquote>
<p>(Značka <span class="math inline">⨆</span> značí supremum, nejmenší horní závoru, least upper bound. Horní závora nějaké podmnožiny je prvek, který je větší než libovolný prvek dané podmnožiny.)</p>
<p>Definice tedy říká, že obraz suprema libovolného řetězce musí být supremem obrazů jednotlivých prvků řetězce.</p>
<p>Česky: pokud se vezme libovolný spočetný řetězec a funkcí <span class="math inline"><em>f</em></span> zobrazíme jeho supremum, tak musíme dostat totéž, jako kdybychom postupně zobrazili všechny prvky daného řetězce a našli supremum obrazů.</p>
<h2 id="všechny-unit-bool">Všechny Unit<sub>⊥</sub> → Bool<sub>⊥</sub></h2>
<p>Zadání: Napište všechny spojité funkce typu Unit<sub>⊥</sub> → Bool<sub>⊥</sub>. Co je to funkce s tímto typem? Takováto funkce musí každé hodnotě z Unit<sub>⊥</sub> přiřadit něco z Bool<sub>⊥</sub>.</p>
<figure>
<img src="/images/unit-bool2.png" alt="Všechny funkce Unit⊥ → Bool⊥" /><figcaption>Všechny funkce Unit<sub>⊥</sub> → Bool<sub>⊥</sub></figcaption>
</figure>
<p>Tyto funkce by bylo vhodné taky seřadit do diagramu, aby bylo patrné, jak to uspořádání na nich funguje. Pro jednoduchost je každou funkci možné zakreslit jako diagram ve tvaru definičního oboru, kde se místo původních prvků na stejná místa doplní hodnota, na kterou se ten který prvek zobrazí.</p>
<figure>
<img src="/images/unit-bool.png" alt="Uspořádání na Unit⊥ → Bool⊥" /><figcaption>Uspořádání na Unit<sub>⊥</sub> → Bool<sub>⊥</sub></figcaption>
</figure>
<p>Pro jiný typ funkcí to může dopadnout třeba tak, jako na obrázku níž.</p>
<figure>
<img src="/images/bool-bool.png" alt="Bool⊥ → Bool⊥" /><figcaption>Bool<sub>⊥</sub> → Bool<sub>⊥</sub></figcaption>
</figure>
<h2 id="striktní-funkce">Striktní funkce</h2>
<p>Striktní funkce je taková funkce, která nejdříve vyhodnotí svůj argument a potom s ním teprve něco počítá. Pokud je tedy argument nedefinovaný, nemůže být definovaný ani výsledek výpočtu. Pro striktní funkci tedy platí <strong>f ⊥ = ⊥</strong>.</p>
<h2 id="odkazy">Odkazy</h2>
<ol type="1">
<li><a href="http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/">Hussling Haskell types into Hasse diagrams</a></li>
<li><a href="http://blog.ezyang.com/2010/12/gin-and-monotonic/">Gin and monotonic</a></li>
<li><a href="http://blog.ezyang.com/2010/12/getting-a-fix-on-fixpoints/">Getting a fix on fixpoints</a></li>
</ol>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>drobný detail: pokaždé se jedná o jiné <span class="math inline">≤</span>, protože se porovnává v jiné doméně<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>takže pro naprostou většinu příkladů na zkoušce PB006 stačí ověřovat monotonicitu<a href="#fnref2">↩</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>Poznámky k IB107</title>
    <link href="https://lubomir.github.io/cs/2011-01-02-poznamky-k-ib107.html" />
    <id>https://lubomir.github.io/cs/2011-01-02-poznamky-k-ib107.html</id>
    <published>2011-01-02T00:00:00Z</published>
    <updated>2016-01-06T19:52:56Z</updated>
    <summary type="html"><![CDATA[<h2 id="věta-o-numeraci">Věta o numeraci</h2>
<blockquote>
<p>Pro každé <span class="math inline"><em>j</em> ≥ 1</span> existuje vyčíslitelná funkce <span class="math inline"><em>Φ</em> : <em>N</em><sup><em>j</em> + 1</sup> → <em>N</em></span>, která je univerzální pro standardní numeraci j-árních funkcí. Tedy pro každé <span class="math inline"><em>e</em> ∈ <em>N</em></span> a <span class="math inline">(<em>a</em><sub>1</sub>, …<em>a</em><sub><em>j</em></sub>)∈<em>N</em><sup><em>j</em></sup></span> platí <img src="/images/veta-o-numeraci.png" alt="Věta o numeraci" /></p>
</blockquote>
<p>Pro každou aritu tedy existuje funkce <span class="math inline"><em>Φ</em></span>, která bere o jeden argument víc -- potřebuje ještě index programu, který má simulovat. Důkaz věty spočívá v definici interpretu -- programu, který bude simulovat jiné programy.</p>
<h2 id="věta-o-parametrizaci">Věta o parametrizaci</h2>
<blockquote>
<p>Ke každému <span class="math inline"><em>n</em> ≥ 1</span>, <span class="math inline"><em>m</em> ≥ 1</span> existuje totálně vyčíslitelná funkce <span class="math inline"><em>s</em><sup><em>m</em></sup><sub><em>n</em></sub> : <em>N</em><sup><em>m</em> + 1</sup> → <em>N</em></span>, taková, že platí <img src="/images/veta-o-parametrizaci.png" alt="Věta o parametrizaci" /></p>
</blockquote>
<p>Takže: existuje funkce <span class="math inline"><em>s</em></span>, která pro index programu <span class="math inline"><em>i</em></span> a <span class="math inline"><em>m</em></span> jeho argumentů spočítá index jiného programu, který bude dělat totéž co <span class="math inline"><em>i</em></span>, ale bude potřebovat o <span class="math inline"><em>m</em></span> argumentů méně. Funkce <span class="math inline"><em>s</em></span> vlastně zafixuje prvních <span class="math inline"><em>m</em></span> argumentů na nějaké konstanty. <span class="math inline"><em>m</em></span> je tady počet fixovaných parametrů, <span class="math inline"><em>n</em></span> počet těch, které se nefixují.</p>
<p>Dokazuje se pomocí programu, který celou konstrukci realizuje -- má <span class="math inline"><em>m</em></span> konstant a přesypává argumenty tak, aby to sedělo. Prvních <span class="math inline"><em>n</em></span> argumentů posune o <span class="math inline"><em>m</em></span> pozic doprava a na uvolněná místa dosadí konstanty. Pozor, aby se při posunování nepřepsalo něco, co bude ještě potřeba.</p>
<h2 id="první-riceova-věta">První Riceova věta</h2>
<blockquote>
<p>Nechť <span class="math inline"><em>I</em> ⊂ <em>N</em></span> je netriviální (není prázdná ani se nerovná <span class="math inline"><em>N</em></span>) a rekurzivní. Potom existují indexy programů <span class="math inline"><em>i</em> ∈ <em>I</em></span> a <span class="math inline"><em>j</em> ∈ <em>I</em>′</span><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> tak, že <span class="math inline"><em>ϕ</em><sub><em>i</em></sub> = <em>ϕ</em><sub><em>j</em></sub></span>.</p>
</blockquote>
<p>Tedy pokud je netriviální podmnožina <span class="math inline"><em>N</em></span> rekurzivní, potom nerespektuje funkce a naopak pokud nějaká množina respektuje funkce a je netriviální, potom nemůže být rekurzivní.</p>
<p>Důkaz se provede sporem: předpokládejme, že množina respektuje funkce a že množina <span class="math inline"><em>I</em></span> obsahuje index nějaké vyčíslitelné funkce<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> <span class="math inline"><em>θ</em></span>, která není prázdná. <span class="math inline"><em>I</em>′</span> potom obsahuje indexy prázdné funkce. Kdyby tomu tak nebylo, tak se prohodí <span class="math inline"><em>I</em></span> a <span class="math inline"><em>I</em>′</span>.</p>
<p>Nechť <span class="math inline"><em>P</em><sub><em>f</em>(<em>i</em>)</sub></span> je program <code>begin</code> <span class="math inline"><em>x</em><sub>2</sub></span> <code>:=</code> <span class="math inline"><em>Φ</em>(<em>i</em>, <em>i</em>)</span><code>;</code> <span class="math inline"><em>x</em><sub>1</sub></span> <code>:=</code> <span class="math inline"><em>θ</em>(<em>x</em><sub>1</sub>)</span> <code>end</code>. Zřejmě program <span class="math inline"><em>P</em></span> počítá funkci <span class="math inline"><em>θ</em></span>, pokud <span class="math inline"><em>ϕ</em><sub><em>i</em></sub>(<em>i</em>)</span> je definované a jinak počítá prázdnou funkci.</p>
<p>Tedy pro všechna <span class="math inline"><em>i</em> ∈ <em>N</em></span> platí <span class="math inline"><em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub> = <em>θ</em></span> právě tehdy když <span class="math inline"><em>i</em> ∈ <em>K</em></span>.</p>
<p>Pokud tedy <span class="math inline"><em>f</em>(<em>i</em>)∈<em>I</em></span>, pak <span class="math inline"><em>f</em>(<em>i</em>)</span> není index prázdné funkce. Je to index <span class="math inline"><em>θ</em></span>. Obráceně pokud <span class="math inline"><em>f</em>(<em>i</em>)</span> je indexem funkce <span class="math inline"><em>θ</em></span>, pak <span class="math inline"><em>f</em>(<em>i</em>)∈<em>I</em></span>. Nechť <span class="math inline"><em>χ</em><sub><em>I</em></sub></span> je charakteristická funkce <span class="math inline"><em>I</em></span>. Pro všechna <span class="math inline"><em>i</em> ∈ <em>N</em></span> musí platit <img src="/images/prvni-riceova-veta-tvrzeni.png" alt="Tvrzení 1" /></p>
<p>Protože <span class="math inline"><em>χ</em><sub><em>I</em></sub> ∘ <em>f</em></span> je totálně vyčíslitelná, musela by <span class="math inline"><em>K</em></span> být rekurzivní, což zřejmě není.</p>
<h2 id="druhá-riceova-věta">Druhá Riceova věta</h2>
<blockquote>
<p>Necht <span class="math inline"><em>I</em> ⊂ <em>N</em></span> respektuje funkce a nechť existuje funkce <span class="math inline"><em>θ</em></span> taková, že všechny její indexy jsou v <span class="math inline"><em>I</em></span> a má vyčíslitelné rozšíření <span class="math inline"><em>θ</em>′</span> takové, že jeho indexy patří do <span class="math inline"><em>I</em>′</span>.</p>
<p><span class="math inline"><em>I</em></span> potom není rekurzivně spočetná.</p>
</blockquote>
<p>Důkaz půjde zase sporem. Nechť funkce <span class="math inline"><em>ξ</em>(<em>i</em>, <em>j</em>)</span> se rovná <span class="math inline"><em>θ</em>′(<em>j</em>)</span>, pokud <span class="math inline"><em>ϕ</em><sub><em>i</em></sub>(<em>i</em>)</span> je definováno a jinak se rovná <span class="math inline"><em>θ</em>(<em>j</em>)</span>. Tato funkce je vyčíslitelná<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>. Podle <a href="#věta-o-parametrizaci">věty o parametrizaci</a> existuje totálně vyčíslitelná funkce <span class="math inline"><em>f</em> : <em>N</em> → <em>N</em></span> taková, že <span class="math inline"><em>ξ</em>(<em>i</em>, <em>j</em>)=<em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub>(<em>j</em>)</span>. <span class="math inline"><em>f</em>(<em>i</em>)</span> potom patří do <span class="math inline"><em>I</em></span> právě tehdy, když <span class="math inline"><em>ϕ</em><sub><em>i</em></sub>(<em>i</em>)</span> není definováno. Tj. <span class="math inline"><em>f</em>(<em>i</em>)∈<em>I</em> ≡ <em>i</em> ∈ <em>K</em>′</span>.</p>
<p>Pokud by tedy <span class="math inline"><em>I</em></span> byla rekurzivně spočetná, tak i <span class="math inline"><em>K</em>′</span> by musela být rekurzivně spočetná. To ale není.</p>
<p>Při použití druhé Riceovy věty je tedy zřejmě potřeba zvolit <span class="math inline"><em>θ</em></span> tak, aby nebyla totální. Jinak by totiž neměla potřebné rozšíření.</p>
<h2 id="třetí-riceova-věta">Třetí Riceova věta</h2>
<blockquote>
<p>Nechť <span class="math inline"><em>I</em> ⊂ <em>N</em></span> respektuje funkce a nechť existuje funkce <span class="math inline"><em>θ</em></span> taková, že všechny její indexy patří do <span class="math inline"><em>I</em></span> a navíc všechna její konečná zúžení patří do <span class="math inline"><em>I</em>′</span>.</p>
<p><span class="math inline"><em>I</em></span> potom není rekurzivně spočetná.</p>
</blockquote>
<p>Důkaz se opět provede sporem. Nechť funkce <span class="math inline"><em>μ</em>(<em>i</em>, <em>j</em>)</span> počítá <span class="math inline"><em>θ</em>(<em>j</em>)</span>, pokud <span class="math inline"><em>P</em><sub><em>i</em></sub></span> nezastaví pro vstup <span class="math inline"><em>i</em></span> během nejvýše <span class="math inline"><em>j</em></span> kroků. Pokud zastaví během nejvýše <span class="math inline"><em>j</em></span> kroků, <span class="math inline"><em>μ</em></span> se zacyklí. Funkce <span class="math inline"><em>μ</em></span> je zřejmě vyčíslitelná.</p>
<p>Podle <a href="#věta-o-parametrizaci">věty o parametrizaci</a> existuje totálně vyčíslitelná funkce <span class="math inline"><em>f</em></span> tak, že <span class="math inline"><em>μ</em>(<em>i</em>, <em>j</em>)=<em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub>(<em>j</em>)</span>.</p>
<p>Dostaneme tedy, že pokud <span class="math inline"><em>i</em> ∈ <em>K</em></span>, tak <span class="math inline"><em>P</em><sub><em>i</em></sub></span> zastaví pro <span class="math inline"><em>i</em></span>. Tedy existuje <span class="math inline"><em>j</em></span> takové, že <span class="math inline"><em>P</em><sub><em>i</em></sub></span> zastaví pro <span class="math inline"><em>i</em></span> po <strong>přesně</strong> <span class="math inline"><em>j</em></span> krocích. Tj. existuje <span class="math inline"><em>j</em></span> takové, že <span class="math inline"><em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub>(<em>x</em>)</span> počítá <span class="math inline"><em>θ</em>(<em>x</em>)</span> pro všechna <span class="math inline"><em>x</em></span> menší než <span class="math inline"><em>j</em></span> a jinak je nedefinované. Potom ale <span class="math inline"><em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub></span> je zúžením <span class="math inline"><em>θ</em></span> a její definiční obor je konečný, tedy <span class="math inline"><em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub> ∈ <em>I</em>′</span>.</p>
<p>Z druhé strany platí, že když <span class="math inline"><em>i</em> ∈ <em>K</em>′</span>, tak <span class="math inline"><em>P</em><sub><em>i</em></sub></span> nikdy nezastaví a <span class="math inline"><em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub></span> počítá celou <span class="math inline"><em>θ</em></span> a tedy patří do <span class="math inline"><em>I</em></span>.</p>
<p>Tedy <span class="math inline"><em>i</em> ∈ <em>K</em>′≡<em>f</em>(<em>i</em>)∈<em>I</em></span> a <span class="math inline"><em>I</em></span> nemůže být rekurzivně spočetná.</p>
<p>Třetí Riceovu větu tedy zřejmě nejde použít, pokud <span class="math inline"><em>I</em></span> obsahuje prázdnou funkci. Ta je totiž konečným zúžením každé funkce.</p>
<h2 id="časová-složitost">Časová složitost</h2>
<h3 id="f-in-og"><span class="math inline"><em>f</em> ∈ <em>O</em>(<em>g</em>)</span></h3>
<p>Funkce <span class="math inline"><em>f</em></span> roste nejvýše tak rychle jako <span class="math inline"><em>g</em></span>.</p>
<blockquote>
<p><span class="math inline">∃<em>c</em>, <em>n</em><sub>0</sub> : ∀<em>n</em> ≥ <em>n</em><sub>0</sub> : <em>f</em>(<em>n</em>)≤<em>c</em><em>g</em>(<em>n</em>)</span></p>
</blockquote>
<h3 id="f-in-og-1"><span class="math inline"><em>f</em> ∈ <em>o</em>(<em>g</em>)</span></h3>
<p>Funkce <span class="math inline"><em>f</em></span> roste pomaleji než <span class="math inline"><em>g</em></span></p>
<figure>
<img src="/images/f-in-og.png" title="\lim{n \to \infty}\frac{f(n)}{g(n)} = 0" alt="" />
</figure>
<h3 id="f-in-omegag"><span class="math inline"><em>f</em> ∈ <em>Ω</em>(<em>g</em>)</span></h3>
<p>Funkce <span class="math inline"><em>f</em></span> roste alespoň tak rychle jako <span class="math inline"><em>g</em></span></p>
<figure>
<img src="/images/f-in-Omega-g.png" title="\exists n_0, c: \forall n \geq n_0 : f(n) \geq \frac{1}{c} g(n)" alt="" />
</figure>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>apostrofem označím doplněk množiny<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>a tedy všechny její indexy<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Nejdřív se začne paralelně (pomocí step counteru) počítat <span class="math inline"><em>θ</em>(<em>j</em>)</span> a <span class="math inline"><em>ϕ</em><sub><em>i</em></sub>(<em>i</em>)</span>. Pokud první skončí <span class="math inline"><em>θ</em>(<em>j</em>)</span>, vrátí se její výsledek. Pokud by první skončil výpočet <span class="math inline"><em>ϕ</em><sub><em>i</em></sub>(<em>i</em>)</span>, začne se přímo simulovat <span class="math inline"><em>θ</em>′(<em>j</em>)</span>.<a href="#fnref3">↩</a></p></li>
</ol>
</section>]]></summary>
</entry>

</feed>
