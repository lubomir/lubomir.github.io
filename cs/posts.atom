<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>lsedlar</title>
    <link href="http://lubomir.github.io//cs/posts.atom" rel="self" />
    <link href="http://lubomir.github.io/" />
    <id>http://lubomir.github.io//cs/posts.atom</id>
    <author>
        <name>Lubomír Sedlář</name>
        <email>lubomir.sedlar@gmail.com</email>
    </author>
    <updated>2013-04-25T00:00:00Z</updated>
    <entry>
    <title>Popisná statistika v R</title>
    <link href="http://lubomir.github.io//cs/2013-04-25-statistika-v-r.html" />
    <id>http://lubomir.github.io//cs/2013-04-25-statistika-v-r.html</id>
    <published>2013-04-25T00:00:00Z</published>
    <updated>2013-04-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Tento text je výcuc z mých poznatků, které jsem nabyl při vypracování projektu do jistého matematického předmětu.</p>
<h2 id="načítání-dat-a-první-průzkum">Načítání dat a první průzkum</h2>
<p>V první řadě je potřeba načíst soubor s daty. Za předpokladu, že máme data ve formátu CSV, se nám bude hodit příkaz <code>read.csv</code> (jak nečekané…). Taky by bylo dobré zjistit, jak vlastně data vypadají, tedy jaké jsou názvy atributů a jak vypadá prvních pár záznamů.</p>
<pre class="R"><code>&gt; data &lt;- read.csv(&quot;nazev_souboru.csv&quot;)
&gt; names(data)
...
&gt; head(data)
...</code></pre>
<p>Jednotlivé atributy je potom možné adresovat přes notaci se znakem <code>$</code>, tedy třeba <code>data$atr1</code>. Funkce <code>nrow(data)</code> nám prozradí, kolik je v datovém rámci záznamů.</p>
<p>Pro kvalitativní atributy se hodí výpis hodnot s příslušnou četností. To se dá udělat pomocí funkce <code>table</code>. Pokud bychom chtěli relativní četnosti, stačí celou tabulku podělit počtem řádků.</p>
<pre class="R"><code>&gt; table(data$class)

   1    2
 700  300
&gt; table(data$class) / nrow(data)

  1   2
0.7 0.3</code></pre>
<p>Pro atributy s větším počtem hodnot než jenom dvě je možné vygenerovat tabulku kumulativních relativních četností pomocí funkce <code>cumsum()</code>.</p>
<p>Pro vizualizaci kvalitativních atributů se hodí např. sloupkový diagram, který je možné vytvořit pomocí funkce <code>barplot</code> aplikované na tabulku četností (třeba i kumulativních). Jiná možnost je polygon četností – funkce <code>plot</code>, jejíž první argument je tabulka, kterou chceme vizualizovat. Polygon četností navíc vyžaduje argument <code>type=&quot;b&quot;</code>, tedy typ grafu <em>both</em>, což znamená puntíky spojené čarami.</p>
<pre class="R"><code>&gt; barplot(table(data$class))
&gt; plot(table(data$at7), type=&quot;b&quot;)</code></pre>
<p>Další užitečné atributy pro grafy jsou:</p>
<dl>
<dt><code>main</code></dt>
<dd>hlavní titulek umístěný nad grafem <code>xlab</code>, <code>ylab</code>
</dd>
<dd>popisek osy x, resp. osy y <code>col</code>
</dd>
<dd>vektor barev použitý pro graf, případně jedna barva jako řetězec, význam se zřejmě liší pro jednotlivé typy grafu; např. <code>col=c(&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;)</code> <code>pch</code>
</dd>
<dd>typ puntíku <code>cex</code>
</dd>
<dd>velikost vykreslovaných puntíků
</dd>
</dl>
<h2 id="kontingenční-tabulky">Kontingenční tabulky</h2>
<p>Závislosti mezi jednotlivými atributy je možné zkoumat třeba pomocí kontingenční tabulky. Tu opět produkuje funkce <code>table</code>, tentokrát se dvěma argumenty. První argument (a tedy datová sada) určuje řádky, druhý argument jsou sloupce.</p>
<p>Z této tabulky je možné dopočítat kontingenční tabulku řádkově (nebo sloupcově) podmíněných četností. Nenašel jsem k tomu ale vestavěnou funkci, takže to bude vyžadovat trochu černé magie.</p>
<p>Pro řádkově podmíněné četnosti stačí každou hodnotu v kontingenční tabulce absolutních četností podělit součtem hodnot na příslušném řádku. Součty po řádcích je možné vyprodukovat pomocí funkce <code>rowSums</code>. Tabulky potom stačí podělit.</p>
<pre class="R"><code>&gt; table(atribut1, atribut2) / rowSums(table(atribut1, atribut2))</code></pre>
<p>Se sloupcově podmíněnými četnosti je to trochu horší. Existuje funkce <code>colSums</code>, která spočítá sumy přes sloupce, jednoduché dělení jako v předchozím případě ale nebude fungovat, protože tabulky si nebudou rozměrově správně odpovídat. Řešením je využít funkci s lakonickým názvem <code>t</code>, která transponuje svůj jediný argument.</p>
<pre class="R"><code>&gt; tab &lt;- table(atribut1, atribut2)
&gt; t(t(tab) / colSums(tab))</code></pre>
<p>Správnost výsledků se dá ověřit například pomocí dalšího volání <code>rowSums</code>, V tabulce řádkově podmíněných četností by měla být suma na každém řádku rovna 1, obdobně pro sloupce pro sloupcově podmíněné četnosti.</p>
<h2 id="generování-histogramů">Generování histogramů</h2>
<p>Základní histogram se dá udělat pomocí funkce <code>hist</code>. Bez nějakých dalších argumentů ale vytvoří nehezkou obludu. Hlavní kámen úrazu této funkce je nastavování počtu intervalů. Pomocí argumenty <code>breaks</code> je sice možné zadat číslo nebo název metody, ale je to jenom doporučení a funkce se tím nemusí přesně řídit. Navíc výchozí nastavení vygeneruje nepříliš přehlednou osu <span class="math"><em>x</em></span>, ze které se těžko odečítají hranice intervalů.</p>
<p>Nicméně můžeme tady využít možnosti definice vlastních funkcí a napsat vlastní vykreslování histogramů. Tato funkce bude očekávat data ve stejném formátu jako standardní <code>hist</code>, počet intervalů, a volitelný popisek osy <span class="math"><em>x</em></span>.</p>
<pre class="R"><code>myhist &lt;- function(data, num_bins, lab=&#39;data&#39;) {
    # Spočítáme šířku intervalu s přesností na jedno desetinné místo
    width &lt;- round((max(data) - min(data)) / num_bins, digits=1)
    # Uděláme vektor bodů, kde začínají a končí intervaly
    breaks &lt;- seq(min(data), min(data) + num_bins * width, by=width)
    # Pro jistotu vypíšeme šířku intervalu na výstup
    cat(&#39;Bin width = &#39;, width, &#39;\n&#39;)

    # Nastavíme okraje
    par(mar=c(6, 4, 1, 2))
    hist(data, breaks=breaks,
        xaxt=&#39;n&#39;,               # Nechceme osu X
        xlab=&#39;&#39;,                # Ani její popisek
        main=&#39;&#39;,                # I hlavní titulek vynecháme
        col=&#39;lightblue&#39;,        # Barva výplně sloupců
        border=&#39;blue&#39;,          # Barva rámečku sloupců
        ylab=&#39;Absolutní četnost&#39;)
    # Přidáme vlastní osu
    axis(1,                     # Kreslíme osu X
        at=breaks,              # Chceme značky na hranicích intervalů
        las=2)                  # Test bude vertikálně, aby se to tam vešlo
    # Vykreslíme popisek pod osou
    mtext(lab, side=1, line=4)  # Číslo u line udává, jak daleko bude text od
                                # grafu

    # Volitelně bychom mohli ještě do rohu přidat informaci o šířce intervalu
    leg &lt;- paste(&#39;Šířka intervalu&#39;, format(width))
    legend(&#39;topright&#39;, leg, box.lty=0)
}</code></pre>
<p>Jako argumenty <code>col</code> a <code>border</code> funkce <code>hist</code> by bylo možné zadat i vektory barev, kdybychom to chtěli oživit. Nechceme.</p>
<p>Velikost fontu se dá ovlivnit parametrem <code>cex</code>. Je potřeba ho zadat u <code>par</code> a <code>mtext</code>.</p>
<figure>
<img src="/images/r-histogram.png" alt="Ukázka vytvořeného histogramu" /><figcaption>Ukázka vytvořeného histogramu</figcaption>
</figure>
<h2 id="korelace-a-regresní-přímka">Korelace a regresní přímka</h2>
<p>Když už máme dva numerické atributy, můžeme mezi nimi hledat hledat nějaké vztahy. Korelační koeficienty se dají počítat funkcí <code>cor(atribut1, atribut2, method=&quot;pearson&quot;)</code>. Další dostupné metody jsou <code>spearman</code> a <code>kendall</code>.</p>
<p>Vypočítat koeficienty regresní přímky lze pomocí funkce <code>lm</code>. Vykreslení do grafu potom provede funkce <code>abline</code> aplikovaná na to, co vrátí <code>lm</code>.</p>
<pre class="R"><code>&gt; lm(loans ~ ages)
...
Coefficients:
(Intercept)         ages
   2982.684        8.118
&gt; abline(lm(loans ~ ages))</code></pre>
<p>Před samotným vykreslením přímky je možné si nachystat třeba tečkový diagram atributů, jejichž závislost hledáme.</p>
<pre class="R"><code>&gt; plot(ages,        # Co bude na ose X
       loans)       # Co bude na ose Y</code></pre>
<h2 id="ukládání-do-souborů">Ukládání do souborů</h2>
<p>Uložení vytvořeného grafu do souboru je vlastně naprosto triviální. Před voláním vykreslovacích funkcí je potřeba přesměrovat výstup do požadovaného souboru pomocí funkce, jejíž název určí formát výstupu a jediný argument název výstupního souboru. Dostupné jsou minimálně <code>pdf</code> a <code>png</code>. Až je dokresleno, zavolání <code>dev.off()</code> zase přesměruje výstup na obrazovku.</p>
<h2 id="další-užitečné-funkce">Další užitečné funkce</h2>
<ul>
<li>Funkce <code>source</code> jako argument očekává jméno souboru a chová se jako stejnojmenný příkaz v Bashi.</li>
<li>Zaokrouhlení hodnot na určitý počet desetinných míst se dá provést pomocí <code>round(x, digits=N)</code>, kde <code>x</code> může být číslo nebo klidně i tabulka.</li>
<li>Pokud před název funkce napíšeme otazník, dostaneme poměrně podrobnou nápovědu. Např. <code>?table</code>.</li>
</ul>
<h2 id="odkazy">Odkazy</h2>
<ul>
<li><a href="http://www.r-tutor.com/elementary-statistics">Pěkný úvod do popisné statistiky v R</a></li>
</ul>]]></summary>
</entry>
<entry>
    <title>Zpracování PDF</title>
    <link href="http://lubomir.github.io//cs/2013-04-02-zpracovani-pdf.html" />
    <id>http://lubomir.github.io//cs/2013-04-02-zpracovani-pdf.html</id>
    <published>2013-04-02T00:00:00Z</published>
    <updated>2013-04-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Občas se mi dostane do rukou naskenovaná knížka ve formátu PDF, kde jsou vždy dvě stránky původního textu na jedné virtuální stránce. Člověk se potom musí posouvat nejen směrem dolů, ale i do stran a občas nahoru. Hlavně na mobilu nic moc.</p>
<p>Nakonec jsem našel relativně spolehlivý způsob, jak takový monolit rozporcovat na menší kousky, a abych to nezapomněl, tak si to poznamenám.</p>
<p>Budeme potřebovat <a href="http://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/">pdftk</a>, <a href="http://www.imagemagick.org/script/index.php">imagemagick</a> a <a href="http://poppler.freedesktop.org/">poppler-utils</a>. V Debianu je všechno nachystané v repozitářích.</p>
<h2 id="nasekat-na-jemno-prosím">Nasekat na jemno, prosím</h2>
<p>Nejdřív původní soubor nasekáme na jednotlivé stránky. Následující příkaz vytvoří z každé stránky v původním pdf jeden soubor.</p>
<pre class="bash"><code>$ pdftk VSTUPNI.PDF burst</code></pre>
<p>Tímto vznikne plus minus autobus milion souborů s názvy <code>pg_0001.pdf</code>.</p>
<h2 id="protřepat-nemíchat">Protřepat, nemíchat</h2>
<p>Následující krok by měl každý vytvořený soubor vertikálně rozpůlit. K tomu se dá použít třeba programů z balíku <code>poppler-utils</code>. Abychom se s tím zbytečně nepárali, vezmeme to všechno naráz.</p>
<pre class="bash"><code>for i in pg_*pdf; do
    pdftoppm $i &gt;${i/pdf/ppm}
    convert $(i/pdf/ppm} -crop 50%x100% +repage vystup-$i
done</code></pre>
<p>Jakkoli děsivě ta substituce vypadá, dělá jen jednu věc: nahradí příponu <code>pdf</code> příponou <code>ppm</code>. Následující příkaz z balíku <code>imagemagick</code> potom akorát obrázek rozsekne napůl (tady se dá pohrát s konkrétním číslem) a výsledek uloží jako dvoustránkové PDF do souboru <code>vystup-pg_0001.pdf</code>.</p>
<h2 id="matláma-patláma-paprčála">Matláma patláma paprčála</h2>
<p>Teď už stačí znovu použít <code>pdftk</code> a všechno to zase nakombinovat do jednoho souboru.</p>
<pre class="bash"><code>$ pdftk vystup-* cat output spojeny.pdf</code></pre>
<p>Zjevně není nutné vytvářet pouze jeden monolit, ale jde to rozdělit do souborů třeba po kapitolách. Taky je snadné vyhodit nezajímavé stránky.</p>
<h2 id="optimalizace-velikosti">Optimalizace velikosti</h2>
<p>Popis výš má zásadní problém: vytvořený soubor má rozměry slona po obědě. Možnou odtučňovací kůrou je třeba <code>ghostscript</code>.</p>
<pre class="bash"><code>$ gs -dCompatibilityLevel=1.4 -dPDFSETTINGS=/screen -dNOPAUSE \
&gt; -dBATCH -sDEVICE=pdfwrite -sOutputFile=output.pdf spojeny.pdf</code></pre>
<p>Tím se každá stránka přepočítá na plus minus 72 což je dost pro monitor. Na tisk už to ale stačit nebude. Další možnosti jsou <code>/ebook</code>, <code>/printer</code>, <code>/prepress</code>.</p>]]></summary>
</entry>
<entry>
    <title>Derivací k regulárním výrazům</title>
    <link href="http://lubomir.github.io//cs/2012-03-20-derivaci-k-regularnim-vyrazum.html" />
    <id>http://lubomir.github.io//cs/2012-03-20-derivaci-k-regularnim-vyrazum.html</id>
    <published>2012-03-20T00:00:00Z</published>
    <updated>2012-03-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>V předmětu <a href="http://www.fi.muni.cz/~sojka/PV030/">PV030</a> se člověk mimo jiné potká s algoritmy pro práci s regulárními výrazy. Jedním z nich je i metoda konverze regulárního výrazu na konečný automat, a ne nedeterministický s <span class="math"><em>ϵ</em></span>-kroky. Touto metodou je možné rovnou vyrobit minimální deterministický konečný automat. A jak lépe porozumět algoritmu než si ho zkusit naprogramovat?</p>
<p>Podrobnější popis je algoritmu je k dispozici <a href="http://www.fi.muni.cz/~sojka/PV030/2012-03-15.pdf">ve slidech</a>, případně ve článku <a href="http://dl.acm.org/citation.cfm?id=321249"><em>Derivatives of Regular Expressions</em></a>, jehož autorem je <em>Janusz A. Brzozowski</em>.</p>
<figure>
<img src="/images/regex0.png" alt="a^*b+(c+d+e)a" /><figcaption><span class="math"><em>a</em><sup> * </sup><em>b</em> + (<em>c</em> + <em>d</em> + <em>e</em>)<em>a</em></span></figcaption>
</figure>
<h2 id="importujeme">Importujeme</h2>
<p>Budeme potřebovat importovat několik modulů, většinu z nich pro parsování výrazu.</p>
<pre class="haskell"><code>import qualified Data.Map as M
import qualified Data.Set as S
import Text.Parsec.Char
import Text.Parsec.String
import Text.Parsec.Combinator
import Text.Parsec.Prim
import Text.Parsec.Expr
import Control.Applicative ((&lt;*), (*&gt;))
import Data.Maybe (fromMaybe)
import Data.List (tails, foldl&#39;)</code></pre>
<h2 id="datové-typy">Datové typy</h2>
<p>Je potřeba nějak reprezentovat jak samotný regulární výraz, tak i výsledný automat. Regexp je možné reprezentovat jako strom. Listy jsou základní výrazy, uzly potom zřetězení, alternativa a iterace.</p>
<p>Později budeme potřebovat určovat, jestli nějaký regulární výraz popisuje (mimo jiné) prázdné slovo. Pro urychlení tedy u těch konstruktorů, kde to není zřejmé, přidáme tuto informaci.</p>
<pre class="haskell"><code>data Regex a = Epsilon
             | Zero
             | Simple a
             | Plus Bool (Regex a) (Regex a)
             | Conc Bool (Regex a) (Regex a)
             | Iter (Regex a)
             deriving (Eq, Ord, Show)</code></pre>
<p>Pro konečný automat bude potřeba další typ. Automat má nějaké přechody, množinu stavů a počáteční stav. Položka <code>isAccepting</code> je funkce, která pro stav řekne, jestli je akceptující.</p>
<pre class="haskell"><code>type Node = Regex Char  -- ^ Popisek stavu

data FiniteAutomaton = FiniteAutomaton
                     { transitions :: M.Map (Node,Char) Node
                     , states      :: S.Set Node
                     , startNode   :: Node
                     , isAccepting :: Node -&gt; Bool
                     }</code></pre>
<p>V první řadě nadefinujeme tři pomocné funkce pro spojování regexpů, které se postarají o korektní vyplnění pomocné boolovské části a taky zabrání vzniku několika patologických výrazů – např. nemá smysl řetězit něco s prázdným slovem. Jiný příklad je výraz <code>(E*)*</code>, který je ekvivalentní s <code>E*</code> (a navíc vede k zacyklení).</p>
<pre class="haskell"><code>plus :: Regex a -&gt; Regex a -&gt; Regex a
plus Zero x = x
plus x Zero = x
plus x y    = Plus (canBeEpsilon x || canBeEpsilon y) x y

conc :: Regex a -&gt; Regex a -&gt; Regex a
conc Epsilon x = x
conc x Epsilon = x
conc Zero _    = Zero
conc _ Zero    = Zero
conc x y       = Conc (canBeEpsilon x &amp;&amp; canBeEpsilon y) x y

iter :: Regex a -&gt; Regex a
iter (Iter x) = Iter x
iter x        = Iter x</code></pre>
<p>Jak jsem psal výše, musíme být schopní pro daný výraz <span class="math"><em>E</em></span> určit, jestli <span class="math"><em>L</em>(<em>E</em>)</span> obsahuje <span class="math"><em>ϵ</em></span>. Vzhledem k tomu, kolikrát se tato funkce bude volat při derivování, by bylo dobré, aby dokázala fungovat v konstantním čase.</p>
<pre class="haskell"><code>canBeEpsilon :: Regex a -&gt; Bool
canBeEpsilon Epsilon      = True
canBeEpsilon Zero         = False
canBeEpsilon (Simple _)   = False
canBeEpsilon (Conc e _ _) = e
canBeEpsilon (Plus e _ _) = e
canBeEpsilon (Iter _)     = True</code></pre>
<h2 id="parsování">Parsování</h2>
<p>A nyní hurá na parsování. <code>Parsec</code> nabízí úžasné možnosti, jak parsovat aritmetické i jiné výrazy. Jediná složitější věc je tady parser pro jednotlivý znak, protože umožňuje využít zpětného lomítka k escapování znaků hvězdičky, plusu a závorek, které by jinak měly speciální význam.</p>
<pre class="haskell"><code>regexP, termP, simpleP :: Parser (Regex Char)
regexP = buildExpressionParser table termP
termP = simpleP &lt;|&gt; char &#39;(&#39; *&gt; regexP &lt;* char &#39;)&#39;
table = [ [ Postfix $ char &#39;*&#39; &gt;&gt; return iter ]
        , [Infix (return conc) AssocLeft]
        , [Infix (char &#39;+&#39; &gt;&gt; return plus) AssocLeft]
        ]
simpleP = do
    c&#39; &lt;- noneOf &quot;()+*&quot;
    c &lt;- if c&#39; == &#39;\\&#39;
            then anyChar
            else return c&#39;
    return (Simple c)</code></pre>
<p>Parser <code>regexP</code> teď můžeme obalit pomocnou funkcí.</p>
<pre class="haskell"><code>fromString :: String -&gt; Regex Char
fromString str = case parse (regexP &lt;* eof) &quot;&quot; str of
    Left _  -&gt; Zero
    Right r -&gt; r</code></pre>
<h2 id="derivace">Derivace</h2>
<p>Funkce pro derivaci regulárních výrazů je skoro doslovným přepisem definice ze <a href="http://www.fi.muni.cz/~sojka/PV030/2012-03-15.pdf">slidů</a>.</p>
<pre class="haskell"><code>derive :: Eq a =&gt; Regex a -&gt; a -&gt; Regex a
derive Zero    _      = Zero
derive Epsilon _      = Zero
derive (Simple x) y
    | x == y          = Epsilon
    | otherwise       = Zero
derive (Plus _ p q) x = plus (derive p x) (derive q x)
derive (Conc _ p q) x
    | canBeEpsilon p  = plus (conc (derive p x) q) (derive q x)
    | otherwise       = conc (derive p x) q
derive (Iter p) x     = conc (derive p x) (iter p)</code></pre>
<h2 id="konstrukce-automatu">Konstrukce automatu</h2>
<p>A můžeme budovat automat! Samotný algoritmus běží v cyklu <code>run</code>, v kterém postupně vytvoříme jak množinu stavů, tak tabulku přechodů.</p>
<p>V každé iteraci vezmeme všechny regulární výrazy z fronty <code>q</code> a každý zderivujeme každým písmenem abecedy. Z těchto všech derivací přidáme nové stavy a přechody mezi ty, co už jsme napočítali. Zároveň nově přidané stavy tvoří novou frontu.</p>
<p>Nemá smysl přidávat žádné hrany, které vedou do stavu odpovídajícího regexpu <code>Zero</code>, tím se jenom zbytečně zvětšuje tabulka přechodů.</p>
<pre class="haskell"><code>toFA :: String -&gt; Regex Char -&gt; FiniteAutomaton
toFA alphabet re = FiniteAutomaton { startNode = re
                                   , transitions = allTransitions
                                   , states = allStates
                                   , isAccepting = canBeEpsilon
                                   }
  where
    (allStates, allTransitions) = run (S.singleton re, M.empty) [re]

    run res []  = res
    run (s,t) q = run (newStates, newTransitions) newQueue
        where
            allD           = [ ((r,a), derive r a) | r &lt;- q, a &lt;- alphabet ]
            derivedStates  = S.fromList $ map snd allD
            newStates      = s `S.union` derivedStates
            newTransitions = M.union t $ M.fromList $ filter ((/= Zero) . snd) allD
            newQueue       = S.toList $ S.difference derivedStates s</code></pre>
<h2 id="práce-s-automatem">Práce s automatem</h2>
<p>Když má automat přejít pod nějakým znakem z jednoho stavu do dalšího, podíváme se do tabulky a pokud je přechod nedefinovaný, interpretujeme to jako přechod do stavu <code>Zero</code>.</p>
<pre class="haskell"><code>transition :: FiniteAutomaton -&gt; Node -&gt; Char -&gt; Node
transition fa q a = fromMaybe Zero $ M.lookup (q,a) (transitions fa)</code></pre>
<p>Pro spuštění automatu nad nějakým slovem tedy začneme v počátečním stavu a postupně automat krmíme znaky ze vstupu. Nakonec stačí zkontrolovat, jestli jsme došli do akceptujícího stavu.</p>
<pre class="haskell"><code>runFA :: FiniteAutomaton -&gt; String -&gt; Bool
runFA fa str = isAccepting fa $ foldl&#39; (transition fa) (startNode fa) str</code></pre>
<p>Teď už můžeme zabalit vytváření automatu do jediné funkce.</p>
<pre class="haskell"><code>strToFA :: String -&gt; FiniteAutomaton
strToFA str =  toFA (getAlphabet str) $ fromString str
  where
    getAlphabet = filter (`notElem` &quot;()*+&quot;)</code></pre>
<p>Pomocí této funkce můžeme vytvořit jednoduchý operátor, který porovná řetězec s regulárním výrazem <span class="math"><em>E</em></span> a zjistí, jestli dané slovo patří do <span class="math"><em>L</em>(<em>E</em>)</span>.</p>
<pre class="haskell"><code>(=~) :: String -&gt; String -&gt; Bool
str =~ regex = runFA (strToFA regex) str</code></pre>
<p>Nalezení všech odpovídajících podřetězců je maličko složitější. Postupně spustíme automat na všechny sufixy řetězce a zapamatujeme si, kde jsme došli do akceptujícího stavu. Zároveň ale zastavíme, když dorazíme do stavu <code>Zero</code>, protože z něj už není úniku.</p>
<pre class="haskell"><code>allMatches :: RE -&gt; String -&gt; [(Int, Int)]
allMatches re str = concatMap (uncurry $ run 1 (startNode fa)) starts
  where
    fa = strToFA re
    starts = zip [0..] (tails str)

    run _ _    _ []        = []
    run _ Zero _ _         = []
    run end q start (a:as) = let newQ = transition fa q a
                             in if isAccepting fa newQ
                                    then (start, end) : run (end + 1) newQ start as
                                    else                run (end + 1) newQ start as</code></pre>
<h2 id="další-úpravy">Další úpravy</h2>
<p>V tomhle stavu program při výpočtu tráví naprostou většinu času porovnáváním regulárních výrazů. Bylo by pěkné zbavit se jich a místo nich používat pro označování stavů čísla. To už ale dělat nebudu.</p>
<figure>
<img src="/images/regex1.png" alt="tis+ti+iti" /><figcaption>tis+ti+iti</figcaption>
</figure>
<h2 id="aktualizace">Aktualizace</h2>
<dl>
<dt>2012–07</dt>
<dd>upraveno tak, aby <code>(E*)*</code> nevedlo k zacyklení; doplněn odkaz na původní článek
</dd>
</dl>]]></summary>
</entry>
<entry>
    <title>Rychlost prohledávání adresáře</title>
    <link href="http://lubomir.github.io//cs/2012-01-24-prochazeni-adresare.html" />
    <id>http://lubomir.github.io//cs/2012-01-24-prochazeni-adresare.html</id>
    <published>2012-01-24T00:00:00Z</published>
    <updated>2012-01-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Procházení všech souborů v adresáři je velice často se objevující potřeba. Navíc je v takovém případě obvykle potřeba rozlišit, jestli nalezená položka je soubor, adresář nebo ještě něco jiného. Je řada možností, jak tohle provést. Zkusil jsem porovnat, jak moc se časově liší různé varianty programu, který projde všechny položky adresáře a nejdříve vypíše soubory, potom adresáře.</p>
<h2 id="hřiště">Hřiště</h2>
<p>Použil jsem tři různé testovací adresáře. Jeden obsahoval jenom soubory, a to třicet tisíc, druhý obsahoval třicet tisíc adresářů a třetí po patnácti tisících od obojího. Počty v třetím případe nejsou naprosto přesné, adresářů tam může být o něco méně. Způsobené je to tím, že názvy jsou generovány skoro náhodně, aby se zajistilo náhodné pořadí.</p>
<p>Vygenerovat to jde dvěma jednoduchými cykly v Bashi.</p>
<pre class="bash"><code>for i in $(seq 1 30000); do
    touch bench1/file-$i
    mkdir bench2/dir-$i
done

for i in $(seq 1 15000); do
    touch bench3/$(mkpasswd &quot;file-$i&quot; | sed &quot;s@/@_@g&quot;)
    mkdir bench3/$(mkpasswd &quot;dir-$i&quot; | sed &quot;s@/@_@g&quot;)
done</code></pre>
<h2 id="metody">Metody</h2>
<p>První rozdíl v testovaných programech spočíval v tom, jak se zajistí, aby soubory byly vypsané dříve než adresáře. Nejjednodušší přístup spočívá v tom, že se adresář projde dvakrát, v prvním průchodu se ignorují adresáře, v druhém soubory.</p>
<p>Druhá a třetí metoda adresář procházejí jenom jednou a nalezené adresáře si pro pozdější zpracování ukládají buď do pole nebo spojového seznamu. Pole je po naplnění vždycky potřeba zvětšit, pokud se ale jeho velikost vždycky zdvojnásobí, složitost uložení nakonec vyjde konstantní. Každý uložený řetězec je taky potřeba naalokovat. Spojový seznam má sice taky konstantní složitost přidání prvku, ovšem vyžaduje na rozdíl od pole dvě alokace paměti.</p>
<p>Druhý rozdíl v testovaných programech spočívá v metodě určování typu položky. Použil jsem zase tři možnosti: pomocí funkce <code>stat()</code>, pomocí položky <code>d_type</code> ve struktuře <code>dirent</code> a pomocí lehce uhozené heuristiky s <code>opendir()</code>.</p>
<pre class="c"><code>int is_dir(const char *path)
{
    struct DIR *dir = opendir(path);
    if (dir == NULL) {
        return 0;
    } else {
        closedir(dir);
        return 1;
    }
}</code></pre>
<p>Tato heuristika má ovšem zásadní problém v tom, že i adresáře, které se nepodařilo otevřít třeba kvůli oprávněním, nahlásí jako soubory.</p>
<p>Rozpoznávání pomocí <code>d_type</code> je nejjednodušší, ale opět má nevýhody:</p>
<ul>
<li>nemusí existovat (pozná se podle makra <code>_DIRENT_HAVE_D_TYPE</code></li>
<li>i když existuje, může (v závislosti na souborovém systému) obsahovat hodnotu <code>DT_UNKNOWN</code> a tedy je potřeba se s tím vyrovnat</li>
</ul>
<h2 id="výsledky">Výsledky</h2>
<p>Každý z devíti programů jsem spustil stokrát a výsledné časy zprůměroval. Metodika nic moc, ale nějaká představa se z toho udělat dá.</p>
<table>
<tr>
<th>
</th>
<pre><code>       &lt;th&gt;Soubory&lt;/th&gt; &lt;th&gt;Adresáře&lt;/th&gt; &lt;th&gt;Mix&lt;/th&gt;&lt;/tr&gt;</code></pre>
<tr>
<th>
dvojitý průchod
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
<tr>
<td>
<code>stat()</code>
</td>
<td>
0,109
</td>
<td>
0,106
</td>
<pre><code>&lt;td&gt;0.107&lt;/td&gt;&lt;/tr&gt;</code></pre>
<tr>
<td>
<code>opendir()</code>
</td>
<td>
0,133
</td>
<td>
0,177
</td>
<pre><code>&lt;td&gt;0.155&lt;/td&gt;&lt;/tr&gt;</code></pre>
<tr>
<td>
<code>d_type</code>
</td>
<td>
0,043
</td>
<td>
0,040
</td>
<pre><code>&lt;td&gt;0.042&lt;/td&gt;&lt;/tr&gt;</code></pre>
<tr>
<th>
Pole
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
<tr>
<td>
<code>stat()</code>
</td>
<td>
0,054
</td>
<td>
0,057
</td>
<pre><code>&lt;td&gt;0.053&lt;/td&gt;&lt;/tr&gt;</code></pre>
<tr>
<td>
<code>opendir()</code>
</td>
<td>
0,067
</td>
<td>
0,091
</td>
<pre><code>&lt;td&gt;0.080&lt;/td&gt;&lt;/tr&gt;</code></pre>
<tr>
<td>
<code>d_type</code>
</td>
<td>
0,021
</td>
<td>
0,021
</td>
<pre><code>&lt;td&gt;0.020&lt;/td&gt;&lt;/tr&gt;</code></pre>
<tr>
<th>
Seznam
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
<tr>
<td>
<code>stat()</code>
</td>
<td>
0,053
</td>
<td>
0,060
</td>
<pre><code>&lt;td&gt;0.058&lt;/td&gt;&lt;/tr&gt;</code></pre>
<tr>
<td>
<code>opendir()</code>
</td>
<td>
0,065
</td>
<td>
0,091
</td>
<pre><code>&lt;td&gt;0.081&lt;/td&gt;&lt;/tr&gt;</code></pre>
<tr>
<td>
<code>d_type</code>
</td>
<td>
0,020
</td>
<td>
0,029
</td>
<pre><code>&lt;td&gt;0.022&lt;/td&gt;&lt;/tr&gt;</code></pre>
</table>
<p>Ponaučení na závěr? Na metodě procházení příliš nezáleží. To, co se s nalezenými položkami bude dít, pravděpodobně zabere výrazně víc času, takže jinou metodou procházení se nedá nic ušetřit.</p>
<p>Všechny <a href="/data/benchmark-dir.tar.bz2">zdrojové soubory</a> je možné si stáhnout včetně měřících skriptů. Skript <code>prepare.sh</code> vytvoří testovací složky, <code>measure.sh</code> spustí měření a <code>test.sh</code> ověřuje, že všechny programy dávají stejný výstup na třetím testovacím adresáři.</p>]]></summary>
</entry>
<entry>
    <title>O princezně, která ztrácela pamět</title>
    <link href="http://lubomir.github.io//cs/2011-11-10-o-princezne.html" />
    <id>http://lubomir.github.io//cs/2011-11-10-o-princezne.html</id>
    <published>2011-11-10T00:00:00Z</published>
    <updated>2011-11-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>Tento text vznikl v rámci přemětu VB000 Základy odborného stylu jako esej na téma <em>Bylo nebylo – informatická pohádka</em></p>
</blockquote>
<p>Za devatero kompilátory a devatero linkery bylo jedno malé, ale krásné království. V tomto království vládl moudrý král. Spravedlivě přiděloval paměť všem poddaným procesům, blahosklonně uzavíral pozapomenuté otevřené soubory a když některý z jeho poddaných dokončil svůj výpočet a přešel do stavu zombie, pečlivě sesbíral veškerou jeho paměť. Pod jeho vládou nebyl v celém království jediný neadresovatelný bajt.</p>
<p>Jedna věc ale dělala králi starosti: jeho jediná dcera, princezna a dědička systému. Byla to sice holka jako lusk, se sofistikovanou architekturou a intuitivním uživatelským rozhraním, na princeznu měla ale jednu zásadní vadu. Každý den si od krále vyžádala nový blok paměti, žádných se ale nikdy nevzdávala. A tak přestože před jejím spuštěním království nikdy netrpělo nouzí, s jejím rozmarným chováním se začaly denní příděly paměti všem poddaným snižovat.</p>
<p>Jednoho pochmurného dne se tedy stalo to, čeho se všichni obávali: v celém království nezbyl jediný volný bajt. Král svolal všechny své rádce, vyložil jim tuto nepříjemnou situaci a očekával návrhy řešení. „Budeme se modlit k velkému Uživateli, aby nám seslal další paměťový modul,“ navrhl některý z rádců. „To je výborný nápad, my ale potřebujeme něco rychlejšího a spolehlivějšího,“ oponoval jiný. Najednou se vzadu ozval králův věrný pobočník Oom: „Vaše Kernelovosti, máme jedinou možnost. Musíme princeznu zabít, paměť jí vzít a nakonec její proces znovu spustíme.“ Králi se toto řešení nelíbilo, přece jen svou dceru miloval, ale nakonec i on uznal, že je to jediné řešení.</p>
<p>Přestože se privilegovaným procesům takto podařilo krizi zažehnat, celá smutná situace se brzy začala opakovat. Král tedy pátral po trvalejším řešení a pozval optimalizáory a analyzátory z celého repozitáře. Aby je nějak motivoval, dal rozhlásit, že kdo napraví princeznu, dostane ji za ženu a půl pevného disku k tomu. Programy se stahovaly z celého Internetu, ať se ale snažily sebevíc, přivést princeznu k rozumu se jim nepodařilo.</p>
<p>Za pár dní v království nastalo pozdvižení. Na hranicích se objevil věhlasný mudrc ze vzdáleného Javistánu. Doprovázela ho početná kolekce objektů. Ve spojovém seznamu si vedl neznámé nástroje a jeho sluhové nesli obrovský binární strom z ezoterických jazyků. Všechny procesy v království do mudrce vkládaly velké naděje. Když ale mudrc přišel k princezně, ukázalo se, že ani pro něj nebude ladění jednoduché. První komplikace nastala, když se pokusil prozkoumat princezniny objekty a metody. Jeho obvyklé postupy selhaly! Princezna totiž nebyla objektová, ale procedurální!</p>
<p>Mudrc byl v úzkých. Postupy, na které byl navyklý, vůbec nezabíraly a s manuální správou paměti si také příliš nerozuměl. Ze své domoviny byl totiž navyklý, že se kolem něj neustále motá sluha a paměť po něm uklízí. I tento světoznámý mudrc tedy nakonec odjel s nepořízenou.</p>
<p>Král z toho byl zničený. Už se těšil, že bude mít, co se správy paměti týká, normální dceru, ale ladění se zase nepodařilo. Když se král vzpamatoval ze zklamání, rozzuřeně prohlásil: „Už žádné šarlatány. Kdo od teď neuspěje v ladění princezny, bude o zásobník kratší a jeho zdrojové kódy budou smazány.“</p>
<p>Zhruba ve stejné době se o nadělení s princeznou dozvěděl chytrý Valgrind. Byl to skromný chlapec, kterého sousedé považovali za trochu jednoduššího, především kvůli jeho textovému rozhraní. Ve skrytu haldy ale věděli, že k práci s pamětí má Valgrind talent. A tak si Valgrind řekl: „Už příliš dlouho se válím v rodném /usr/bin. Žádné přerušení mě tady z nudy nevytrhne, půjdu zkusit svoje štěstí.“ Sbalil si svoje kladivo Callgrind a sekeru Cachegrind a vyrazil.</p>
<p>Jenom se podíval na princeznu, už věděl, která bije. Vždyť ta holka churavá vůbec nepoužívá funkci free(). I když Valgrind věděl, jak na princezniny potíže, nemohl na ni jít zhurta. Nejprve si jenom navzájem posílali signály, ale když král zjistil, že už si naalokovali sdílený blok paměti, bylo jasné, že krize je zažehnána a v království zase nastala hojnost paměti.</p>
<p>Zakrátko se Valgrind s princeznou vzali a jestli dosud nespadli, tak spolu profilují dodnes.</p>]]></summary>
</entry>
<entry>
    <title>Kódování čísel</title>
    <link href="http://lubomir.github.io//cs/2011-06-06-kodovani-cisel.html" />
    <id>http://lubomir.github.io//cs/2011-06-06-kodovani-cisel.html</id>
    <published>2011-06-06T00:00:00Z</published>
    <updated>2011-06-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>V předmětu <a href="https://is.muni.cz/auth/predmety/predmet.pl?id=585364">IB047</a> se dá mimo jiné potkat s problémem, jak co nejúsporněji uložit data do souboru. Jako ideální řešení se ukáže použít nějaké vhodné kódování. A protože nejlépe člověk něco pochopí tak, že si to vyzkouší, napsal jsem si funkce pro kódování i dekódování různými metodami.</p>
<h2 id="varianty">Varianty</h2>
<p>První myslitelné kódování je klasický zápis čísla ve dvojkové soustavě. Jeho výhoda je velká úspornost, na druhou stranu každá posloupnost nul a jedniček se dá interpretovat jako číslo. My bychom ale chtěli poznat, kde jedno číslo končí a druhé začíná. Proto potřebujeme <em>bezprefixový</em> kód, tedy takový, aby žádné slovo nebylo prefixem jiného. Zároveň ale nechceme používat žádnou překladovou tabulku, takže <a href="http://cs.wikipedia.org/wiki/Huffmanovo_kódování">Huffmanovo kódování</a> je ze hry.</p>
<p>Nejjednodušší variantou, jak toho dosáhnout, je použít <em>unární</em> kódování. Číslo <span class="math"><em>n</em></span> zakóduje pomocí <span class="math"><em>n</em></span> nul následovaných jedničkou. Zřejmě je tedy bezprefixové, ale zároveň i paměťově neefektivní, protože délka kódu je lineární k velikosti kódovaného čísla.</p>
<p>Jako lepší nápad vypadá zapsání čísla binárně a přidání jeho délky pomocí nějakého bezprefixového kódu. To ale také není optimální, protože bychom nevyužili mnoho možností. Konkrétně jde o slova, která začínají nulami. V klasickém dvojkovém zápisu jsou čísla 00 a 0 stejná. Z našeho pohledu je ale užitečné je rozlišit. Proto pro každou délku kódu využijeme všechny možnosti, tedy pro slovem délky jedna budeme kódovat dvě čísla, délkou dvě čtyři atd.</p>
<p>Pro každé číslo tedy určíme délku slova, odečteme od něj nějakou hodnotu a převedeme do dvojkové soustavy. Délku určíme jako <span class="math">⌊log<sub>2<sub></sub></sub>(<em>n</em> + 1)⌋</span>. Zároveň z délky můžeme určit, o kolik zmenšit kódované číslo před převodem: <span class="math">2<sup><em>l</em></sup> − 1</span>.</p>
<h2 id="implementace">Implementace</h2>
<p>Nejdříve tedy definice typů.</p>
<pre class="haskell"><code>data Bit = Zero | One deriving (Eq)

instance Show Bit where
    show Zero = &quot;0&quot;
    show One  = &quot;1&quot;

type Stream = [Bit]</code></pre>
<p>Typy požadovaných funkcí vypadají následovně. Kódovací funkce pro číslo vrátí posloupnost bitů, dekódovací naopak z proudy bitů vytáhnou první číslo a vrátí ho společně se zbytkem proudu. Funkce <code>fromBinary</code> se liší v tom, že zpracuje celý proud.</p>
<pre class="haskell"><code>unary, binary, gamma, delta        :: Int -&gt; Stream
parseUnary, parseGamma, parseDelta :: Stream -&gt; (Int, Stream)
fromBinary :: Stream -&gt; Int</code></pre>
<p>Unární kódování je velice jednoduché. Operátor <code>(***) :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; (a, c) -&gt; (b, d)</code> se nachází v modulu <code>Control.Arrow</code> a jeho jediný účel je aplikace funkcí na složky dvojice.</p>
<pre class="haskell"><code>unary n    = replicate n Zero ++ [One]
parseUnary = (length *** tail) . span (== Zero)</code></pre>
<p>Funkce pro binární kódování čísla jsou trošku složitější, ale pořád tam není žádná magie. Provádí klasický přepis čísla do dvojkové soustavy. Pomocná funkce <code>binary'</code> navíc výsledný kód doplní zleva do požadované délky nulami. Také 0 při délce kódu 0 reprezentuje prázdným seznamem.</p>
<pre class="haskell"><code>binary = bin []
  where
    bin acc 0 = Zero : acc
    bin acc 1 = One  : acc
    bin acc n = bin ((if odd n then One else Zero) : acc) (n `div` 2)

binary&#39; :: Int -&gt; Int -&gt; Stream
binary&#39; 0 0 = []
binary&#39; len n = padding ++ code
  where code = binary n
        padding = replicate (len - length code) Zero

fromBinary = foldl (\num x -&gt; num * 2 + (if x == Zero then 0 else 1)) 0</code></pre>
<p>Myšlenku popsanou na začátku realizují mimo jiné <span class="math"><em>γ</em></span> a <span class="math"><em>δ</em></span> kódy. <span class="math"><em>γ</em></span>-kód pro délku slova používá unární kódování, <span class="math"><em>δ</em></span>-kód jde ještě dál a používá pro zapsání délky <span class="math"><em>γ</em></span>-kód. Zřejmě jsou si tedy v mnohém podobná a má smysl nejdřív napsat obecnější funkci.</p>
<pre class="haskell"><code>encodeWith :: (Int -&gt; Stream) -&gt; Int -&gt; Stream
encodeWith f n = f len ++ binary&#39; len (n - 2^len + 1)
  where len = floor . logBase 2 . fromIntegral $ n + 1

parseWith :: (Stream -&gt; (Int, Stream)) -&gt; Stream -&gt; (Int, Stream)
parseWith f s = (fromBinary bin + 2^len - 1, ss)
  where (len, rest) = f s
        (bin, ss)   = splitAt len rest</code></pre>
<p>S funkcemi <code>encodeWith</code>, <code>parseWith</code> je tedy implementace <span class="math"><em>γ</em></span> i <span class="math"><em>δ</em></span> kódování poměrně triviální.</p>
<pre class="haskell"><code>gamma = encodeWith unary
parseGamma = parseWith parseUnary

delta = encodeWith gamma
parseDelta = parseWith parseGamma</code></pre>
<p>Odtud už je jednoduché napsat funkci, které bude kódovat nebo dekódovat seznam čísel.</p>
<pre class="haskell"><code>encode :: (Int -&gt; Stream) -&gt; [Int] -&gt; Stream
encode = concatMap

decode :: (Stream -&gt; (Int, Stream)) -&gt; Stream -&gt; [Int]
decode f s = let (n, ss) = f s
             in case ss of
                  [] -&gt; [n]
                  _  -&gt; n : decode f ss</code></pre>
<p><strong>Upozornění</strong>: toto není úplně ideální implementace, protože umožňuje práci pouze s čísly omezené velikosti, navíc jsem se nesnažil o efektivitu, takže je to velice pomalé. Taky chybí jakákoli kontrola chyb.</p>]]></summary>
</entry>
<entry>
    <title>XMonad a okna s pevnou velikostí</title>
    <link href="http://lubomir.github.io//cs/2011-04-04-xmonad-a-okna-s-pevnou-velikosti.html" />
    <id>http://lubomir.github.io//cs/2011-04-04-xmonad-a-okna-s-pevnou-velikosti.html</id>
    <published>2011-04-04T00:00:00Z</published>
    <updated>2011-04-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Už docela dlouho k téměř úplné spokojenosti používám XMonad jako správce oken. Sice má své mouchy, ale přednosti to dostatečně vyvažují. Navíc se i ty mouchy dají odstranit.</p>
<p>Poslední věc, na kterou jsem narazil a která mě donutila upravit <code>xmonad.hs</code> bylo ne zrovna přátelské chování k oknům, která si nastavují nějakou požadovanou velikost. XMonad tyto rady totiž totálně ignoruje. Ve většině případů je to docela žádoucí chování, jediná výjimka jsou okna, u kterých nemá moc smysl měnit velikost. V mém případě šlo hlavně o <a href="http://www.frozen-bubble.org/">Frozen Bubble</a> a <a href="http://www.dosbox.com/">dosbox</a>.</p>
<p>Jedna možnost řešení by bylo vyjmenovat dotyčné aplikace a přímo oknům nastavit režim floating. To se mi ale nelíbilo, protože by to nebylo ani pohodlné, ani spolehlivé, a často bych musel měnit konfiguraci.</p>
<p>Společným znakem oken, která mají fixní velikost, je nastavení minimální a maximální velikosti okna na stejnou hodnotu. Toto nastavení je v <code>WM_NORMAL_HINTS</code> a dá se zjistit třeba přes <code>xprop</code>. Toto pole má typ <code>XSizeHints</code> a nejpřesnější popis, který jsem našel, vypadá takto:</p>
<pre class="c"><code>typedef struct {
    long flags;                /* marks which fields in this
                                  structure are defined */
    int x, y;                  /* Obsolete */
    int width, height;         /* Obsolete */
    int min_width, min_height;
    int max_width, max_height;
    int width_inc, height_inc;
    struct {
           int x;              /* numerator */
           int y;              /* denominator */
    } min_aspect, max_aspect;
    int base_width, base_height;
    int win_gravity;
    /* this structure may be extended in the future */
} XSizeHints;</code></pre>
<p>To jistě není žádný zázrak, ale už se s tím dá něco dělat. Zajímavé hodnoty jsou ty s prefixem <code>min_</code> a <code>max_</code>. Pokud jsou nastavené na jinou hodnotu než 0 a zároveň se rovnají odpovídající si hodnoty, okno má zřejmě nastavenou fixní velikost.</p>
<pre class="haskell"><code>isFixed :: [CLong] -&gt; Bool
isFixed h = minWidth h == maxWidth h
         &amp;&amp; minHeight h == maxHeight h
         &amp;&amp; all (&gt;0) [minWidth h, maxWidth h, minHeight h, maxHeight h]</code></pre>
<p>V modulu <code>XMonad.Util.WindowProperties</code> je k dispozici funkce <code>getProp32s :: String -&gt; Window -&gt; X (Maybe [CLong])</code>, s jejíž pomocí už se dá napsat potřebná funkce pro manage hook. Definice typu <code>CLong</code> je v modulu <code>Foreign.C.Types</code>.</p>
<pre class="haskell"><code>isNonResizable :: Query Bool
isNonResizable = ask &gt;&gt;= \w -&gt; liftX $ do
    atom &lt;- getProp32s &quot;WM_NORMAL_HINTS&quot; w
    return $ case atom of
        Just hints  -&gt; hasFixedSize hints
        Nothing     -&gt; False</code></pre>
<p>Poslední chybějící kus jsou funkce na vrácení požadovaných rozměrů. Vlastně jde jenom o čitelnější zápisy vytažení příslušné hodnoty ze seznamu:</p>
<pre class="haskell"><code>minWidth  = (!! 5) :: [CLong] -&gt; CLong
minHeight = (!! 6) :: [CLong] -&gt; CLong
maxWidth  = (!! 7) :: [CLong] -&gt; CLong
maxHeight = (!! 8) :: [CLong] -&gt; CLong</code></pre>
<p>A to je asi tak všechno. Zatím mám pocit, že to funguje, žádné chyby jsem nepozoroval. <a href="/data/HandleFixedWindows.hs">Kompletní soubor</a> stačí nakopírovat do <code>~/.xmonad/lib/</code>, naimportovat do konfiguračního souboru a použít.</p>]]></summary>
</entry>
<entry>
    <title>Znásilňování SICStus Prologu</title>
    <link href="http://lubomir.github.io//cs/2011-02-26-znasilnovani-sicstus-prologu.html" />
    <id>http://lubomir.github.io//cs/2011-02-26-znasilnovani-sicstus-prologu.html</id>
    <published>2011-02-26T00:00:00Z</published>
    <updated>2011-02-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="instalace">Instalace</h2>
<p>Nejdřív je potřeba stáhnout samotný program k instalaci z <a href="https://lindir.ics.muni.cz/sicstus/">této stránky</a> (pouze pro studenty FI a nekomerční použití). Přihlašuje se učem a sekundárním heslem. Je nutné stáhnout dva soubory: archiv s programem a soubor s příslušným licenčním klíčem.</p>
<p>Instalace je docela jednoduchá:</p>
<ol type="1">
<li>rozbalit archiv</li>
<li>v nově vytvořeném adresáři spustit <code>./InstallSICStus --all-questions</code></li>
<li>odpovědět na spoustu otázek
<ul>
<li>klíč a podobné věci jsou v druhém staženém souboru</li>
<li>pokud se zvolí vhodný adresář, není potřeba ani heslo roota</li>
<li>instalovat Tk, jasper, odbc ani nic podobného není nezbytně nutné</li>
<li>pokud se instaluje v systému s vyšší verzí GLibc než 2 je potřeba potvrdit, že opravdu chci instalovat</li>
</ul></li>
</ol>
<p>A to je asi tak vše. Další pokračování by mohla být instalace <a href="http://www.eclipse.org/">Eclipse</a> a IDE pro Prolog jménem <a href="http://www.sics.se/sicstus/spider/site/index.html">Spider</a>.</p>
<p>Případná odinstalace je relativně jednoduchá. Stačí si ponechat soubor <code>UnInstallSICStus</code> z adresáře, odkud se instalovalo. Je to primitivní shellový skript, který smaže všechny nainstalované soubory. Komentář v souboru sice tvrdí, že některé soubory neodstraní, ale nikde jsem žádné zbytky nenašel.</p>
<h2 id="použití">Použití</h2>
<p>Při instalaci se do adresáře <code>$PREFIX/bin</code> mimo jiné nainstaluje spustitelný soubor <code>sicstus</code>, což je přímo interpret. Tu stačí spustit a jsem skoro tam, kde jsme chtěli být.</p>
<p>To slovíčko „skoro“ je poměrně důležité. Interpret sice běží, ale zdaleka se nechová tak, aby se dal pohodlně používat. Například kurzor se nedá posunout šipkami doprostřed psaného dotazu a opravit překlep, po ukončení zůstane nezalomený řádek a posunutý prompt, nikde žádná historie dotazů …</p>
<p>Naštěstí to není nezvratný stav. Stačí nainstalovat utilitu <a href="http://utopia.knoware.nl/~hlub/rlwrap/">rlwrap</a> třeba ze standardních repozitářů a potom spouštět <code>rlwrap sicsus</code>. Výsledkem je stejný interpret, ale tentokrát se všemi výhodami knihovny readline, jako třeba funkční šipky nebo historie ukládaná do <code>~/.sicstus_history</code>, ve které se dá interaktivně vyhledávat přes <code>^R</code> nebo jenom šipkou nahoru/dolů. Možná to má někde nějaký háček, ale zatím jsem na nic nepřišel.</p>
<h3 id="někdo-to-rád-barevné">Někdo to rád barevné</h3>
<p>Rlwrap umožňuje pomocí přepínače <code>-p</code> (nebo <code>--promp-colour</code>) obarvit výzvu programu. Menší problém je ale v tom, že za prompt považuje i řádky, kde se vypisuje víc možných unifikací a interpret čeká na středník kvůli další možnosti. Osobně bych preferoval obarvení pouze klasické výzvy <code>| ?-</code> a podobných, které začínají znakem <code>|</code>.</p>
<p>Naštěstí si tohle přání můžu splnit pomocí filtru. Stačí si uložit <a href="/data/prolog_filter">tento filtr</a> ideálně do adresáře <code>/usr/share/rlwrap/filters</code> a potom spouštět pomocí <code>rlwrap -z 'prolog_filter Blue' sicstus</code>. Možnosti barev jsou <code>black</code>, <code>red</code>, <code>green</code>, <code>yellow</code>, <code>blue</code>, <code>purple</code>, <code>cyan</code> a <code>white</code>. Pokud je alespoň první písmeno velké, použije se tučná varianta.</p>
<h4 id="aktualizace-16.3.2011">Aktualizace 16</h4>
<p>Existuje i výrazně jednodušší řešení. Rlwrap umožňuje přepínači nastavit, které výzvy má „vařit“. Je to přepínač <code>-O regexp</code>, kde potřebný regulární výraz je <code>'^\|'</code>. Potom stačí použít klasicky <code>-pBARVA</code> (stejný výčet jako je výše) a už to funguje.</p>
<p>Taky se může hodit přidat přepínač <code>-g '^.$'</code>, což zakáže ukládání jednopísmenných odpovědí do historie.</p>
<h2 id="vim">Vim</h2>
<p>Vim sám o sobě Prolog moc nepodporuje. Nakopírováním těch <a href="https://github.com/adimit/prolog.vim">správných souborů</a> do <code>~/.vim/</code> se ale změní do celkem použitelné formy: sympaticky zvýrazňuje syntaxi, automaticky odsazuje řádky a sám pozná, kde začínají a končí foldy.</p>
<p>Poslední drobný zádrhel je v tom, že si většinou splete typ souboru s Perlem, který taky používá příponu <code>.pl</code>. Dá se to obejít přidáním modeline na konec souboru:</p>
<pre class="prolog"><code>% vim: ft=prolog</code></pre>]]></summary>
</entry>
<entry>
    <title>CPO a spojité funkce</title>
    <link href="http://lubomir.github.io//cs/2011-01-24-cpo-a-spojite-funkce.html" />
    <id>http://lubomir.github.io//cs/2011-01-24-cpo-a-spojite-funkce.html</id>
    <published>2011-01-24T00:00:00Z</published>
    <updated>2011-01-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Každý typ se dá charakterizovat jako částečně uspořádaná množina hodnot. Pokud platí, že každý spočetný řetězec má supremum, potom se jedná o <a href="http://en.wikipedia.org/wiki/Complete_partial_order">Complete Partial Order</a>.</p>
<h2 id="primitivní-typy----příklady">Primitivní typy -- příklady</h2>
<figure>
<img src="/images/unitt.png" alt="Unit⊥" /><figcaption>Unit<sub>⊥</sub></figcaption>
</figure>
<figure>
<img src="/images/boolt.png" alt="Bool⊥" /><figcaption>Bool<sub>⊥</sub></figcaption>
</figure>
<p>Značky <code>tt</code> a <code>ff</code> jsou jednoduše symboly pro pravdivou a nepravdivou hodnotu. Další primitivní typ je třeba typ všech celých čísel <code>Int</code>.</p>
<h2 id="operace-nad-typy">Operace nad typy</h2>
<p>Z primitivních typů je možné pomocí operací vytvářet další, bohatší typy.</p>
<dl>
<dt>Lift X</dt>
<dd>přidá ⊥ jako nejméně definovaný prvek do typu X. Dno (⊥) je menší než všechny původní prvky v X a jinak se touto operací uspořádání nemění. X × Y
</dd>
<dd>kartézský součin dvou typů (typ všech dvojic, kde první složka je typu X a druhá složka má typ Y). Pokud <span class="math"><em>x</em><sub>1</sub>, <em>x</em><sub>2</sub> ∈ <em>X</em>, <em>x</em><sub>1</sub> ≤ <em>x</em><sub>2</sub></span> a <span class="math"><em>y</em><sub>1</sub>, <em>y</em><sub>2</sub> ∈ <em>Y</em>, <em>y</em><sub>1</sub> ≤ <em>y</em><sub>2</sub></span>, potom platí <span class="math">(<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>) ≤ (<em>x</em><sub>2</sub>, <em>y</em><sub>2</sub>)</span>. <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> X + Y
</dd>
<dd>disjunktní sjednocení, hodnota tohoto typu obsahuje buď nějakou hodnotu typu X, nebo hodnotu typu Y (např. takto funguje <code>union</code> v C nebo <code>Either</code> v Haskellu) X → Y
</dd>
<dd>mocninný typ; typ všech spojitých funkcí, které hodnotu typu X zobrazí na hodnotu typu Y
</dd>
</dl>
<p>Další příklady jsou ve slidech z přednášky na straně 167</p>
<figure>
<img src="/images/bool-x-bool.png" alt="Bool⊥ × Bool⊥" /><figcaption>Bool<sub>⊥</sub> × Bool<sub>⊥</sub></figcaption>
</figure>
<h2 id="spojitost-funkce">Spojitost funkce</h2>
<blockquote>
<p>Funkce <span class="math"><em>f</em></span> je monotonní právě tehdy, když platí <span class="math">∀<em>a</em>, <em>b</em> : <em>a</em> ≤ <em>b</em> ⇒ <em>f</em>(<em>a</em>) ≤ <em>f</em>(<em>b</em>)</span>.</p>
</blockquote>
<p>Tedy: funkce <span class="math"><em>f</em></span> je monotonní, pokud pro každé dva prvky jejího definičního oboru platí, že pokud je jeden méně definovaný než jiný, tak potom jejich obrazy na tom budou stejně.</p>
<p>Takže například funkce <span class="math"><em>f</em></span> je monotonní, ale funkce <span class="math"><em>g</em></span> monotonní není.</p>
<pre><code>f () = True
f ⊥ = True

g () = True
g ⊥ = False</code></pre>
<p>Spojitost funkce je ještě trochu silnější pojem. Každá spojitá funkce je i monotonní. Obrácené tvrzení neplatí, existují i nespojité monotonní funkce. Platí ale, že každá monotonní funkce s konečným definičním oborem (doménou) je spojitá<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>.</p>
<blockquote>
<p>Funkce <span class="math"><em>f</em></span> je spojitá, pokud pro každý spočetný řetězec <span class="math"><em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, …</span> platí <span class="math"><em>f</em>(⨆(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, …)) = ⨆(<em>f</em>(<em>x</em><sub>1</sub>), <em>f</em>(<em>x</em><sub>2</sub>), …)</span></p>
</blockquote>
<p>(Značka <span class="math">⨆</span> značí supremum, nejmenší horní závoru, least upper bound. Horní závora nějaké podmnožiny je prvek, který je větší než libovolný prvek dané podmnožiny.)</p>
<p>Definice tedy říká, že obraz suprema libovolného řetězce musí být supremem obrazů jednotlivých prvků řetězce.</p>
<p>Česky: pokud se vezme libovolný spočetný řetězec a funkcí <span class="math"><em>f</em></span> zobrazíme jeho supremum, tak musíme dostat totéž, jako kdybychom postupně zobrazili všechny prvky daného řetězce a našli supremum obrazů.</p>
<h2 id="všechny-unit-bool">Všechny Unit<sub>⊥</sub> → Bool<sub>⊥</sub></h2>
<p>Zadání: Napište všechny spojité funkce typu Unit<sub>⊥</sub> → Bool<sub>⊥</sub>. Co je to funkce s tímto typem? Takováto funkce musí každé hodnotě z Unit<sub>⊥</sub> přiřadit něco z Bool<sub>⊥</sub>.</p>
<figure>
<img src="/images/unit-bool2.png" alt="Všechny funkce Unit⊥ → Bool⊥" /><figcaption>Všechny funkce Unit<sub>⊥</sub> → Bool<sub>⊥</sub></figcaption>
</figure>
<p>Tyto funkce by bylo vhodné taky seřadit do diagramu, aby bylo patrné, jak to uspořádání na nich funguje. Pro jednoduchost je každou funkci možné zakreslit jako diagram ve tvaru definičního oboru, kde se místo původních prvků na stejná místa doplní hodnota, na kterou se ten který prvek zobrazí.</p>
<figure>
<img src="/images/unit-bool.png" alt="Uspořádání na Unit⊥ → Bool⊥" /><figcaption>Uspořádání na Unit<sub>⊥</sub> → Bool<sub>⊥</sub></figcaption>
</figure>
<p>Pro jiný typ funkcí to může dopadnout třeba tak, jako na obrázku níž.</p>
<figure>
<img src="/images/bool-bool.png" alt="Bool⊥ → Bool⊥" /><figcaption>Bool<sub>⊥</sub> → Bool<sub>⊥</sub></figcaption>
</figure>
<h2 id="striktní-funkce">Striktní funkce</h2>
<p>Striktní funkce je taková funkce, která nejdříve vyhodnotí svůj argument a potom s ním teprve něco počítá. Pokud je tedy argument nedefinovaný, nemůže být definovaný ani výsledek výpočtu. Pro striktní funkci tedy platí <strong>f ⊥ = ⊥</strong>.</p>
<h2 id="odkazy">Odkazy</h2>
<ol type="1">
<li><a href="http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/">Hussling Haskell types into Hasse diagrams</a></li>
<li><a href="http://blog.ezyang.com/2010/12/gin-and-monotonic/">Gin and monotonic</a></li>
<li><a href="http://blog.ezyang.com/2010/12/getting-a-fix-on-fixpoints/">Getting a fix on fixpoints</a></li>
</ol>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>drobný detail: pokaždé se jedná o jiné <span class="math"> ≤ </span>, protože se porovnává v jiné doméně<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>takže pro naprostou většinu příkladů na zkoušce PB006 stačí ověřovat monotonicitu<a href="#fnref2">↩</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>Poznámky k IB107</title>
    <link href="http://lubomir.github.io//cs/2011-01-02-poznamky-k-ib107.html" />
    <id>http://lubomir.github.io//cs/2011-01-02-poznamky-k-ib107.html</id>
    <published>2011-01-02T00:00:00Z</published>
    <updated>2011-01-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="věta-o-numeraci">Věta o numeraci</h2>
<blockquote>
<p>Pro každé <span class="math"><em>j</em> ≥ 1</span> existuje vyčíslitelná funkce <span class="math">Φ : <em>N</em><sup><em>j</em> + 1</sup> → <em>N</em></span>, která je univerzální pro standardní numeraci j-árních funkcí. Tedy pro každé <span class="math"><em>e</em> ∈ <em>N</em></span> a <span class="math">(<em>a</em><sub>1</sub>, …<em>a</em><sub><em>j</em></sub>) ∈ <em>N</em><sup><em>j</em></sup></span> platí <img src="/images/veta-o-numeraci.png" alt="Věta o numeraci" /></p>
</blockquote>
<p>Pro každou aritu tedy existuje funkce <span class="math">Φ</span>, která bere o jeden argument víc -- potřebuje ještě index programu, který má simulovat. Důkaz věty spočívá v definici interpretu -- programu, který bude simulovat jiné programy.</p>
<h2 id="věta-o-parametrizaci">Věta o parametrizaci</h2>
<blockquote>
<p>Ke každému <span class="math"><em>n</em> ≥ 1</span>, <span class="math"><em>m</em> ≥ 1</span> existuje totálně vyčíslitelná funkce <span class="math"><em>s</em><sup><em>m</em></sup><sub><em>n</em></sub> : <em>N</em><sup><em>m</em> + 1</sup> → <em>N</em></span>, taková, že platí <img src="/images/veta-o-parametrizaci.png" alt="Věta o parametrizaci" /></p>
</blockquote>
<p>Takže: existuje funkce <span class="math"><em>s</em></span>, která pro index programu <span class="math"><em>i</em></span> a <span class="math"><em>m</em></span> jeho argumentů spočítá index jiného programu, který bude dělat totéž co <span class="math"><em>i</em></span>, ale bude potřebovat o <span class="math"><em>m</em></span> argumentů méně. Funkce <span class="math"><em>s</em></span> vlastně zafixuje prvních <span class="math"><em>m</em></span> argumentů na nějaké konstanty. <span class="math"><em>m</em></span> je tady počet fixovaných parametrů, <span class="math"><em>n</em></span> počet těch, které se nefixují.</p>
<p>Dokazuje se pomocí programu, který celou konstrukci realizuje -- má <span class="math"><em>m</em></span> konstant a přesypává argumenty tak, aby to sedělo. Prvních <span class="math"><em>n</em></span> argumentů posune o <span class="math"><em>m</em></span> pozic doprava a na uvolněná místa dosadí konstanty. Pozor, aby se při posunování nepřepsalo něco, co bude ještě potřeba.</p>
<h2 id="první-riceova-věta">První Riceova věta</h2>
<blockquote>
<p>Nechť <span class="math"><em>I</em> ⊂ <em>N</em></span> je netriviální (není prázdná ani se nerovná <span class="math"><em>N</em></span>) a rekurzivní. Potom existují indexy programů <span class="math"><em>i</em> ∈ <em>I</em></span> a <span class="math"><em>j</em> ∈ <em>I</em>′</span><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> tak, že <span class="math"><em>ϕ</em><sub><em>i</em></sub> = <em>ϕ</em><sub><em>j</em></sub></span>.</p>
</blockquote>
<p>Tedy pokud je netriviální podmnožina <span class="math"><em>N</em></span> rekurzivní, potom nerespektuje funkce a naopak pokud nějaká množina respektuje funkce a je netriviální, potom nemůže být rekurzivní.</p>
<p>Důkaz se provede sporem: předpokládejme, že množina respektuje funkce a že množina <span class="math"><em>I</em></span> obsahuje index nějaké vyčíslitelné funkce<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> <span class="math"><em>θ</em></span>, která není prázdná. <span class="math"><em>I</em>′</span> potom obsahuje indexy prázdné funkce. Kdyby tomu tak nebylo, tak se prohodí <span class="math"><em>I</em></span> a <span class="math"><em>I</em>′</span>.</p>
<p>Nechť <span class="math"><em>P</em><sub><em>f</em>(<em>i</em>)</sub></span> je program <code>begin</code> <span class="math"><em>x</em><sub>2</sub></span> <code>:=</code> <span class="math">Φ(<em>i</em>, <em>i</em>)</span><code>;</code> <span class="math"><em>x</em><sub>1</sub></span> <code>:=</code> <span class="math"><em>θ</em>(<em>x</em><sub>1</sub>)</span> <code>end</code>. Zřejmě program <span class="math"><em>P</em></span> počítá funkci <span class="math"><em>θ</em></span>, pokud <span class="math"><em>ϕ</em><sub><em>i</em></sub>(<em>i</em>)</span> je definované a jinak počítá prázdnou funkci.</p>
<p>Tedy pro všechna <span class="math"><em>i</em> ∈ <em>N</em></span> platí <span class="math"><em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub> = <em>θ</em></span> právě tehdy když <span class="math"><em>i</em> ∈ <em>K</em></span>.</p>
<p>Pokud tedy <span class="math"><em>f</em>(<em>i</em>) ∈ <em>I</em></span>, pak <span class="math"><em>f</em>(<em>i</em>)</span> není index prázdné funkce. Je to index <span class="math"><em>θ</em></span>. Obráceně pokud <span class="math"><em>f</em>(<em>i</em>)</span> je indexem funkce <span class="math"><em>θ</em></span>, pak <span class="math"><em>f</em>(<em>i</em>) ∈ <em>I</em></span>. Nechť <span class="math"><em>χ</em><sub><em>I</em></sub></span> je charakteristická funkce <span class="math"><em>I</em></span>. Pro všechna <span class="math"><em>i</em> ∈ <em>N</em></span> musí platit <img src="/images/prvni-riceova-veta-tvrzeni.png" alt="Tvrzení 1" /></p>
<p>Protože <span class="math"><em>χ</em><sub><em>I</em></sub> ∘ <em>f</em></span> je totálně vyčíslitelná, musela by <span class="math"><em>K</em></span> být rekurzivní, což zřejmě není.</p>
<h2 id="druhá-riceova-věta">Druhá Riceova věta</h2>
<blockquote>
<p>Necht <span class="math"><em>I</em> ⊂ <em>N</em></span> respektuje funkce a nechť existuje funkce <span class="math"><em>θ</em></span> taková, že všechny její indexy jsou v <span class="math"><em>I</em></span> a má vyčíslitelné rozšíření <span class="math"><em>θ</em>′</span> takové, že jeho indexy patří do <span class="math"><em>I</em>′</span>.</p>
<p><span class="math"><em>I</em></span> potom není rekurzivně spočetná.</p>
</blockquote>
<p>Důkaz půjde zase sporem. Nechť funkce <span class="math"><em>ξ</em>(<em>i</em>, <em>j</em>)</span> se rovná <span class="math"><em>θ</em>′(<em>j</em>)</span>, pokud <span class="math"><em>ϕ</em><sub><em>i</em></sub>(<em>i</em>)</span> je definováno a jinak se rovná <span class="math"><em>θ</em>(<em>j</em>)</span>. Tato funkce je vyčíslitelná<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>. Podle <a href="#věta-o-parametrizaci">věty o parametrizaci</a> existuje totálně vyčíslitelná funkce <span class="math"><em>f</em> : <em>N</em> → <em>N</em></span> taková, že <span class="math"><em>ξ</em>(<em>i</em>, <em>j</em>) = <em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub>(<em>j</em>)</span>. <span class="math"><em>f</em>(<em>i</em>)</span> potom patří do <span class="math"><em>I</em></span> právě tehdy, když <span class="math"><em>ϕ</em><sub><em>i</em></sub>(<em>i</em>)</span> není definováno. Tj. <span class="math"><em>f</em>(<em>i</em>) ∈ <em>I</em> ≡ <em>i</em> ∈ <em>K</em>′</span>.</p>
<p>Pokud by tedy <span class="math"><em>I</em></span> byla rekurzivně spočetná, tak i <span class="math"><em>K</em>′</span> by musela být rekurzivně spočetná. To ale není.</p>
<p>Při použití druhé Riceovy věty je tedy zřejmě potřeba zvolit <span class="math"><em>θ</em></span> tak, aby nebyla totální. Jinak by totiž neměla potřebné rozšíření.</p>
<h2 id="třetí-riceova-věta">Třetí Riceova věta</h2>
<blockquote>
<p>Nechť <span class="math"><em>I</em> ⊂ <em>N</em></span> respektuje funkce a nechť existuje funkce <span class="math"><em>θ</em></span> taková, že všechny její indexy patří do <span class="math"><em>I</em></span> a navíc všechna její konečná zúžení patří do <span class="math"><em>I</em>′</span>.</p>
<p><span class="math"><em>I</em></span> potom není rekurzivně spočetná.</p>
</blockquote>
<p>Důkaz se opět provede sporem. Nechť funkce <span class="math"><em>μ</em>(<em>i</em>, <em>j</em>)</span> počítá <span class="math"><em>θ</em>(<em>j</em>)</span>, pokud <span class="math"><em>P</em><sub><em>i</em></sub></span> nezastaví pro vstup <span class="math"><em>i</em></span> během nejvýše <span class="math"><em>j</em></span> kroků. Pokud zastaví během nejvýše <span class="math"><em>j</em></span> kroků, <span class="math"><em>μ</em></span> se zacyklí. Funkce <span class="math"><em>μ</em></span> je zřejmě vyčíslitelná.</p>
<p>Podle <a href="#věta-o-parametrizaci">věty o parametrizaci</a> existuje totálně vyčíslitelná funkce <span class="math"><em>f</em></span> tak, že <span class="math"><em>μ</em>(<em>i</em>, <em>j</em>) = <em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub>(<em>j</em>)</span>.</p>
<p>Dostaneme tedy, že pokud <span class="math"><em>i</em> ∈ <em>K</em></span>, tak <span class="math"><em>P</em><sub><em>i</em></sub></span> zastaví pro <span class="math"><em>i</em></span>. Tedy existuje <span class="math"><em>j</em></span> takové, že <span class="math"><em>P</em><sub><em>i</em></sub></span> zastaví pro <span class="math"><em>i</em></span> po <strong>přesně</strong> <span class="math"><em>j</em></span> krocích. Tj. existuje <span class="math"><em>j</em></span> takové, že <span class="math"><em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub>(<em>x</em>)</span> počítá <span class="math"><em>θ</em>(<em>x</em>)</span> pro všechna <span class="math"><em>x</em></span> menší než <span class="math"><em>j</em></span> a jinak je nedefinované. Potom ale <span class="math"><em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub></span> je zúžením <span class="math"><em>θ</em></span> a její definiční obor je konečný, tedy <span class="math"><em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub> ∈ <em>I</em>′</span>.</p>
<p>Z druhé strany platí, že když <span class="math"><em>i</em> ∈ <em>K</em>′</span>, tak <span class="math"><em>P</em><sub><em>i</em></sub></span> nikdy nezastaví a <span class="math"><em>ϕ</em><sub><em>f</em>(<em>i</em>)</sub></span> počítá celou <span class="math"><em>θ</em></span> a tedy patří do <span class="math"><em>I</em></span>.</p>
<p>Tedy <span class="math"><em>i</em> ∈ <em>K</em>′ ≡ <em>f</em>(<em>i</em>) ∈ <em>I</em></span> a <span class="math"><em>I</em></span> nemůže být rekurzivně spočetná.</p>
<p>Třetí Riceovu větu tedy zřejmě nejde použít, pokud <span class="math"><em>I</em></span> obsahuje prázdnou funkci. Ta je totiž konečným zúžením každé funkce.</p>
<h2 id="časová-složitost">Časová složitost</h2>
<h3 id="f-in-og"><span class="math"><em>f</em> ∈ <em>O</em>(<em>g</em>)</span></h3>
<p>Funkce <span class="math"><em>f</em></span> roste nejvýše tak rychle jako <span class="math"><em>g</em></span>.</p>
<blockquote>
<p><span class="math">∃<em>c</em>, <em>n</em><sub>0</sub> : ∀<em>n</em> ≥ <em>n</em><sub>0</sub> : <em>f</em>(<em>n</em>) ≤ <em>c</em><em>g</em>(<em>n</em>)</span></p>
</blockquote>
<h3 id="f-in-og-1"><span class="math"><em>f</em> ∈ <em>o</em>(<em>g</em>)</span></h3>
<p>Funkce <span class="math"><em>f</em></span> roste pomaleji než <span class="math"><em>g</em></span></p>
<figure>
<img src="/images/f-in-og.png" title="\lim{n \to \infty}\frac{f(n)}{g(n)} = 0" />
</figure>
<h3 id="f-in-omegag"><span class="math"><em>f</em> ∈ Ω(<em>g</em>)</span></h3>
<p>Funkce <span class="math"><em>f</em></span> roste alespoň tak rychle jako <span class="math"><em>g</em></span></p>
<figure>
<img src="/images/f-in-Omega-g.png" title="\exists n_0, c: \forall n \geq n_0 : f(n) \geq \frac{1}{c} g(n)" />
</figure>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>apostrofem označím doplněk množiny<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>a tedy všechny její indexy<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Nejdřív se začne paralelně (pomocí step counteru) počítat <span class="math"><em>θ</em>(<em>j</em>)</span> a <span class="math"><em>ϕ</em><sub><em>i</em></sub>(<em>i</em>)</span>. Pokud první skončí <span class="math"><em>θ</em>(<em>j</em>)</span>, vrátí se její výsledek. Pokud by první skončil výpočet <span class="math"><em>ϕ</em><sub><em>i</em></sub>(<em>i</em>)</span>, začne se přímo simulovat <span class="math"><em>θ</em>′(<em>j</em>)</span>.<a href="#fnref3">↩</a></p></li>
</ol>
</section>]]></summary>
</entry>

</feed>
