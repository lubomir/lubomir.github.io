<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="../css/bootstrap.css">
    <link rel="alternate" type="application/rss+xml" href="../rss.xml">
    <link rel="icon" type="image/vnd.microsoft.icon" href="../favicon.ico">
    <title>Derivací k regulárním výrazům</title>
  </head>

  <body id="top">

    <div class="container">
      <h1>Derivací k regulárním výrazům</h1>

<div class="row metainfo">
    <div class="col-md-4">
        <a href="../">zpět na hlavní stránku</a>
    </div>
    <div class="col-md-4">
        <strong>20. březen 2012</strong>
    </div>

    <div class="col-md-4">
        <span>Označeno jako: <a href="../cs/tags/haskell.html">Haskell</a>, <a href="../cs/tags/regularni-vyrazy.html">regulární výrazy</a>.</span>
    </div>
</div>

<div class="post">
<p>V předmětu <a href="http://www.fi.muni.cz/~sojka/PV030/">PV030</a> se člověk mimo jiné potká s algoritmy pro práci s regulárními výrazy. Jedním z nich je i metoda konverze regulárního výrazu na konečný automat, a ne nedeterministický s <span class="math"><em>ϵ</em></span>-kroky. Touto metodou je možné rovnou vyrobit minimální deterministický konečný automat. A jak lépe porozumět algoritmu než si ho zkusit naprogramovat?</p>
<p>Podrobnější popis je algoritmu je k dispozici <a href="http://www.fi.muni.cz/~sojka/PV030/2012-03-15.pdf">ve slidech</a>, případně ve článku <a href="http://dl.acm.org/citation.cfm?id=321249"><em>Derivatives of Regular Expressions</em></a>, jehož autorem je <em>Janusz A. Brzozowski</em>.</p>
<figure>
<img src="../images/regex0.png" alt="a^*b+(c+d+e)a" /><figcaption><span class="math"><em>a</em><sup> * </sup><em>b</em> + (<em>c</em> + <em>d</em> + <em>e</em>)<em>a</em></span></figcaption>
</figure>
<h2 id="importujeme">Importujeme</h2>
<p>Budeme potřebovat importovat několik modulů, většinu z nich pro parsování výrazu.</p>
<pre class="haskell"><code>import qualified Data.Map as M
import qualified Data.Set as S
import Text.Parsec.Char
import Text.Parsec.String
import Text.Parsec.Combinator
import Text.Parsec.Prim
import Text.Parsec.Expr
import Control.Applicative ((&lt;*), (*&gt;))
import Data.Maybe (fromMaybe)
import Data.List (tails, foldl')</code></pre>
<h2 id="datové-typy">Datové typy</h2>
<p>Je potřeba nějak reprezentovat jak samotný regulární výraz, tak i výsledný automat. Regexp je možné reprezentovat jako strom. Listy jsou základní výrazy, uzly potom zřetězení, alternativa a iterace.</p>
<p>Později budeme potřebovat určovat, jestli nějaký regulární výraz popisuje (mimo jiné) prázdné slovo. Pro urychlení tedy u těch konstruktorů, kde to není zřejmé, přidáme tuto informaci.</p>
<pre class="haskell"><code>data Regex a = Epsilon
             | Zero
             | Simple a
             | Plus Bool (Regex a) (Regex a)
             | Conc Bool (Regex a) (Regex a)
             | Iter (Regex a)
             deriving (Eq, Ord, Show)</code></pre>
<p>Pro konečný automat bude potřeba další typ. Automat má nějaké přechody, množinu stavů a počáteční stav. Položka <code>isAccepting</code> je funkce, která pro stav řekne, jestli je akceptující.</p>
<pre class="haskell"><code>type Node = Regex Char  -- ^ Popisek stavu

data FiniteAutomaton = FiniteAutomaton
                     { transitions :: M.Map (Node,Char) Node
                     , states      :: S.Set Node
                     , startNode   :: Node
                     , isAccepting :: Node -&gt; Bool
                     }</code></pre>
<p>V první řadě nadefinujeme tři pomocné funkce pro spojování regexpů, které se postarají o korektní vyplnění pomocné boolovské části a taky zabrání vzniku několika patologických výrazů – např. nemá smysl řetězit něco s prázdným slovem. Jiný příklad je výraz <code>(E*)*</code>, který je ekvivalentní s <code>E*</code> (a navíc vede k zacyklení).</p>
<pre class="haskell"><code>plus :: Regex a -&gt; Regex a -&gt; Regex a
plus Zero x = x
plus x Zero = x
plus x y    = Plus (canBeEpsilon x || canBeEpsilon y) x y

conc :: Regex a -&gt; Regex a -&gt; Regex a
conc Epsilon x = x
conc x Epsilon = x
conc Zero _    = Zero
conc _ Zero    = Zero
conc x y       = Conc (canBeEpsilon x &amp;&amp; canBeEpsilon y) x y

iter :: Regex a -&gt; Regex a
iter (Iter x) = Iter x
iter x        = Iter x</code></pre>
<p>Jak jsem psal výše, musíme být schopní pro daný výraz <span class="math"><em>E</em></span> určit, jestli <span class="math"><em>L</em>(<em>E</em>)</span> obsahuje <span class="math"><em>ϵ</em></span>. Vzhledem k tomu, kolikrát se tato funkce bude volat při derivování, by bylo dobré, aby dokázala fungovat v konstantním čase.</p>
<pre class="haskell"><code>canBeEpsilon :: Regex a -&gt; Bool
canBeEpsilon Epsilon      = True
canBeEpsilon Zero         = False
canBeEpsilon (Simple _)   = False
canBeEpsilon (Conc e _ _) = e
canBeEpsilon (Plus e _ _) = e
canBeEpsilon (Iter _)     = True</code></pre>
<h2 id="parsování">Parsování</h2>
<p>A nyní hurá na parsování. <code>Parsec</code> nabízí úžasné možnosti, jak parsovat aritmetické i jiné výrazy. Jediná složitější věc je tady parser pro jednotlivý znak, protože umožňuje využít zpětného lomítka k escapování znaků hvězdičky, plusu a závorek, které by jinak měly speciální význam.</p>
<pre class="haskell"><code>regexP, termP, simpleP :: Parser (Regex Char)
regexP = buildExpressionParser table termP
termP = simpleP &lt;|&gt; char '(' *&gt; regexP &lt;* char ')'
table = [ [ Postfix $ char '*' &gt;&gt; return iter ]
        , [Infix (return conc) AssocLeft]
        , [Infix (char '+' &gt;&gt; return plus) AssocLeft]
        ]
simpleP = do
    c' &lt;- noneOf &quot;()+*&quot;
    c &lt;- if c' == '\\'
            then anyChar
            else return c'
    return (Simple c)</code></pre>
<p>Parser <code>regexP</code> teď můžeme obalit pomocnou funkcí.</p>
<pre class="haskell"><code>fromString :: String -&gt; Regex Char
fromString str = case parse (regexP &lt;* eof) &quot;&quot; str of
    Left _  -&gt; Zero
    Right r -&gt; r</code></pre>
<h2 id="derivace">Derivace</h2>
<p>Funkce pro derivaci regulárních výrazů je skoro doslovným přepisem definice ze <a href="http://www.fi.muni.cz/~sojka/PV030/2012-03-15.pdf">slidů</a>.</p>
<pre class="haskell"><code>derive :: Eq a =&gt; Regex a -&gt; a -&gt; Regex a
derive Zero    _      = Zero
derive Epsilon _      = Zero
derive (Simple x) y
    | x == y          = Epsilon
    | otherwise       = Zero
derive (Plus _ p q) x = plus (derive p x) (derive q x)
derive (Conc _ p q) x
    | canBeEpsilon p  = plus (conc (derive p x) q) (derive q x)
    | otherwise       = conc (derive p x) q
derive (Iter p) x     = conc (derive p x) (iter p)</code></pre>
<h2 id="konstrukce-automatu">Konstrukce automatu</h2>
<p>A můžeme budovat automat! Samotný algoritmus běží v cyklu <code>run</code>, v kterém postupně vytvoříme jak množinu stavů, tak tabulku přechodů.</p>
<p>V každé iteraci vezmeme všechny regulární výrazy z fronty <code>q</code> a každý zderivujeme každým písmenem abecedy. Z těchto všech derivací přidáme nové stavy a přechody mezi ty, co už jsme napočítali. Zároveň nově přidané stavy tvoří novou frontu.</p>
<p>Nemá smysl přidávat žádné hrany, které vedou do stavu odpovídajícího regexpu <code>Zero</code>, tím se jenom zbytečně zvětšuje tabulka přechodů.</p>
<pre class="haskell"><code>toFA :: String -&gt; Regex Char -&gt; FiniteAutomaton
toFA alphabet re = FiniteAutomaton { startNode = re
                                   , transitions = allTransitions
                                   , states = allStates
                                   , isAccepting = canBeEpsilon
                                   }
  where
    (allStates, allTransitions) = run (S.singleton re, M.empty) [re]

    run res []  = res
    run (s,t) q = run (newStates, newTransitions) newQueue
        where
            allD           = [ ((r,a), derive r a) | r &lt;- q, a &lt;- alphabet ]
            derivedStates  = S.fromList $ map snd allD
            newStates      = s `S.union` derivedStates
            newTransitions = M.union t $ M.fromList $ filter ((/= Zero) . snd) allD
            newQueue       = S.toList $ S.difference derivedStates s</code></pre>
<h2 id="práce-s-automatem">Práce s automatem</h2>
<p>Když má automat přejít pod nějakým znakem z jednoho stavu do dalšího, podíváme se do tabulky a pokud je přechod nedefinovaný, interpretujeme to jako přechod do stavu <code>Zero</code>.</p>
<pre class="haskell"><code>transition :: FiniteAutomaton -&gt; Node -&gt; Char -&gt; Node
transition fa q a = fromMaybe Zero $ M.lookup (q,a) (transitions fa)</code></pre>
<p>Pro spuštění automatu nad nějakým slovem tedy začneme v počátečním stavu a postupně automat krmíme znaky ze vstupu. Nakonec stačí zkontrolovat, jestli jsme došli do akceptujícího stavu.</p>
<pre class="haskell"><code>runFA :: FiniteAutomaton -&gt; String -&gt; Bool
runFA fa str = isAccepting fa $ foldl' (transition fa) (startNode fa) str</code></pre>
<p>Teď už můžeme zabalit vytváření automatu do jediné funkce.</p>
<pre class="haskell"><code>strToFA :: String -&gt; FiniteAutomaton
strToFA str =  toFA (getAlphabet str) $ fromString str
  where
    getAlphabet = filter (`notElem` &quot;()*+&quot;)</code></pre>
<p>Pomocí této funkce můžeme vytvořit jednoduchý operátor, který porovná řetězec s regulárním výrazem <span class="math"><em>E</em></span> a zjistí, jestli dané slovo patří do <span class="math"><em>L</em>(<em>E</em>)</span>.</p>
<pre class="haskell"><code>(=~) :: String -&gt; String -&gt; Bool
str =~ regex = runFA (strToFA regex) str</code></pre>
<p>Nalezení všech odpovídajících podřetězců je maličko složitější. Postupně spustíme automat na všechny sufixy řetězce a zapamatujeme si, kde jsme došli do akceptujícího stavu. Zároveň ale zastavíme, když dorazíme do stavu <code>Zero</code>, protože z něj už není úniku.</p>
<pre class="haskell"><code>allMatches :: RE -&gt; String -&gt; [(Int, Int)]
allMatches re str = concatMap (uncurry $ run 1 (startNode fa)) starts
  where
    fa = strToFA re
    starts = zip [0..] (tails str)

    run _ _    _ []        = []
    run _ Zero _ _         = []
    run end q start (a:as) = let newQ = transition fa q a
                             in if isAccepting fa newQ
                                    then (start, end) : run (end + 1) newQ start as
                                    else                run (end + 1) newQ start as</code></pre>
<h2 id="další-úpravy">Další úpravy</h2>
<p>V tomhle stavu program při výpočtu tráví naprostou většinu času porovnáváním regulárních výrazů. Bylo by pěkné zbavit se jich a místo nich používat pro označování stavů čísla. To už ale dělat nebudu.</p>
<figure>
<img src="../images/regex1.png" alt="tis+ti+iti" /><figcaption>tis+ti+iti</figcaption>
</figure>
<h2 id="aktualizace">Aktualizace</h2>
<dl>
<dt>2012–07</dt>
<dd>upraveno tak, aby <code>(E*)*</code> nevedlo k zacyklení; doplněn odkaz na původní článek
</dd>
</dl>
</div>

    </div><!-- .container -->

    <footer class="container">
        <ul class="nav nav-pills">
          <li><a href="../">Domů</a></li>
          <li><a href="#top">Nahoru</a></li>
          <li class="last"><a href="mailto:lubomir.sedlar@gmail.com">Kontakt</a></li>
          <li class="license"><a href="http://creativecommons.org/licenses/by/4.0/">
            <img src="../images/cc-by.png" alt="CC-BY" title="Licencováno jako Creative Commons Attribution"></a>
          </li>
        </ul>
    </footer><!-- .container -->

    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-40665960-1']);
        _gaq.push(['_trackPageview']);
        (function() {
         var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
         ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
         var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
         })();
     </script>
  </body>
</html>
