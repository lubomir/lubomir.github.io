<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="../css/bootstrap.css">
    <link rel="alternate" type="application/rss+xml" href="../rss.xml">
    <link rel="icon" type="image/vnd.microsoft.icon" href="../favicon.ico">
    <title>Kódování čísel</title>
  </head>

  <body id="top">

    <div class="container">
      <h1>Kódování čísel</h1>

<div class="row metainfo">
    <div class="col-md-4">
        <a href="../">zpět na hlavní stránku</a>
    </div>
    <div class="col-md-4">
        <strong>6. červen 2011</strong>
    </div>

    <div class="col-md-4">
        <span>Označeno jako: <a href="../cs/tags/kodovani.html">kódování</a>, <a href="../cs/tags/haskell.html">Haskell</a>, <a href="../cs/tags/programovani.html">programování</a>.</span>
    </div>
</div>

<div class="post">
<p>V předmětu <a href="https://is.muni.cz/auth/predmety/predmet.pl?id=585364">IB047</a> se dá mimo jiné potkat s problémem, jak co nejúsporněji uložit data do souboru. Jako ideální řešení se ukáže použít nějaké vhodné kódování. A protože nejlépe člověk něco pochopí tak, že si to vyzkouší, napsal jsem si funkce pro kódování i dekódování různými metodami.</p>
<h2 id="varianty">Varianty</h2>
<p>První myslitelné kódování je klasický zápis čísla ve dvojkové soustavě. Jeho výhoda je velká úspornost, na druhou stranu každá posloupnost nul a jedniček se dá interpretovat jako číslo. My bychom ale chtěli poznat, kde jedno číslo končí a druhé začíná. Proto potřebujeme <em>bezprefixový</em> kód, tedy takový, aby žádné slovo nebylo prefixem jiného. Zároveň ale nechceme používat žádnou překladovou tabulku, takže <a href="http://cs.wikipedia.org/wiki/Huffmanovo_kódování">Huffmanovo kódování</a> je ze hry.</p>
<p>Nejjednodušší variantou, jak toho dosáhnout, je použít <em>unární</em> kódování. Číslo <span class="math"><em>n</em></span> zakóduje pomocí <span class="math"><em>n</em></span> nul následovaných jedničkou. Zřejmě je tedy bezprefixové, ale zároveň i paměťově neefektivní, protože délka kódu je lineární k velikosti kódovaného čísla.</p>
<p>Jako lepší nápad vypadá zapsání čísla binárně a přidání jeho délky pomocí nějakého bezprefixového kódu. To ale také není optimální, protože bychom nevyužili mnoho možností. Konkrétně jde o slova, která začínají nulami. V klasickém dvojkovém zápisu jsou čísla 00 a 0 stejná. Z našeho pohledu je ale užitečné je rozlišit. Proto pro každou délku kódu využijeme všechny možnosti, tedy pro slovem délky jedna budeme kódovat dvě čísla, délkou dvě čtyři atd.</p>
<p>Pro každé číslo tedy určíme délku slova, odečteme od něj nějakou hodnotu a převedeme do dvojkové soustavy. Délku určíme jako <span class="math">⌊log<sub>2<sub></sub></sub>(<em>n</em> + 1)⌋</span>. Zároveň z délky můžeme určit, o kolik zmenšit kódované číslo před převodem: <span class="math">2<sup><em>l</em></sup> − 1</span>.</p>
<h2 id="implementace">Implementace</h2>
<p>Nejdříve tedy definice typů.</p>
<pre class="haskell"><code>data Bit = Zero | One deriving (Eq)

instance Show Bit where
    show Zero = &quot;0&quot;
    show One  = &quot;1&quot;

type Stream = [Bit]</code></pre>
<p>Typy požadovaných funkcí vypadají následovně. Kódovací funkce pro číslo vrátí posloupnost bitů, dekódovací naopak z proudy bitů vytáhnou první číslo a vrátí ho společně se zbytkem proudu. Funkce <code>fromBinary</code> se liší v tom, že zpracuje celý proud.</p>
<pre class="haskell"><code>unary, binary, gamma, delta        :: Int -&gt; Stream
parseUnary, parseGamma, parseDelta :: Stream -&gt; (Int, Stream)
fromBinary :: Stream -&gt; Int</code></pre>
<p>Unární kódování je velice jednoduché. Operátor <code>(***) :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; (a, c) -&gt; (b, d)</code> se nachází v modulu <code>Control.Arrow</code> a jeho jediný účel je aplikace funkcí na složky dvojice.</p>
<pre class="haskell"><code>unary n    = replicate n Zero ++ [One]
parseUnary = (length *** tail) . span (== Zero)</code></pre>
<p>Funkce pro binární kódování čísla jsou trošku složitější, ale pořád tam není žádná magie. Provádí klasický přepis čísla do dvojkové soustavy. Pomocná funkce <code>binary'</code> navíc výsledný kód doplní zleva do požadované délky nulami. Také 0 při délce kódu 0 reprezentuje prázdným seznamem.</p>
<pre class="haskell"><code>binary = bin []
  where
    bin acc 0 = Zero : acc
    bin acc 1 = One  : acc
    bin acc n = bin ((if odd n then One else Zero) : acc) (n `div` 2)

binary' :: Int -&gt; Int -&gt; Stream
binary' 0 0 = []
binary' len n = padding ++ code
  where code = binary n
        padding = replicate (len - length code) Zero

fromBinary = foldl (\num x -&gt; num * 2 + (if x == Zero then 0 else 1)) 0</code></pre>
<p>Myšlenku popsanou na začátku realizují mimo jiné <span class="math"><em>γ</em></span> a <span class="math"><em>δ</em></span> kódy. <span class="math"><em>γ</em></span>-kód pro délku slova používá unární kódování, <span class="math"><em>δ</em></span>-kód jde ještě dál a používá pro zapsání délky <span class="math"><em>γ</em></span>-kód. Zřejmě jsou si tedy v mnohém podobná a má smysl nejdřív napsat obecnější funkci.</p>
<pre class="haskell"><code>encodeWith :: (Int -&gt; Stream) -&gt; Int -&gt; Stream
encodeWith f n = f len ++ binary' len (n - 2^len + 1)
  where len = floor . logBase 2 . fromIntegral $ n + 1

parseWith :: (Stream -&gt; (Int, Stream)) -&gt; Stream -&gt; (Int, Stream)
parseWith f s = (fromBinary bin + 2^len - 1, ss)
  where (len, rest) = f s
        (bin, ss)   = splitAt len rest</code></pre>
<p>S funkcemi <code>encodeWith</code>, <code>parseWith</code> je tedy implementace <span class="math"><em>γ</em></span> i <span class="math"><em>δ</em></span> kódování poměrně triviální.</p>
<pre class="haskell"><code>gamma = encodeWith unary
parseGamma = parseWith parseUnary

delta = encodeWith gamma
parseDelta = parseWith parseGamma</code></pre>
<p>Odtud už je jednoduché napsat funkci, které bude kódovat nebo dekódovat seznam čísel.</p>
<pre class="haskell"><code>encode :: (Int -&gt; Stream) -&gt; [Int] -&gt; Stream
encode = concatMap

decode :: (Stream -&gt; (Int, Stream)) -&gt; Stream -&gt; [Int]
decode f s = let (n, ss) = f s
             in case ss of
                  [] -&gt; [n]
                  _  -&gt; n : decode f ss</code></pre>
<p><strong>Upozornění</strong>: toto není úplně ideální implementace, protože umožňuje práci pouze s čísly omezené velikosti, navíc jsem se nesnažil o efektivitu, takže je to velice pomalé. Taky chybí jakákoli kontrola chyb.</p>
</div>

    </div><!-- .container -->

    <footer class="container">
        <ul class="nav nav-pills">
          <li><a href="../">Domů</a></li>
          <li><a href="#top">Nahoru</a></li>
          <li class="last"><a href="mailto:lsedlar@mail.muni.cz">Kontakt</a></li>
          <li class="license"><a href="http://creativecommons.org/licenses/by/4.0/">
            <img src="../images/cc-by.png" alt="CC-BY" title="Licencováno jako Creative Commons Attribution"></a>
          </li>
        </ul>
    </footer><!-- .container -->

    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-40665960-1']);
        _gaq.push(['_trackPageview']);
        (function() {
         var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
         ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
         var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
         })();
     </script>
  </body>
</html>
