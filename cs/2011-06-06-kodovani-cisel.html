<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:400,700&subset=latin,latin-ext" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="../css/bootstrap.css">
    <link rel="alternate" type="application/rss+xml" href="../rss.xml">
    <link rel="icon" type="image/vnd.microsoft.icon" href="../favicon.ico">
    <title>Kódování čísel</title>
  </head>

  <body id="top">

    <div class="container">
      <h1>Kódování čísel</h1>

<div class="row metainfo">
    <div class="col-md-4">
        <a href="../">zpět na hlavní stránku</a>
    </div>
    <div class="col-md-4">
        <strong>6. červen 2011</strong>
    </div>

    <div class="col-md-4">
        <span>Označeno jako: <a href="../cs/tags/kodovani.html">kódování</a>, <a href="../cs/tags/haskell.html">Haskell</a>, <a href="../cs/tags/programovani.html">programování</a>.</span>
    </div>
</div>

<div class="post">
    <article>
        <p>V předmětu <a href="https://is.muni.cz/auth/predmety/predmet.pl?id=585364">IB047</a> se dá mimo jiné potkat s problémem, jak co nejúsporněji uložit data do souboru. Jako ideální řešení se ukáže použít nějaké vhodné kódování. A protože nejlépe člověk něco pochopí tak, že si to vyzkouší, napsal jsem si funkce pro kódování i dekódování různými metodami.</p>
<h2 id="varianty">Varianty</h2>
<p>První myslitelné kódování je klasický zápis čísla ve dvojkové soustavě. Jeho výhoda je velká úspornost, na druhou stranu každá posloupnost nul a jedniček se dá interpretovat jako číslo. My bychom ale chtěli poznat, kde jedno číslo končí a druhé začíná. Proto potřebujeme <em>bezprefixový</em> kód, tedy takový, aby žádné slovo nebylo prefixem jiného. Zároveň ale nechceme používat žádnou překladovou tabulku, takže <a href="http://cs.wikipedia.org/wiki/Huffmanovo_kódování">Huffmanovo kódování</a> je ze hry.</p>
<p>Nejjednodušší variantou, jak toho dosáhnout, je použít <em>unární</em> kódování. Číslo <span class="math inline"><em>n</em></span> zakóduje pomocí <span class="math inline"><em>n</em></span> nul následovaných jedničkou. Zřejmě je tedy bezprefixové, ale zároveň i paměťově neefektivní, protože délka kódu je lineární k velikosti kódovaného čísla.</p>
<p>Jako lepší nápad vypadá zapsání čísla binárně a přidání jeho délky pomocí nějakého bezprefixového kódu. To ale také není optimální, protože bychom nevyužili mnoho možností. Konkrétně jde o slova, která začínají nulami. V klasickém dvojkovém zápisu jsou čísla 00 a 0 stejná. Z našeho pohledu je ale užitečné je rozlišit. Proto pro každou délku kódu využijeme všechny možnosti, tedy pro slovem délky jedna budeme kódovat dvě čísla, délkou dvě čtyři atd.</p>
<p>Pro každé číslo tedy určíme délku slova, odečteme od něj nějakou hodnotu a převedeme do dvojkové soustavy. Délku určíme jako <span class="math inline">⌊log<sub>2<sub></sub></sub>(<em>n</em> + 1)⌋</span>. Zároveň z délky můžeme určit, o kolik zmenšit kódované číslo před převodem: <span class="math inline">2<sup><em>l</em></sup> − 1</span>.</p>
<h2 id="implementace">Implementace</h2>
<p>Nejdříve tedy definice typů.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Bit</span> <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">|</span> <span class="dt">One</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>)

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Bit</span> <span class="kw">where</span>
    show <span class="dt">Zero</span> <span class="fu">=</span> <span class="st">&quot;0&quot;</span>
    show <span class="dt">One</span>  <span class="fu">=</span> <span class="st">&quot;1&quot;</span>

<span class="kw">type</span> <span class="dt">Stream</span> <span class="fu">=</span> [<span class="dt">Bit</span>]</code></pre></div>
<p>Typy požadovaných funkcí vypadají následovně. Kódovací funkce pro číslo vrátí posloupnost bitů, dekódovací naopak z proudy bitů vytáhnou první číslo a vrátí ho společně se zbytkem proudu. Funkce <code>fromBinary</code> se liší v tom, že zpracuje celý proud.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">unary, binary, gamma,<span class="ot"> delta        ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span>
parseUnary, parseGamma,<span class="ot"> parseDelta ::</span> <span class="dt">Stream</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Stream</span>)
<span class="ot">fromBinary ::</span> <span class="dt">Stream</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre></div>
<p>Unární kódování je velice jednoduché. Operátor <code>(***) :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; (a, c) -&gt; (b, d)</code> se nachází v modulu <code>Control.Arrow</code> a jeho jediný účel je aplikace funkcí na složky dvojice.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">unary n    <span class="fu">=</span> replicate n <span class="dt">Zero</span> <span class="fu">++</span> [<span class="dt">One</span>]
parseUnary <span class="fu">=</span> (length <span class="fu">***</span> tail) <span class="fu">.</span> span (<span class="fu">==</span> <span class="dt">Zero</span>)</code></pre></div>
<p>Funkce pro binární kódování čísla jsou trošku složitější, ale pořád tam není žádná magie. Provádí klasický přepis čísla do dvojkové soustavy. Pomocná funkce <code>binary'</code> navíc výsledný kód doplní zleva do požadované délky nulami. Také 0 při délce kódu 0 reprezentuje prázdným seznamem.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">binary <span class="fu">=</span> bin []
  <span class="kw">where</span>
    bin acc <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">:</span> acc
    bin acc <span class="dv">1</span> <span class="fu">=</span> <span class="dt">One</span>  <span class="fu">:</span> acc
    bin acc n <span class="fu">=</span> bin ((<span class="kw">if</span> odd n <span class="kw">then</span> <span class="dt">One</span> <span class="kw">else</span> <span class="dt">Zero</span>) <span class="fu">:</span> acc) (n <span class="ot">`div`</span> <span class="dv">2</span>)

<span class="ot">binary' ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span>
binary' <span class="dv">0</span> <span class="dv">0</span> <span class="fu">=</span> []
binary' len n <span class="fu">=</span> padding <span class="fu">++</span> code
  <span class="kw">where</span> code <span class="fu">=</span> binary n
        padding <span class="fu">=</span> replicate (len <span class="fu">-</span> length code) <span class="dt">Zero</span>

fromBinary <span class="fu">=</span> foldl (\num x <span class="ot">-&gt;</span> num <span class="fu">*</span> <span class="dv">2</span> <span class="fu">+</span> (<span class="kw">if</span> x <span class="fu">==</span> <span class="dt">Zero</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> <span class="dv">1</span>)) <span class="dv">0</span></code></pre></div>
<p>Myšlenku popsanou na začátku realizují mimo jiné <span class="math inline"><em>γ</em></span> a <span class="math inline"><em>δ</em></span> kódy. <span class="math inline"><em>γ</em></span>-kód pro délku slova používá unární kódování, <span class="math inline"><em>δ</em></span>-kód jde ještě dál a používá pro zapsání délky <span class="math inline"><em>γ</em></span>-kód. Zřejmě jsou si tedy v mnohém podobná a má smysl nejdřív napsat obecnější funkci.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">encodeWith ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span>
encodeWith f n <span class="fu">=</span> f len <span class="fu">++</span> binary' len (n <span class="fu">-</span> <span class="dv">2</span><span class="fu">^</span>len <span class="fu">+</span> <span class="dv">1</span>)
  <span class="kw">where</span> len <span class="fu">=</span> floor <span class="fu">.</span> logBase <span class="dv">2</span> <span class="fu">.</span> fromIntegral <span class="fu">$</span> n <span class="fu">+</span> <span class="dv">1</span>

<span class="ot">parseWith ::</span> (<span class="dt">Stream</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Stream</span>)) <span class="ot">-&gt;</span> <span class="dt">Stream</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Stream</span>)
parseWith f s <span class="fu">=</span> (fromBinary bin <span class="fu">+</span> <span class="dv">2</span><span class="fu">^</span>len <span class="fu">-</span> <span class="dv">1</span>, ss)
  <span class="kw">where</span> (len, rest) <span class="fu">=</span> f s
        (bin, ss)   <span class="fu">=</span> splitAt len rest</code></pre></div>
<p>S funkcemi <code>encodeWith</code>, <code>parseWith</code> je tedy implementace <span class="math inline"><em>γ</em></span> i <span class="math inline"><em>δ</em></span> kódování poměrně triviální.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gamma <span class="fu">=</span> encodeWith unary
parseGamma <span class="fu">=</span> parseWith parseUnary

delta <span class="fu">=</span> encodeWith gamma
parseDelta <span class="fu">=</span> parseWith parseGamma</code></pre></div>
<p>Odtud už je jednoduché napsat funkci, které bude kódovat nebo dekódovat seznam čísel.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">encode ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span>) <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Stream</span>
encode <span class="fu">=</span> concatMap

<span class="ot">decode ::</span> (<span class="dt">Stream</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Stream</span>)) <span class="ot">-&gt;</span> <span class="dt">Stream</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
decode f s <span class="fu">=</span> <span class="kw">let</span> (n, ss) <span class="fu">=</span> f s
             <span class="kw">in</span> <span class="kw">case</span> ss <span class="kw">of</span>
                  [] <span class="ot">-&gt;</span> [n]
                  _  <span class="ot">-&gt;</span> n <span class="fu">:</span> decode f ss</code></pre></div>
<p><strong>Upozornění</strong>: toto není úplně ideální implementace, protože umožňuje práci pouze s čísly omezené velikosti, navíc jsem se nesnažil o efektivitu, takže je to velice pomalé. Taky chybí jakákoli kontrola chyb.</p>
    </article>

    <h2 class="comments-header">Komentáře</h2>

    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function () {
            this.page.url = "https://lubomir.github.io//cs/2011-06-06-kodovani-cisel.html";
            this.page.identifier = "/cs/2011-06-06-kodovani-cisel.html";
        };
        (function() {
            var d = document, s = d.createElement('script');
            s.src = '//indexoflsedlar.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>

    </div><!-- .container -->

    <footer class="container">
        <ul class="nav nav-pills">
          <li><a href="../">Domů</a></li>
          <li><a href="#top">Nahoru</a></li>
          <li><a href="mailto:lubomir.sedlar@gmail.com">Kontakt</a></li>
          <li class="last"><a href="../cookies.html">Cookies</a></li>
          <li class="license"><a href="http://creativecommons.org/licenses/by/4.0/">
            <img src="../images/cc-by.png" alt="CC-BY" title="Licencováno jako Creative Commons Attribution"></a>
          </li>
        </ul>
    </footer><!-- .container -->

    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-40665960-1']);
        _gaq.push(['_trackPageview']);
        (function() {
         var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
         ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
         var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
         })();
        window.cookieconsent_options = {"message":"This website uses some cookies.","dismiss":"Got it!","learnMore":"More info","link":"/cookies.html","theme":"dark-floating"};
     </script>
     <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/1.0.9/cookieconsent.min.js"></script>
  </body>
</html>
