<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="../css/bootstrap.css">
    <link rel="alternate" type="application/rss+xml" href="../rss.xml">
    <link rel="icon" type="image/vnd.microsoft.icon" href="../favicon.ico">
    <title>UnitTest v C++</title>
  </head>

  <body id="top">

    <div class="container">
      <h1>UnitTest v C++</h1>

<div class="row metainfo">
    <div class="col-md-4">
        <a href="../">zpět na hlavní stránku</a>
    </div>
    <div class="col-md-4">
        <strong>19. prosinec 2010</strong>
    </div>

    <div class="col-md-4">
        <span>Označeno jako: <a href="../cs/tags/programovani.html">programování</a>, <a href="../cs/tags/c%2B%2B.html">C++</a>, <a href="../cs/tags/testy.html">testy</a>.</span>
    </div>
</div>

<div class="post">
<p>Unit testy jsou užitečná věc, pokud je třeba testovat jednotlivé funkce, třídy nebo metody. Většinou využívá nějakou knihovnu, což má oproti psaní testovacích kódů ručně výhodu v tom, že knihovna minimalizuje potřebu psát zbytečný kód okolo a rovnou poskytuje metody pro testování a případně i měření výkonu.</p>
<p>Já používám knihovnu <a href="http://unittest-cpp.sourceforge.net/">UnitTest++</a>, která je rozumným kompromisem mezi funkcionalitou a jednoduchostí.</p>
<h2 id="použití">Použití</h2>
<p>Testy pomocí UnitTest++ je možné psát do libovolného souboru s příponou <code>.cpp</code> i <code>.cc</code>, jak je komu libo. Pro kompilaci je potřeba kompilátoru předat informace o tom, kde najde příslušné hlavičkové soubory a potom i knihovnu. Obojí jsem zkompiloval a je na Aise dostupné v adresáři <code>/home/~xsedlar3/include</code>.</p>
<p>Na začátku testovacího souboru je pochopitelně třeba vložit hlavičky knihovny vlastního kódu, který je třeba testovat.</p>
<pre class="cpp"><code>#include &lt;unittest++/UnitTest++.h&gt;</code></pre>
<p>Ke spouštění testů je třeba přidat i funkci <code>main</code>:</p>
<pre class="cpp"><code>int main() {
    return UnitTest::RunAllTests();
}</code></pre>
<h2 id="testy">Testy</h2>
<p>Jednotlivé testy se píšou pomocí maker <code>TEST</code>, které má jeden parametr -- identifikátor, podle kterého půjde dohledávat, který test selhal. Následuje blok, ve kterém se provádí test.</p>
<pre class="cpp"><code>TEST(Addition) {
    CHECK(someFunction());
}</code></pre>
<p>K usnadnění psaní testů je definováno několik šikovných maker jako je výše uvedené <code>CHECK</code>. To jednoduše kontroluje, jestli se jeho argument vyhodnotí na <code>true</code>. Další možnosti jsou třeba <code>CHECK_EQUAL(co_cekam, testovany_vyraz)</code>, které ověří, že testovaný výraz vrací určenou hodnotu. Pořadí argumentů je tady docela důležité, pokud bude očekávaná hodnota jako druhá, případně chyby budou hlášené dost chaoticky. Další makra jsou popsána v <a href="http://unittest-cpp.sourceforge.net/UnitTest++.html">dokumentaci</a>.</p>
<p>Aby se i ve velkém souboru s testy dalo dobře orientovat, je možné jednotlivé testy dělit do sad pomocí makra <code>SUITE(nazev)</code>, případně je rozdělit do více souborů.</p>
<p>Jednoduchý test tedy může vypadat takto:</p>
<pre class="cpp"><code>TEST(InsertValueAtStart) {
    List&lt;int&gt; list;
    List&lt;int&gt;::ItemType *iter;

    iter = list.push_front(10);
    CHECK( ! list.empty());
    CHECK_EQUAL(10, it-&gt;getValue());
    CHECK_EQUAL(10, list.first()-&gt;getValue());
    CHECK_EQUAL(10, list.last()-&gt;getValue());
}</code></pre>
<h2 id="fixtures">Fixtures</h2>
<p>Při psaní testů se dá velice rychle narazit na situaci, že se na začátku několika testů opakuje stejná část, která jenom chystá objekt na další testovaní, např. plní seznam daty. Toto se dá zjednodušit přesunutím takovéto inicializace do tzv. fixture.</p>
<p>V případě knihovny UnitTest++ se jedná o definici třídy, jejíž konstruktor se zavolá na začátku testu, kde je použitá, a celý test se potom vykonává tak, že má přímo přístup k členským prvkům dané třídy. Místo makra <code>TEST</code> se potom použije <code>TEST_FIXTURE</code> se dvěma argumenty. Prvním je právě název fixture.</p>
<p>Může to tedy vypadat takto:</p>
<pre class="cpp"><code>struct LongList {
    LongList() {
        it1 = list.push_back(10);
        it2 = list.push_back(20);
        it3 = list.push_back(30);
        it4 = list.push_back(40);
        it5 = list.push_back(50);
        it6 = list.push_back(60);
    }

    std::string to_str() { return list_to_str(list); }

    List&lt;int&gt; list;
    List&lt;int&gt;::ItemType *it1, *it2, *it3, *it4, *it5, *it6;
};

TEST_FIXTURE(LongList, SwapTwoDistinctIntervals) {
    list.push_back(70);
    list.swap(it2, it3, it5, it6);
    CHECK_EQUAL(&quot;{ 10, 50, 60, 40, 20, 30, 70 }&quot;, to_str());
    list.swap(it5, it6, it2, it3);
    CHECK_EQUAL(&quot;{ 10, 20, 30, 40, 50, 60, 70 }&quot;, to_str());
}</code></pre>
</div>

    </div><!-- .container -->

    <footer class="container">
        <ul class="nav nav-pills">
          <li><a href="../">Domů</a></li>
          <li><a href="#top">Nahoru</a></li>
          <li class="last"><a href="mailto:lubomir.sedlar@gmail.com">Kontakt</a></li>
          <li class="license"><a href="http://creativecommons.org/licenses/by/4.0/">
            <img src="../images/cc-by.png" alt="CC-BY" title="Licencováno jako Creative Commons Attribution"></a>
          </li>
        </ul>
    </footer><!-- .container -->

    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-40665960-1']);
        _gaq.push(['_trackPageview']);
        (function() {
         var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
         ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
         var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
         })();
     </script>
  </body>
</html>
